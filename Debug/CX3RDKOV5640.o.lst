   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"CX3RDKOV5640.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.section	.bss.glEp0Buffer,"aw",%nobits
  17              		.align	2
  20              	glEp0Buffer:
  21 0000 00000000 		.space	32
  21      00000000 
  21      00000000 
  21      00000000 
  21      00000000 
  22              		.comm	uvcAppThread,168,4
  23              		.comm	SenAppThread,168,4
  24              		.comm	glTimerEvent,40,4
  25              		.comm	cmdQu,32,4
  26              		.comm	statQu,32,4
  27              		.comm	cmdQuMux,56,4
  28              		.comm	statQuMux,56,4
  29              		.comm	timMux,56,4
  30              		.comm	imgHdMux,56,4
  31              		.section	.bss.UvcTimer,"aw",%nobits
  32              		.align	2
  35              	UvcTimer:
  36 0000 00000000 		.space	44
  36      00000000 
  36      00000000 
  36      00000000 
  36      00000000 
  37              		.section	.text.UvcAppProgressTimer,"ax",%progbits
  38              		.align	2
  40              	UvcAppProgressTimer:
  41              	.LFB0:
  42              		.file 1 "../CX3RDKOV5640.c"
   1:../CX3RDKOV5640.c **** /*
   2:../CX3RDKOV5640.c ****  ## e-con Systems USB UVC Stack – See3CAMCX3RDK Platform
   3:../CX3RDKOV5640.c **** 
   4:../CX3RDKOV5640.c ****  ## source file : CX3RDKOV5640.c
   5:../CX3RDKOV5640.c ****  ## ===========================
   6:../CX3RDKOV5640.c ****  ##
   7:../CX3RDKOV5640.c ****  ##  Copyright E-Con Systems, 2013-2014,
   8:../CX3RDKOV5640.c ****  ##  All Rights Reserved
   9:../CX3RDKOV5640.c ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
  10:../CX3RDKOV5640.c ****  ##
  11:../CX3RDKOV5640.c ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  12:../CX3RDKOV5640.c ****  ##  PROPERTY OF ECON SYSTEMS
  13:../CX3RDKOV5640.c **** 
  14:../CX3RDKOV5640.c ****  ## www.e-consystems.com
  15:../CX3RDKOV5640.c ****  ##
  16:../CX3RDKOV5640.c ****  ##
  17:../CX3RDKOV5640.c ****  ## ===========================
  18:../CX3RDKOV5640.c **** */
  19:../CX3RDKOV5640.c **** 
  20:../CX3RDKOV5640.c **** #include "cyu3system.h"
  21:../CX3RDKOV5640.c **** #include "cyu3os.h"
  22:../CX3RDKOV5640.c **** #include "cyu3dma.h"
  23:../CX3RDKOV5640.c **** #include "cyu3error.h"
  24:../CX3RDKOV5640.c **** #include "cyu3usb.h"
  25:../CX3RDKOV5640.c **** #include "cyu3i2c.h"
  26:../CX3RDKOV5640.c **** #include "cyu3uart.h"
  27:../CX3RDKOV5640.c **** #include "cyu3gpio.h"
  28:../CX3RDKOV5640.c **** #include "cyu3utils.h"
  29:../CX3RDKOV5640.c **** #include "cyu3pib.h"
  30:../CX3RDKOV5640.c **** #include "cyu3socket.h"
  31:../CX3RDKOV5640.c **** #include "sock_regs.h"
  32:../CX3RDKOV5640.c **** #include "cyu3mipicsi.h"
  33:../CX3RDKOV5640.c **** 
  34:../CX3RDKOV5640.c **** //#include "CX3OV5640Lib.h"
  35:../CX3RDKOV5640.c **** #include "CX3RDKOV5640.h"
  36:../CX3RDKOV5640.c **** #include "sensor.h"
  37:../CX3RDKOV5640.c **** #include "cmdqu.h"
  38:../CX3RDKOV5640.c **** #include "uvc.h"
  39:../CX3RDKOV5640.c **** 
  40:../CX3RDKOV5640.c **** /* Event generated on Timer overflow*/
  41:../CX3RDKOV5640.c **** #define ES_TIMER_RESET_EVENT		(1<<4)
  42:../CX3RDKOV5640.c **** 
  43:../CX3RDKOV5640.c **** /* Event generated on a USB Suspend Request*/
  44:../CX3RDKOV5640.c **** #define ES_USB_SUSP_EVENT_FLAG		(1<<5)
  45:../CX3RDKOV5640.c **** 
  46:../CX3RDKOV5640.c **** /* Firmware version*/
  47:../CX3RDKOV5640.c **** #define MajorVersion 				1
  48:../CX3RDKOV5640.c **** #define MinorVersion 				3
  49:../CX3RDKOV5640.c **** #define SubVersion					133
  50:../CX3RDKOV5640.c **** #define SubVersion1					309
  51:../CX3RDKOV5640.c **** #define RESET_TIMER_ENABLE 1
  52:../CX3RDKOV5640.c **** 
  53:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
  54:../CX3RDKOV5640.c **** #define TIMER_PERIOD	(500)
  55:../CX3RDKOV5640.c **** 
  56:../CX3RDKOV5640.c **** /****** for VIS debugging ******/
  57:../CX3RDKOV5640.c **** //#define VISDebug
  58:../CX3RDKOV5640.c **** 
  59:../CX3RDKOV5640.c **** /*************End***************/
  60:../CX3RDKOV5640.c **** 
  61:../CX3RDKOV5640.c **** /******* The Global Variables from FX3 code *******/
  62:../CX3RDKOV5640.c **** //VdRingBuf     cmdQu, statQu;
  63:../CX3RDKOV5640.c **** CyU3PMutex    cmdQuMux, statQuMux, timMux, imgHdMux;
  64:../CX3RDKOV5640.c **** 
  65:../CX3RDKOV5640.c **** /******************* End **************************/
  66:../CX3RDKOV5640.c **** 
  67:../CX3RDKOV5640.c **** static CyU3PTimer        UvcTimer;
  68:../CX3RDKOV5640.c **** 
  69:../CX3RDKOV5640.c **** static void UvcAppProgressTimer (uint32_t arg)
  70:../CX3RDKOV5640.c **** {
  43              		.loc 1 70 0
  44              		.cfi_startproc
  45              		@ args = 0, pretend = 0, frame = 8
  46              		@ frame_needed = 1, uses_anonymous_args = 0
  47 0000 00482DE9 		stmfd	sp!, {fp, lr}
  48              	.LCFI0:
  49              		.cfi_def_cfa_offset 8
  50              		.cfi_offset 11, -8
  51              		.cfi_offset 14, -4
  52 0004 04B08DE2 		add	fp, sp, #4
  53              	.LCFI1:
  54              		.cfi_def_cfa 11, 4
  55 0008 08D04DE2 		sub	sp, sp, #8
  56 000c 08000BE5 		str	r0, [fp, #-8]
  71:../CX3RDKOV5640.c ****     /* This frame has taken too long to complete.
  72:../CX3RDKOV5640.c ****      * Abort it, so that the next frame can be started. */
  73:../CX3RDKOV5640.c ****     CyU3PEventSet(&glTimerEvent, ES_TIMER_RESET_EVENT,CYU3P_EVENT_OR);
  57              		.loc 1 73 0
  58 0010 10009FE5 		ldr	r0, .L2
  59 0014 1010A0E3 		mov	r1, #16
  60 0018 0020A0E3 		mov	r2, #0
  61 001c FEFFFFEB 		bl	_txe_event_flags_set
  74:../CX3RDKOV5640.c **** }
  62              		.loc 1 74 0
  63 0020 04D04BE2 		sub	sp, fp, #4
  64              		@ sp needed
  65 0024 0088BDE8 		ldmfd	sp!, {fp, pc}
  66              	.L3:
  67              		.align	2
  68              	.L2:
  69 0028 00000000 		.word	glTimerEvent
  70              		.cfi_endproc
  71              	.LFE0:
  73              		.global	glDMATxCount
  74              		.section	.bss.glDMATxCount,"aw",%nobits
  75              		.align	2
  78              	glDMATxCount:
  79 0000 00000000 		.space	4
  80              		.global	glDmaDone
  81              		.section	.bss.glDmaDone,"aw",%nobits
  82              		.align	2
  85              	glDmaDone:
  86 0000 00000000 		.space	4
  87              		.global	glActiveSocket
  88              		.section	.bss.glActiveSocket,"aw",%nobits
  91              	glActiveSocket:
  92 0000 00       		.space	1
  93              		.global	doLpmDisable
  94              		.section	.data.doLpmDisable,"aw",%progbits
  95              		.align	2
  98              	doLpmDisable:
  99 0000 01000000 		.word	1
 100              		.global	glHitFV
 101              		.section	.bss.glHitFV,"aw",%nobits
 102              		.align	2
 105              	glHitFV:
 106 0000 00000000 		.space	4
 107              		.global	glMipiActive
 108              		.section	.bss.glMipiActive,"aw",%nobits
 109              		.align	2
 112              	glMipiActive:
 113 0000 00000000 		.space	4
 114              		.global	glIsClearFeature
 115              		.section	.bss.glIsClearFeature,"aw",%nobits
 116              		.align	2
 119              	glIsClearFeature:
 120 0000 00000000 		.space	4
 121              		.global	glPreviewStarted
 122              		.section	.bss.glPreviewStarted,"aw",%nobits
 123              		.align	2
 126              	glPreviewStarted:
 127 0000 00000000 		.space	4
 128              		.global	glUVCHeader
 129              		.section	.data.glUVCHeader,"aw",%progbits
 130              		.align	2
 133              	glUVCHeader:
 134 0000 0C       		.byte	12
 135 0001 8C       		.byte	-116
 136 0002 00       		.byte	0
 137 0003 00       		.byte	0
 138 0004 00       		.byte	0
 139 0005 00       		.byte	0
 140 0006 00       		.byte	0
 141 0007 00       		.byte	0
 142 0008 00       		.byte	0
 143 0009 00       		.byte	0
 144 000a 00       		.byte	0
 145 000b 00       		.byte	0
 146              		.comm	glCommitCtrl,32,4
 147              		.global	glCurrentFrameIndex
 148              		.section	.data.glCurrentFrameIndex,"aw",%progbits
 151              	glCurrentFrameIndex:
 152 0000 01       		.byte	1
 153              		.comm	glStillCommitCtrl,32,4
 154              		.global	glCurrentStillFrameIndex
 155              		.section	.data.glCurrentStillFrameIndex,"aw",%progbits
 158              	glCurrentStillFrameIndex:
 159 0000 01       		.byte	1
 160              		.global	glStillTriggerCtrl
 161              		.section	.bss.glStillTriggerCtrl,"aw",%nobits
 164              	glStillTriggerCtrl:
 165 0000 00       		.space	1
 166              		.global	glFrameIndexToSet
 167              		.section	.bss.glFrameIndexToSet,"aw",%nobits
 170              	glFrameIndexToSet:
 171 0000 00       		.space	1
 172              		.global	glStillCaptureStart
 173              		.section	.bss.glStillCaptureStart,"aw",%nobits
 174              		.align	2
 177              	glStillCaptureStart:
 178 0000 00000000 		.space	4
 179              		.global	glStillCaptured
 180              		.section	.bss.glStillCaptured,"aw",%nobits
 181              		.align	2
 184              	glStillCaptured:
 185 0000 00000000 		.space	4
 186              		.global	glStillSkip
 187              		.section	.bss.glStillSkip,"aw",%nobits
 190              	glStillSkip:
 191 0000 00       		.space	1
 192              		.global	glIsApplnActive
 193              		.section	.bss.glIsApplnActive,"aw",%nobits
 194              		.align	2
 197              	glIsApplnActive:
 198 0000 00000000 		.space	4
 199              		.global	glIsConfigured
 200              		.section	.bss.glIsConfigured,"aw",%nobits
 201              		.align	2
 204              	glIsConfigured:
 205 0000 00000000 		.space	4
 206              		.global	glIsStreamingStarted
 207              		.section	.bss.glIsStreamingStarted,"aw",%nobits
 208              		.align	2
 211              	glIsStreamingStarted:
 212 0000 00000000 		.space	4
 213              		.comm	glChHandleUVCStream,232,4
 214              		.global	ES_UVC_STREAM_BUF_SIZE
 215              		.section	.bss.ES_UVC_STREAM_BUF_SIZE,"aw",%nobits
 216              		.align	1
 219              	ES_UVC_STREAM_BUF_SIZE:
 220 0000 0000     		.space	2
 221              		.global	ES_UVC_DATA_BUF_SIZE
 222              		.section	.bss.ES_UVC_DATA_BUF_SIZE,"aw",%nobits
 223              		.align	1
 226              	ES_UVC_DATA_BUF_SIZE:
 227 0000 0000     		.space	2
 228              		.global	ES_UVC_STREAM_BUF_COUNT
 229              		.section	.bss.ES_UVC_STREAM_BUF_COUNT,"aw",%nobits
 232              	ES_UVC_STREAM_BUF_COUNT:
 233 0000 00       		.space	1
 234              		.global	g_IsAutoFocus
 235              		.section	.data.g_IsAutoFocus,"aw",%progbits
 238              	g_IsAutoFocus:
 239 0000 01       		.byte	1
 240              		.global	glGet_Info
 241              		.section	.bss.glGet_Info,"aw",%nobits
 244              	glGet_Info:
 245 0000 00       		.space	1
 246              		.global	gl8GetControl
 247              		.section	.bss.gl8GetControl,"aw",%nobits
 248              		.align	1
 251              	gl8GetControl:
 252 0000 0000     		.space	2
 253              		.global	gl8SetControl
 254              		.section	.bss.gl8SetControl,"aw",%nobits
 255              		.align	1
 258              	gl8SetControl:
 259 0000 0000     		.space	2
 260              		.global	gl16GetControl
 261              		.section	.bss.gl16GetControl,"aw",%nobits
 262              		.align	1
 265              	gl16GetControl:
 266 0000 0000     		.space	2
 267              		.global	gl32GetControl
 268              		.section	.bss.gl32GetControl,"aw",%nobits
 269              		.align	2
 272              	gl32GetControl:
 273 0000 00000000 		.space	4
 274              		.global	glcommitcount
 275              		.section	.bss.glcommitcount,"aw",%nobits
 278              	glcommitcount:
 279 0000 00       		.space	1
 280              		.global	glcheckframe
 281              		.section	.data.glcheckframe,"aw",%progbits
 284              	glcheckframe:
 285 0000 01       		.byte	1
 286              		.section	.text.esUVCAppErrorHandler,"ax",%progbits
 287              		.align	2
 288              		.global	esUVCAppErrorHandler
 290              	esUVCAppErrorHandler:
 291              	.LFB1:
  75:../CX3RDKOV5640.c **** #endif
  76:../CX3RDKOV5640.c **** 
  77:../CX3RDKOV5640.c **** volatile int32_t glDMATxCount = 0;          /* Counter used to count the Dma Transfers */
  78:../CX3RDKOV5640.c **** volatile int32_t glDmaDone = 0;
  79:../CX3RDKOV5640.c **** volatile uint8_t glActiveSocket = 0;
  80:../CX3RDKOV5640.c **** volatile CyBool_t doLpmDisable = CyTrue;	/* Flag used to Enable/Disable low USB 3.0 LPM */
  81:../CX3RDKOV5640.c **** CyBool_t glHitFV = CyFalse;             	/* Flag used for state of FV signal. */
  82:../CX3RDKOV5640.c **** CyBool_t glMipiActive = CyFalse;        	/* Flag set to true when Mipi interface is active. Used fo
  83:../CX3RDKOV5640.c **** CyBool_t glIsClearFeature = CyFalse;    	/* Flag to signal when AppStop is called from the ClearFea
  84:../CX3RDKOV5640.c **** CyBool_t glPreviewStarted = CyFalse;		/* Flag to support Mac os */
  85:../CX3RDKOV5640.c **** 
  86:../CX3RDKOV5640.c **** /* UVC Header */
  87:../CX3RDKOV5640.c **** uint8_t glUVCHeader[ES_UVC_HEADER_LENGTH] =
  88:../CX3RDKOV5640.c **** {
  89:../CX3RDKOV5640.c ****     0x0C,                           /* Header Length */
  90:../CX3RDKOV5640.c ****     0x8C,                           /* Bit field header field */
  91:../CX3RDKOV5640.c ****     0x00,0x00,0x00,0x00,            /* Presentation time stamp field */
  92:../CX3RDKOV5640.c ****     0x00,0x00,0x00,0x00,0x00,0x00   /* Source clock reference field */
  93:../CX3RDKOV5640.c **** };
  94:../CX3RDKOV5640.c **** 
  95:../CX3RDKOV5640.c **** /* Video Probe Commit Control */
  96:../CX3RDKOV5640.c **** uint8_t glCommitCtrl[ES_UVC_MAX_PROBE_SETTING_ALIGNED];
  97:../CX3RDKOV5640.c **** uint8_t glCurrentFrameIndex = 1;
  98:../CX3RDKOV5640.c **** uint8_t glStillCommitCtrl[ES_UVC_MAX_STILL_PROBE_SETTING_ALIGNED];
  99:../CX3RDKOV5640.c **** uint8_t glCurrentStillFrameIndex = 1;
 100:../CX3RDKOV5640.c **** uint8_t glStillTriggerCtrl = 0;
 101:../CX3RDKOV5640.c **** uint8_t glFrameIndexToSet = 0;
 102:../CX3RDKOV5640.c **** CyBool_t glStillCaptureStart = CyFalse;
 103:../CX3RDKOV5640.c **** CyBool_t glStillCaptured = CyFalse;
 104:../CX3RDKOV5640.c **** uint8_t glStillSkip = 0;
 105:../CX3RDKOV5640.c **** 
 106:../CX3RDKOV5640.c **** CyBool_t glIsApplnActive = CyFalse;             /* Whether the Mipi->USB application is active or n
 107:../CX3RDKOV5640.c **** CyBool_t glIsConfigured = CyFalse;              /* Whether Application is in configured state or no
 108:../CX3RDKOV5640.c **** CyBool_t glIsStreamingStarted = CyFalse;        /* Whether streaming has started - Used for MAC OS 
 109:../CX3RDKOV5640.c **** 
 110:../CX3RDKOV5640.c **** /* DMA Channel */
 111:../CX3RDKOV5640.c **** CyU3PDmaMultiChannel glChHandleUVCStream;       /* DMA Channel Handle for UVC Stream  */
 112:../CX3RDKOV5640.c **** uint16_t ES_UVC_STREAM_BUF_SIZE=0;
 113:../CX3RDKOV5640.c **** uint16_t ES_UVC_DATA_BUF_SIZE=0;
 114:../CX3RDKOV5640.c **** uint8_t ES_UVC_STREAM_BUF_COUNT=0;
 115:../CX3RDKOV5640.c **** 
 116:../CX3RDKOV5640.c **** uint8_t g_IsAutoFocus=1;						/* Check the AutoFocus is Enabled or not*/
 117:../CX3RDKOV5640.c **** 
 118:../CX3RDKOV5640.c **** /* USB control request processing variables*/
 119:../CX3RDKOV5640.c **** #if 1
 120:../CX3RDKOV5640.c **** 
 121:../CX3RDKOV5640.c **** uint8_t glGet_Info = 0;
 122:../CX3RDKOV5640.c **** int16_t gl8GetControl = 0;
 123:../CX3RDKOV5640.c **** int16_t gl8SetControl = 0;
 124:../CX3RDKOV5640.c **** int16_t gl16GetControl = 0;
 125:../CX3RDKOV5640.c **** 
 126:../CX3RDKOV5640.c **** int32_t gl32GetControl = 0;
 127:../CX3RDKOV5640.c **** 
 128:../CX3RDKOV5640.c **** #endif
 129:../CX3RDKOV5640.c **** 
 130:../CX3RDKOV5640.c **** uint8_t glcommitcount=0,glcheckframe=1;
 131:../CX3RDKOV5640.c **** 
 132:../CX3RDKOV5640.c **** /* Application critical error handler */
 133:../CX3RDKOV5640.c ****     void
 134:../CX3RDKOV5640.c **** esUVCAppErrorHandler (
 135:../CX3RDKOV5640.c ****         CyU3PReturnStatus_t status        /* API return status */
 136:../CX3RDKOV5640.c ****         )
 137:../CX3RDKOV5640.c **** {
 292              		.loc 1 137 0
 293              		.cfi_startproc
 294              		@ args = 0, pretend = 0, frame = 8
 295              		@ frame_needed = 1, uses_anonymous_args = 0
 296 0000 00482DE9 		stmfd	sp!, {fp, lr}
 297              	.LCFI2:
 298              		.cfi_def_cfa_offset 8
 299              		.cfi_offset 11, -8
 300              		.cfi_offset 14, -4
 301 0004 04B08DE2 		add	fp, sp, #4
 302              	.LCFI3:
 303              		.cfi_def_cfa 11, 4
 304 0008 08D04DE2 		sub	sp, sp, #8
 305 000c 08000BE5 		str	r0, [fp, #-8]
 306              	.L5:
 138:../CX3RDKOV5640.c ****     /* Application failed with the error code status */
 139:../CX3RDKOV5640.c **** 
 140:../CX3RDKOV5640.c ****     /* Add custom debug or recovery actions here */
 141:../CX3RDKOV5640.c **** 
 142:../CX3RDKOV5640.c ****     /* Loop indefinitely */
 143:../CX3RDKOV5640.c ****     for (;;)
 144:../CX3RDKOV5640.c ****     {
 145:../CX3RDKOV5640.c ****         /* Thread sleep : 100 ms */
 146:../CX3RDKOV5640.c ****         CyU3PThreadSleep (100);
 307              		.loc 1 146 0 discriminator 1
 308 0010 6400A0E3 		mov	r0, #100
 309 0014 FEFFFFEB 		bl	_tx_thread_sleep
 147:../CX3RDKOV5640.c ****     }
 310              		.loc 1 147 0 discriminator 1
 311 0018 FCFFFFEA 		b	.L5
 312              		.cfi_endproc
 313              	.LFE1:
 315              		.section	.text.esUVCUvcAddHeader,"ax",%progbits
 316              		.align	2
 318              	esUVCUvcAddHeader:
 319              	.LFB2:
 148:../CX3RDKOV5640.c **** }
 149:../CX3RDKOV5640.c **** 
 150:../CX3RDKOV5640.c **** 
 151:../CX3RDKOV5640.c **** /* UVC header addition function */
 152:../CX3RDKOV5640.c ****     static void
 153:../CX3RDKOV5640.c **** esUVCUvcAddHeader (
 154:../CX3RDKOV5640.c ****         uint8_t *buffer_p,      /* Buffer pointer */
 155:../CX3RDKOV5640.c ****         uint8_t frameInd        /* EOF or normal frame indication */
 156:../CX3RDKOV5640.c ****         )
 157:../CX3RDKOV5640.c **** {
 320              		.loc 1 157 0
 321              		.cfi_startproc
 322              		@ args = 0, pretend = 0, frame = 8
 323              		@ frame_needed = 1, uses_anonymous_args = 0
 324 0000 00482DE9 		stmfd	sp!, {fp, lr}
 325              	.LCFI4:
 326              		.cfi_def_cfa_offset 8
 327              		.cfi_offset 11, -8
 328              		.cfi_offset 14, -4
 329 0004 04B08DE2 		add	fp, sp, #4
 330              	.LCFI5:
 331              		.cfi_def_cfa 11, 4
 332 0008 08D04DE2 		sub	sp, sp, #8
 333 000c 08000BE5 		str	r0, [fp, #-8]
 334 0010 0130A0E1 		mov	r3, r1
 335 0014 09304BE5 		strb	r3, [fp, #-9]
 158:../CX3RDKOV5640.c ****     /* Copy header to buffer */
 159:../CX3RDKOV5640.c ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, ES_UVC_HEADER_LENGTH);
 336              		.loc 1 159 0
 337 0018 08001BE5 		ldr	r0, [fp, #-8]
 338 001c 50109FE5 		ldr	r1, .L8
 339 0020 0C20A0E3 		mov	r2, #12
 340 0024 FEFFFFEB 		bl	CyU3PMemCopy
 160:../CX3RDKOV5640.c **** 
 161:../CX3RDKOV5640.c ****     /* Check if last packet of the frame. */
 162:../CX3RDKOV5640.c ****     if (frameInd == ES_UVC_HEADER_EOF)
 341              		.loc 1 162 0
 342 0028 09305BE5 		ldrb	r3, [fp, #-9]	@ zero_extendqisi2
 343 002c 020053E3 		cmp	r3, #2
 344 0030 0D00001A 		bne	.L6
 163:../CX3RDKOV5640.c ****     {
 164:../CX3RDKOV5640.c ****         /* Modify UVC header to toggle Frame ID */
 165:../CX3RDKOV5640.c ****         glUVCHeader[1] ^= ES_UVC_HEADER_FRAME_ID;
 345              		.loc 1 165 0
 346 0034 38309FE5 		ldr	r3, .L8
 347 0038 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 348 003c 013023E2 		eor	r3, r3, #1
 349 0040 FF2003E2 		and	r2, r3, #255
 350 0044 28309FE5 		ldr	r3, .L8
 351 0048 0120C3E5 		strb	r2, [r3, #1]
 166:../CX3RDKOV5640.c **** 
 167:../CX3RDKOV5640.c ****         /* Indicate End of Frame in the buffer */
 168:../CX3RDKOV5640.c ****         buffer_p[1] |=  ES_UVC_HEADER_EOF;
 352              		.loc 1 168 0
 353 004c 08301BE5 		ldr	r3, [fp, #-8]
 354 0050 013083E2 		add	r3, r3, #1
 355 0054 08201BE5 		ldr	r2, [fp, #-8]
 356 0058 012082E2 		add	r2, r2, #1
 357 005c 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 358 0060 022082E3 		orr	r2, r2, #2
 359 0064 FF2002E2 		and	r2, r2, #255
 360 0068 0020C3E5 		strb	r2, [r3]
 361              	.L6:
 169:../CX3RDKOV5640.c ****     }
 170:../CX3RDKOV5640.c **** }
 362              		.loc 1 170 0
 363 006c 04D04BE2 		sub	sp, fp, #4
 364              		@ sp needed
 365 0070 0088BDE8 		ldmfd	sp!, {fp, pc}
 366              	.L9:
 367              		.align	2
 368              	.L8:
 369 0074 00000000 		.word	glUVCHeader
 370              		.cfi_endproc
 371              	.LFE2:
 373              		.section	.rodata
 374              		.align	2
 375              	.LC0:
 376 0000 0A0D4170 		.ascii	"\012\015AplnStrt:ChannelReset Err = 0x%x\000"
 376      6C6E5374 
 376      72743A43 
 376      68616E6E 
 376      656C5265 
 377 0023 00       		.align	2
 378              	.LC1:
 379 0024 0A0D4170 		.ascii	"\012\015AplnStrt:SetXfer Err = 0x%x\000"
 379      6C6E5374 
 379      72743A53 
 379      65745866 
 379      65722045 
 380              		.section	.text.esUVCUvcApplnStart,"ax",%progbits
 381              		.align	2
 382              		.global	esUVCUvcApplnStart
 384              	esUVCUvcApplnStart:
 385              	.LFB3:
 171:../CX3RDKOV5640.c **** 
 172:../CX3RDKOV5640.c **** 
 173:../CX3RDKOV5640.c **** /* This function starts the video streaming application. It is called
 174:../CX3RDKOV5640.c ****  * when there is a SET_INTERFACE event for alternate interface 1
 175:../CX3RDKOV5640.c ****  * (in case of UVC over Isochronous Endpoint usage) or when a
 176:../CX3RDKOV5640.c ****  * COMMIT_CONTROL(SET_CUR) request is received (when using BULK only UVC).
 177:../CX3RDKOV5640.c ****  */
 178:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t
 179:../CX3RDKOV5640.c **** esUVCUvcApplnStart (void)
 180:../CX3RDKOV5640.c **** {
 386              		.loc 1 180 0
 387              		.cfi_startproc
 388              		@ args = 0, pretend = 0, frame = 8
 389              		@ frame_needed = 1, uses_anonymous_args = 0
 390 0000 00482DE9 		stmfd	sp!, {fp, lr}
 391              	.LCFI6:
 392              		.cfi_def_cfa_offset 8
 393              		.cfi_offset 11, -8
 394              		.cfi_offset 14, -4
 395 0004 04B08DE2 		add	fp, sp, #4
 396              	.LCFI7:
 397              		.cfi_def_cfa 11, 4
 398 0008 10D04DE2 		sub	sp, sp, #16
 181:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 399              		.loc 1 181 0
 400 000c 0030A0E3 		mov	r3, #0
 401 0010 08300BE5 		str	r3, [fp, #-8]
 182:../CX3RDKOV5640.c **** 
 183:../CX3RDKOV5640.c ****     glIsApplnActive = CyTrue;
 402              		.loc 1 183 0
 403 0014 2C319FE5 		ldr	r3, .L14
 404 0018 0120A0E3 		mov	r2, #1
 405 001c 002083E5 		str	r2, [r3]
 184:../CX3RDKOV5640.c ****     glDmaDone = 0;
 406              		.loc 1 184 0
 407 0020 24319FE5 		ldr	r3, .L14+4
 408 0024 0020A0E3 		mov	r2, #0
 409 0028 002083E5 		str	r2, [r3]
 185:../CX3RDKOV5640.c ****     glDMATxCount = 0;
 410              		.loc 1 185 0
 411 002c 1C319FE5 		ldr	r3, .L14+8
 412 0030 0020A0E3 		mov	r2, #0
 413 0034 002083E5 		str	r2, [r3]
 186:../CX3RDKOV5640.c ****     glHitFV = CyFalse;
 414              		.loc 1 186 0
 415 0038 14319FE5 		ldr	r3, .L14+12
 416 003c 0020A0E3 		mov	r2, #0
 417 0040 002083E5 		str	r2, [r3]
 187:../CX3RDKOV5640.c ****     doLpmDisable = CyTrue;
 418              		.loc 1 187 0
 419 0044 0C319FE5 		ldr	r3, .L14+16
 420 0048 0120A0E3 		mov	r2, #1
 421 004c 002083E5 		str	r2, [r3]
 188:../CX3RDKOV5640.c **** 
 189:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
 190:../CX3RDKOV5640.c ****     CyU3PTimerStop (&UvcTimer);
 422              		.loc 1 190 0
 423 0050 04019FE5 		ldr	r0, .L14+20
 424 0054 FEFFFFEB 		bl	_txe_timer_deactivate
 191:../CX3RDKOV5640.c **** #endif
 192:../CX3RDKOV5640.c **** 
 193:../CX3RDKOV5640.c **** 
 194:../CX3RDKOV5640.c ****     /* Place the EP in NAK mode before cleaning up the pipe. */
 195:../CX3RDKOV5640.c ****     CyU3PUsbSetEpNak (ES_UVC_EP_BULK_VIDEO, CyTrue);
 425              		.loc 1 195 0
 426 0058 8300A0E3 		mov	r0, #131
 427 005c 0110A0E3 		mov	r1, #1
 428 0060 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 196:../CX3RDKOV5640.c ****     CyU3PBusyWait (100);
 429              		.loc 1 196 0
 430 0064 6400A0E3 		mov	r0, #100
 431 0068 FEFFFFEB 		bl	CyFx3BusyWait
 197:../CX3RDKOV5640.c **** 
 198:../CX3RDKOV5640.c ****     /* Reset USB EP and DMA */
 199:../CX3RDKOV5640.c ****     CyU3PUsbFlushEp(ES_UVC_EP_BULK_VIDEO);
 432              		.loc 1 199 0
 433 006c 8300A0E3 		mov	r0, #131
 434 0070 FEFFFFEB 		bl	CyU3PUsbFlushEp
 200:../CX3RDKOV5640.c ****     status = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 435              		.loc 1 200 0
 436 0074 E4009FE5 		ldr	r0, .L14+24
 437 0078 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 438 007c 08000BE5 		str	r0, [fp, #-8]
 201:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 439              		.loc 1 201 0
 440 0080 08301BE5 		ldr	r3, [fp, #-8]
 441 0084 000053E3 		cmp	r3, #0
 442 0088 0500000A 		beq	.L11
 202:../CX3RDKOV5640.c ****     {
 203:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4,"\n\rAplnStrt:ChannelReset Err = 0x%x", status);
 443              		.loc 1 203 0
 444 008c 0400A0E3 		mov	r0, #4
 445 0090 CC109FE5 		ldr	r1, .L14+28
 446 0094 08201BE5 		ldr	r2, [fp, #-8]
 447 0098 FEFFFFEB 		bl	CyU3PDebugPrint
 204:../CX3RDKOV5640.c ****         return status;
 448              		.loc 1 204 0
 449 009c 08301BE5 		ldr	r3, [fp, #-8]
 450 00a0 250000EA 		b	.L12
 451              	.L11:
 205:../CX3RDKOV5640.c ****     }
 206:../CX3RDKOV5640.c **** 
 207:../CX3RDKOV5640.c ****     status = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 452              		.loc 1 207 0
 453 00a4 B4009FE5 		ldr	r0, .L14+24
 454 00a8 0010A0E3 		mov	r1, #0
 455 00ac 0020A0E3 		mov	r2, #0
 456 00b0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 457 00b4 08000BE5 		str	r0, [fp, #-8]
 208:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 458              		.loc 1 208 0
 459 00b8 08301BE5 		ldr	r3, [fp, #-8]
 460 00bc 000053E3 		cmp	r3, #0
 461 00c0 0500000A 		beq	.L13
 209:../CX3RDKOV5640.c ****     {
 210:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAplnStrt:SetXfer Err = 0x%x", status);
 462              		.loc 1 210 0
 463 00c4 0400A0E3 		mov	r0, #4
 464 00c8 98109FE5 		ldr	r1, .L14+32
 465 00cc 08201BE5 		ldr	r2, [fp, #-8]
 466 00d0 FEFFFFEB 		bl	CyU3PDebugPrint
 211:../CX3RDKOV5640.c ****         return status;
 467              		.loc 1 211 0
 468 00d4 08301BE5 		ldr	r3, [fp, #-8]
 469 00d8 170000EA 		b	.L12
 470              	.L13:
 212:../CX3RDKOV5640.c ****     }
 213:../CX3RDKOV5640.c **** 
 214:../CX3RDKOV5640.c ****     CyU3PUsbSetEpNak (ES_UVC_EP_BULK_VIDEO, CyFalse);
 471              		.loc 1 214 0
 472 00dc 8300A0E3 		mov	r0, #131
 473 00e0 0010A0E3 		mov	r1, #0
 474 00e4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 215:../CX3RDKOV5640.c ****     CyU3PBusyWait (200);
 475              		.loc 1 215 0
 476 00e8 C800A0E3 		mov	r0, #200
 477 00ec FEFFFFEB 		bl	CyFx3BusyWait
 216:../CX3RDKOV5640.c **** //
 217:../CX3RDKOV5640.c **** //    /* Place the EP in NAK mode before cleaning up the pipe. */
 218:../CX3RDKOV5640.c **** //    CyU3PUsbSetEpNak (ES_UVC_EP_BULK_VIDEO, CyTrue);
 219:../CX3RDKOV5640.c **** //    CyU3PBusyWait (100);
 220:../CX3RDKOV5640.c **** //
 221:../CX3RDKOV5640.c **** //    /* Reset USB EP and DMA */
 222:../CX3RDKOV5640.c **** //    CyU3PUsbFlushEp(ES_UVC_EP_BULK_VIDEO);
 223:../CX3RDKOV5640.c **** //    status = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 224:../CX3RDKOV5640.c **** //    if (status != CY_U3P_SUCCESS)
 225:../CX3RDKOV5640.c **** //    {
 226:../CX3RDKOV5640.c **** //        CyU3PDebugPrint (4,"\n\rAplnStrt:ChannelReset Err = 0x%x", status);
 227:../CX3RDKOV5640.c **** //        return status;
 228:../CX3RDKOV5640.c **** //    }
 229:../CX3RDKOV5640.c **** //    status = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 230:../CX3RDKOV5640.c **** //    if (status != CY_U3P_SUCCESS)
 231:../CX3RDKOV5640.c **** //    {
 232:../CX3RDKOV5640.c **** //        CyU3PDebugPrint (4, "\n\rAplnStrt:SetXfer Err = 0x%x", status);
 233:../CX3RDKOV5640.c **** //        return status;
 234:../CX3RDKOV5640.c **** //    }
 235:../CX3RDKOV5640.c **** //    CyU3PUsbSetEpNak (ES_UVC_EP_BULK_VIDEO, CyFalse);
 236:../CX3RDKOV5640.c **** //    CyU3PBusyWait (200);
 237:../CX3RDKOV5640.c **** 
 238:../CX3RDKOV5640.c **** 	 /* Night Mode function
 239:../CX3RDKOV5640.c **** 	 *  --------------------
 240:../CX3RDKOV5640.c **** 	 *  esOV5640_Nightmode API is used to enable the Nightmode
 241:../CX3RDKOV5640.c **** 	 *  of OV5640 sensor.
 242:../CX3RDKOV5640.c **** 	 *  Set Enable -- Cytrue to enable Nightmode
 243:../CX3RDKOV5640.c **** 	 * 				  CyFalse to Disable Nightmode
 244:../CX3RDKOV5640.c **** 	 *
 245:../CX3RDKOV5640.c **** 	 *  Set NightMode_option -- 1 to 6 to set different night modes
 246:../CX3RDKOV5640.c **** 	 *
 247:../CX3RDKOV5640.c **** 	 * To test different night modes, uncomment the below statement and build the firmware
 248:../CX3RDKOV5640.c **** 	 */
 249:../CX3RDKOV5640.c ****     //TODO Change this Function to "Sensor Specific" Nightmode Function to enable the nightmode(If 
 250:../CX3RDKOV5640.c **** 	/*esOV5640_Nightmode(CyTrue,3);*/
 251:../CX3RDKOV5640.c **** 
 252:../CX3RDKOV5640.c **** 
 253:../CX3RDKOV5640.c ****     /* Resume the Fixed Function GPIF State machine */
 254:../CX3RDKOV5640.c ****     CyU3PGpifSMControl(CyFalse);
 478              		.loc 1 254 0
 479 00f0 0000A0E3 		mov	r0, #0
 480 00f4 FEFFFFEB 		bl	CyU3PGpifSMControl
 255:../CX3RDKOV5640.c **** 
 256:../CX3RDKOV5640.c ****     glActiveSocket = 0;
 481              		.loc 1 256 0
 482 00f8 6C309FE5 		ldr	r3, .L14+36
 483 00fc 0020A0E3 		mov	r2, #0
 484 0100 0020C3E5 		strb	r2, [r3]
 257:../CX3RDKOV5640.c ****     CyU3PGpifSMSwitch(ES_UVC_INVALID_GPIF_STATE, CX3_START_SCK0,
 485              		.loc 1 257 0
 486 0104 0230A0E3 		mov	r3, #2
 487 0108 00308DE5 		str	r3, [sp]
 488 010c 5C009FE5 		ldr	r0, .L14+40
 489 0110 0010A0E3 		mov	r1, #0
 490 0114 54209FE5 		ldr	r2, .L14+40
 491 0118 0030A0E3 		mov	r3, #0
 492 011c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 258:../CX3RDKOV5640.c ****     		ES_UVC_INVALID_GPIF_STATE, ALPHA_CX3_START_SCK0, ES_UVC_GPIF_SWITCH_TIMEOUT);
 259:../CX3RDKOV5640.c **** 
 260:../CX3RDKOV5640.c ****     CyU3PThreadSleep(10);
 493              		.loc 1 260 0
 494 0120 0A00A0E3 		mov	r0, #10
 495 0124 FEFFFFEB 		bl	_tx_thread_sleep
 261:../CX3RDKOV5640.c **** 
 262:../CX3RDKOV5640.c ****     /* Wake Mipi interface and Image Sensor */
 263:../CX3RDKOV5640.c ****     CyU3PMipicsiWakeup();
 496              		.loc 1 263 0
 497 0128 FEFFFFEB 		bl	CyU3PMipicsiWakeup
 264:../CX3RDKOV5640.c **** 
 265:../CX3RDKOV5640.c ****     //TODO Change this function with "Sensor Specific" PowerUp function to PowerUp the sensor
 266:../CX3RDKOV5640.c ****     //esCamera_Power_Up();  // remove the camera operations function for VIS mipi camera test -wche
 267:../CX3RDKOV5640.c **** 
 268:../CX3RDKOV5640.c ****     glMipiActive = CyTrue;
 498              		.loc 1 268 0
 499 012c 40309FE5 		ldr	r3, .L14+44
 500 0130 0120A0E3 		mov	r2, #1
 501 0134 002083E5 		str	r2, [r3]
 269:../CX3RDKOV5640.c **** 
 270:../CX3RDKOV5640.c ****     //TODO Change this Function with "Sensor Specific" AutoFocus Function to Set the AutoFocus of t
 271:../CX3RDKOV5640.c **** 	if(glStillCaptureStart!= CyTrue)
 272:../CX3RDKOV5640.c **** 	{
 273:../CX3RDKOV5640.c **** 		if(0&&g_IsAutoFocus)// disable the auto focus for VIS camera. -wcheng
 274:../CX3RDKOV5640.c **** 			;//esOV5640_SetAutofocus(g_IsAutoFocus);
 275:../CX3RDKOV5640.c **** 	}
 276:../CX3RDKOV5640.c ****     return CY_U3P_SUCCESS;
 502              		.loc 1 276 0
 503 0138 0030A0E3 		mov	r3, #0
 504              	.L12:
 277:../CX3RDKOV5640.c **** }
 505              		.loc 1 277 0
 506 013c 0300A0E1 		mov	r0, r3
 507 0140 04D04BE2 		sub	sp, fp, #4
 508              		@ sp needed
 509 0144 0088BDE8 		ldmfd	sp!, {fp, pc}
 510              	.L15:
 511              		.align	2
 512              	.L14:
 513 0148 00000000 		.word	glIsApplnActive
 514 014c 00000000 		.word	glDmaDone
 515 0150 00000000 		.word	glDMATxCount
 516 0154 00000000 		.word	glHitFV
 517 0158 00000000 		.word	doLpmDisable
 518 015c 00000000 		.word	UvcTimer
 519 0160 00000000 		.word	glChHandleUVCStream
 520 0164 00000000 		.word	.LC0
 521 0168 24000000 		.word	.LC1
 522 016c 00000000 		.word	glActiveSocket
 523 0170 01010000 		.word	257
 524 0174 00000000 		.word	glMipiActive
 525              		.cfi_endproc
 526              	.LFE3:
 528              		.section	.rodata
 529 0042 0000     		.align	2
 530              	.LC2:
 531 0044 0A0D4170 		.ascii	"\012\015AplnStop:ChannelReset Err = 0x%x\000"
 531      6C6E5374 
 531      6F703A43 
 531      68616E6E 
 531      656C5265 
 532              		.section	.text.esUVCUvcApplnStop,"ax",%progbits
 533              		.align	2
 534              		.global	esUVCUvcApplnStop
 536              	esUVCUvcApplnStop:
 537              	.LFB4:
 278:../CX3RDKOV5640.c **** 
 279:../CX3RDKOV5640.c **** /* This function stops the video streaming. It is called from the USB event
 280:../CX3RDKOV5640.c ****  * handler, when there is a reset / disconnect or SET_INTERFACE for alternate
 281:../CX3RDKOV5640.c ****  * interface 0 in case of ischronous implementation or when a Clear Feature (Halt)
 282:../CX3RDKOV5640.c ****  * request is received (in case of bulk only implementation).
 283:../CX3RDKOV5640.c ****  */
 284:../CX3RDKOV5640.c ****     void
 285:../CX3RDKOV5640.c **** esUVCUvcApplnStop(void)
 286:../CX3RDKOV5640.c **** {
 538              		.loc 1 286 0
 539              		.cfi_startproc
 540              		@ args = 0, pretend = 0, frame = 8
 541              		@ frame_needed = 1, uses_anonymous_args = 0
 542 0000 00482DE9 		stmfd	sp!, {fp, lr}
 543              	.LCFI8:
 544              		.cfi_def_cfa_offset 8
 545              		.cfi_offset 11, -8
 546              		.cfi_offset 14, -4
 547 0004 04B08DE2 		add	fp, sp, #4
 548              	.LCFI9:
 549              		.cfi_def_cfa 11, 4
 550 0008 08D04DE2 		sub	sp, sp, #8
 287:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 551              		.loc 1 287 0
 552 000c 0030A0E3 		mov	r3, #0
 553 0010 08300BE5 		str	r3, [fp, #-8]
 288:../CX3RDKOV5640.c **** 
 289:../CX3RDKOV5640.c ****     /* Update the flag so that the application thread is notified of this. */
 290:../CX3RDKOV5640.c ****     glIsApplnActive = CyFalse;
 554              		.loc 1 290 0
 555 0014 D8309FE5 		ldr	r3, .L19
 556 0018 0020A0E3 		mov	r2, #0
 557 001c 002083E5 		str	r2, [r3]
 291:../CX3RDKOV5640.c **** 
 292:../CX3RDKOV5640.c ****     /* Stop the image sensor and CX3 mipi interface */
 293:../CX3RDKOV5640.c ****     status = CyU3PMipicsiSleep();
 558              		.loc 1 293 0
 559 0020 FEFFFFEB 		bl	CyU3PMipicsiSleep
 560 0024 08000BE5 		str	r0, [fp, #-8]
 294:../CX3RDKOV5640.c **** 
 295:../CX3RDKOV5640.c ****     //TODO Change this function with "Sensor Specific" PowerDown function to PowerDown the sensor
 296:../CX3RDKOV5640.c ****     //esCamera_Power_Down();  // remove the camera operations function for VIS mipi camera test -wc
 297:../CX3RDKOV5640.c **** 
 298:../CX3RDKOV5640.c ****     glMipiActive = CyFalse;
 561              		.loc 1 298 0
 562 0028 C8309FE5 		ldr	r3, .L19+4
 563 002c 0020A0E3 		mov	r2, #0
 564 0030 002083E5 		str	r2, [r3]
 299:../CX3RDKOV5640.c **** 
 300:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
 301:../CX3RDKOV5640.c ****     CyU3PTimerStop (&UvcTimer);
 565              		.loc 1 301 0
 566 0034 C0009FE5 		ldr	r0, .L19+8
 567 0038 FEFFFFEB 		bl	_txe_timer_deactivate
 302:../CX3RDKOV5640.c **** #endif
 303:../CX3RDKOV5640.c **** 
 304:../CX3RDKOV5640.c ****     /* Pause the GPIF interface*/
 305:../CX3RDKOV5640.c ****     CyU3PGpifSMControl(CyTrue);
 568              		.loc 1 305 0
 569 003c 0100A0E3 		mov	r0, #1
 570 0040 FEFFFFEB 		bl	CyU3PGpifSMControl
 306:../CX3RDKOV5640.c **** 
 307:../CX3RDKOV5640.c ****     CyU3PUsbSetEpNak (ES_UVC_EP_BULK_VIDEO, CyTrue);
 571              		.loc 1 307 0
 572 0044 8300A0E3 		mov	r0, #131
 573 0048 0110A0E3 		mov	r1, #1
 574 004c FEFFFFEB 		bl	CyU3PUsbSetEpNak
 308:../CX3RDKOV5640.c ****     CyU3PBusyWait (100);
 575              		.loc 1 308 0
 576 0050 6400A0E3 		mov	r0, #100
 577 0054 FEFFFFEB 		bl	CyFx3BusyWait
 309:../CX3RDKOV5640.c **** 
 310:../CX3RDKOV5640.c ****     /* Abort and destroy the video streaming channel */
 311:../CX3RDKOV5640.c ****     /* Reset the channel: Set to DSCR chain starting point in PORD/CONS SCKT; set DSCR_SIZE field i
 312:../CX3RDKOV5640.c ****     status = CyU3PDmaMultiChannelReset(&glChHandleUVCStream);
 578              		.loc 1 312 0
 579 0058 A0009FE5 		ldr	r0, .L19+12
 580 005c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 581 0060 08000BE5 		str	r0, [fp, #-8]
 313:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 582              		.loc 1 313 0
 583 0064 08301BE5 		ldr	r3, [fp, #-8]
 584 0068 000053E3 		cmp	r3, #0
 585 006c 0300000A 		beq	.L17
 314:../CX3RDKOV5640.c ****     {
 315:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4,"\n\rAplnStop:ChannelReset Err = 0x%x",status);
 586              		.loc 1 315 0
 587 0070 0400A0E3 		mov	r0, #4
 588 0074 88109FE5 		ldr	r1, .L19+16
 589 0078 08201BE5 		ldr	r2, [fp, #-8]
 590 007c FEFFFFEB 		bl	CyU3PDebugPrint
 591              	.L17:
 316:../CX3RDKOV5640.c ****     }
 317:../CX3RDKOV5640.c ****     CyU3PThreadSleep(25);
 592              		.loc 1 317 0
 593 0080 1900A0E3 		mov	r0, #25
 594 0084 FEFFFFEB 		bl	_tx_thread_sleep
 318:../CX3RDKOV5640.c **** 
 319:../CX3RDKOV5640.c ****     /* Flush the endpoint memory */
 320:../CX3RDKOV5640.c ****     CyU3PUsbFlushEp(ES_UVC_EP_BULK_VIDEO);
 595              		.loc 1 320 0
 596 0088 8300A0E3 		mov	r0, #131
 597 008c FEFFFFEB 		bl	CyU3PUsbFlushEp
 321:../CX3RDKOV5640.c ****     /* Clear the stall condition and sequence numbers if ClearFeature. */
 322:../CX3RDKOV5640.c ****     if (glIsClearFeature)
 598              		.loc 1 322 0
 599 0090 70309FE5 		ldr	r3, .L19+20
 600 0094 003093E5 		ldr	r3, [r3]
 601 0098 000053E3 		cmp	r3, #0
 602 009c 0600000A 		beq	.L18
 323:../CX3RDKOV5640.c ****     {
 324:../CX3RDKOV5640.c ****         CyU3PUsbStall (ES_UVC_EP_BULK_VIDEO, CyFalse, CyTrue);
 603              		.loc 1 324 0
 604 00a0 8300A0E3 		mov	r0, #131
 605 00a4 0010A0E3 		mov	r1, #0
 606 00a8 0120A0E3 		mov	r2, #1
 607 00ac FEFFFFEB 		bl	CyU3PUsbStall
 325:../CX3RDKOV5640.c ****         glIsClearFeature = CyFalse;
 608              		.loc 1 325 0
 609 00b0 50309FE5 		ldr	r3, .L19+20
 610 00b4 0020A0E3 		mov	r2, #0
 611 00b8 002083E5 		str	r2, [r3]
 612              	.L18:
 326:../CX3RDKOV5640.c ****     }
 327:../CX3RDKOV5640.c ****     CyU3PUsbSetEpNak (ES_UVC_EP_BULK_VIDEO, CyFalse);
 613              		.loc 1 327 0
 614 00bc 8300A0E3 		mov	r0, #131
 615 00c0 0010A0E3 		mov	r1, #0
 616 00c4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 328:../CX3RDKOV5640.c **** 	CyU3PBusyWait (200);
 617              		.loc 1 328 0
 618 00c8 C800A0E3 		mov	r0, #200
 619 00cc FEFFFFEB 		bl	CyFx3BusyWait
 329:../CX3RDKOV5640.c **** 
 330:../CX3RDKOV5640.c ****     glDMATxCount = 0;
 620              		.loc 1 330 0
 621 00d0 34309FE5 		ldr	r3, .L19+24
 622 00d4 0020A0E3 		mov	r2, #0
 623 00d8 002083E5 		str	r2, [r3]
 331:../CX3RDKOV5640.c ****     glDmaDone = 0;
 624              		.loc 1 331 0
 625 00dc 2C309FE5 		ldr	r3, .L19+28
 626 00e0 0020A0E3 		mov	r2, #0
 627 00e4 002083E5 		str	r2, [r3]
 332:../CX3RDKOV5640.c **** 
 333:../CX3RDKOV5640.c ****     /* Enable USB 3.0 LPM */
 334:../CX3RDKOV5640.c ****     CyU3PUsbLPMEnable ();
 628              		.loc 1 334 0
 629 00e8 FEFFFFEB 		bl	CyU3PUsbLPMEnable
 335:../CX3RDKOV5640.c **** }
 630              		.loc 1 335 0
 631 00ec 04D04BE2 		sub	sp, fp, #4
 632              		@ sp needed
 633 00f0 0088BDE8 		ldmfd	sp!, {fp, pc}
 634              	.L20:
 635              		.align	2
 636              	.L19:
 637 00f4 00000000 		.word	glIsApplnActive
 638 00f8 00000000 		.word	glMipiActive
 639 00fc 00000000 		.word	UvcTimer
 640 0100 00000000 		.word	glChHandleUVCStream
 641 0104 44000000 		.word	.LC2
 642 0108 00000000 		.word	glIsClearFeature
 643 010c 00000000 		.word	glDMATxCount
 644 0110 00000000 		.word	glDmaDone
 645              		.cfi_endproc
 646              	.LFE4:
 648              		.section	.rodata
 649 0067 00       		.align	2
 650              	.LC3:
 651 0068 0A0D4770 		.ascii	"\012\015GpifCB:WrapUp SCK0 Err = 0x%x\000"
 651      69664342 
 651      3A577261 
 651      70557020 
 651      53434B30 
 652              		.align	2
 653              	.LC4:
 654 0088 0A0D4770 		.ascii	"\012\015GpifCB:WrapUp SCK1 Err = 0x%x\000"
 654      69664342 
 654      3A577261 
 654      70557020 
 654      53434B31 
 655              		.section	.text.esUVCGpifCB,"ax",%progbits
 656              		.align	2
 657              		.global	esUVCGpifCB
 659              	esUVCGpifCB:
 660              	.LFB5:
 336:../CX3RDKOV5640.c **** 
 337:../CX3RDKOV5640.c **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
 338:../CX3RDKOV5640.c ****     void
 339:../CX3RDKOV5640.c **** esUVCGpifCB (
 340:../CX3RDKOV5640.c ****         CyU3PGpifEventType event,
 341:../CX3RDKOV5640.c ****         uint8_t currentState
 342:../CX3RDKOV5640.c ****         )
 343:../CX3RDKOV5640.c **** {
 661              		.loc 1 343 0
 662              		.cfi_startproc
 663              		@ args = 0, pretend = 0, frame = 16
 664              		@ frame_needed = 1, uses_anonymous_args = 0
 665 0000 00482DE9 		stmfd	sp!, {fp, lr}
 666              	.LCFI10:
 667              		.cfi_def_cfa_offset 8
 668              		.cfi_offset 11, -8
 669              		.cfi_offset 14, -4
 670 0004 04B08DE2 		add	fp, sp, #4
 671              	.LCFI11:
 672              		.cfi_def_cfa 11, 4
 673 0008 10D04DE2 		sub	sp, sp, #16
 674 000c 0020A0E1 		mov	r2, r0
 675 0010 0130A0E1 		mov	r3, r1
 676 0014 0D204BE5 		strb	r2, [fp, #-13]
 677 0018 0E304BE5 		strb	r3, [fp, #-14]
 344:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 678              		.loc 1 344 0
 679 001c 0030A0E3 		mov	r3, #0
 680 0020 08300BE5 		str	r3, [fp, #-8]
 345:../CX3RDKOV5640.c ****     /* Handle interrupt from the State Machine */
 346:../CX3RDKOV5640.c ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 681              		.loc 1 346 0
 682 0024 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 683 0028 010053E3 		cmp	r3, #1
 684 002c 1C00001A 		bne	.L21
 347:../CX3RDKOV5640.c ****     {
 348:../CX3RDKOV5640.c ****         /* Wrapup Socket 0*/
 349:../CX3RDKOV5640.c ****         if(currentState == CX3_PARTIAL_BUFFER_IN_SCK0)
 685              		.loc 1 349 0
 686 0030 0E305BE5 		ldrb	r3, [fp, #-14]	@ zero_extendqisi2
 687 0034 090053E3 		cmp	r3, #9
 688 0038 0B00001A 		bne	.L23
 350:../CX3RDKOV5640.c ****         {
 351:../CX3RDKOV5640.c ****             status = CyU3PDmaMultiChannelSetWrapUp(&glChHandleUVCStream,0);
 689              		.loc 1 351 0
 690 003c 68009FE5 		ldr	r0, .L25
 691 0040 0010A0E3 		mov	r1, #0
 692 0044 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 693 0048 08000BE5 		str	r0, [fp, #-8]
 352:../CX3RDKOV5640.c ****             if (status != CY_U3P_SUCCESS)
 694              		.loc 1 352 0
 695 004c 08301BE5 		ldr	r3, [fp, #-8]
 696 0050 000053E3 		cmp	r3, #0
 697 0054 1200000A 		beq	.L21
 353:../CX3RDKOV5640.c ****             {
 354:../CX3RDKOV5640.c ****                 CyU3PDebugPrint (4, "\n\rGpifCB:WrapUp SCK0 Err = 0x%x",status);
 698              		.loc 1 354 0
 699 0058 0400A0E3 		mov	r0, #4
 700 005c 4C109FE5 		ldr	r1, .L25+4
 701 0060 08201BE5 		ldr	r2, [fp, #-8]
 702 0064 FEFFFFEB 		bl	CyU3PDebugPrint
 703 0068 0D0000EA 		b	.L21
 704              	.L23:
 355:../CX3RDKOV5640.c ****             }
 356:../CX3RDKOV5640.c ****         }
 357:../CX3RDKOV5640.c ****         /* Wrapup Socket 1 */
 358:../CX3RDKOV5640.c ****         else if(currentState == CX3_PARTIAL_BUFFER_IN_SCK1)
 705              		.loc 1 358 0
 706 006c 0E305BE5 		ldrb	r3, [fp, #-14]	@ zero_extendqisi2
 707 0070 0A0053E3 		cmp	r3, #10
 708 0074 0A00001A 		bne	.L21
 359:../CX3RDKOV5640.c ****         {
 360:../CX3RDKOV5640.c ****             status = CyU3PDmaMultiChannelSetWrapUp(&glChHandleUVCStream,1);
 709              		.loc 1 360 0
 710 0078 2C009FE5 		ldr	r0, .L25
 711 007c 0110A0E3 		mov	r1, #1
 712 0080 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 713 0084 08000BE5 		str	r0, [fp, #-8]
 361:../CX3RDKOV5640.c ****             if (status != CY_U3P_SUCCESS)
 714              		.loc 1 361 0
 715 0088 08301BE5 		ldr	r3, [fp, #-8]
 716 008c 000053E3 		cmp	r3, #0
 717 0090 0300000A 		beq	.L21
 362:../CX3RDKOV5640.c ****             {
 363:../CX3RDKOV5640.c ****                 CyU3PDebugPrint (4, "\n\rGpifCB:WrapUp SCK1 Err = 0x%x",status);
 718              		.loc 1 363 0
 719 0094 0400A0E3 		mov	r0, #4
 720 0098 14109FE5 		ldr	r1, .L25+8
 721 009c 08201BE5 		ldr	r2, [fp, #-8]
 722 00a0 FEFFFFEB 		bl	CyU3PDebugPrint
 723              	.L21:
 364:../CX3RDKOV5640.c ****             }
 365:../CX3RDKOV5640.c ****         }
 366:../CX3RDKOV5640.c ****     }
 367:../CX3RDKOV5640.c **** #ifdef VISDebug
 368:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rJump into GPIFCB: event %d currentState %d", event, currentState);
 369:../CX3RDKOV5640.c **** #endif
 370:../CX3RDKOV5640.c **** }
 724              		.loc 1 370 0
 725 00a4 04D04BE2 		sub	sp, fp, #4
 726              		@ sp needed
 727 00a8 0088BDE8 		ldmfd	sp!, {fp, pc}
 728              	.L26:
 729              		.align	2
 730              	.L25:
 731 00ac 00000000 		.word	glChHandleUVCStream
 732 00b0 68000000 		.word	.LC3
 733 00b4 88000000 		.word	.LC4
 734              		.cfi_endproc
 735              	.LFE5:
 737              		.section	.text.esUVCUvcAppDmaCallback,"ax",%progbits
 738              		.align	2
 739              		.global	esUVCUvcAppDmaCallback
 741              	esUVCUvcAppDmaCallback:
 742              	.LFB6:
 371:../CX3RDKOV5640.c **** 
 372:../CX3RDKOV5640.c **** 
 373:../CX3RDKOV5640.c **** /* DMA callback function to handle the produce and consume events. */
 374:../CX3RDKOV5640.c ****     void
 375:../CX3RDKOV5640.c **** esUVCUvcAppDmaCallback (
 376:../CX3RDKOV5640.c ****         CyU3PDmaMultiChannel   *chHandle,
 377:../CX3RDKOV5640.c ****         CyU3PDmaCbType_t  type,
 378:../CX3RDKOV5640.c ****         CyU3PDmaCBInput_t *input
 379:../CX3RDKOV5640.c ****         )
 380:../CX3RDKOV5640.c **** {
 743              		.loc 1 380 0
 744              		.cfi_startproc
 745              		@ args = 0, pretend = 0, frame = 32
 746              		@ frame_needed = 1, uses_anonymous_args = 0
 747 0000 00482DE9 		stmfd	sp!, {fp, lr}
 748              	.LCFI12:
 749              		.cfi_def_cfa_offset 8
 750              		.cfi_offset 11, -8
 751              		.cfi_offset 14, -4
 752 0004 04B08DE2 		add	fp, sp, #4
 753              	.LCFI13:
 754              		.cfi_def_cfa 11, 4
 755 0008 28D04DE2 		sub	sp, sp, #40
 756 000c 18000BE5 		str	r0, [fp, #-24]
 757 0010 0130A0E1 		mov	r3, r1
 758 0014 20200BE5 		str	r2, [fp, #-32]
 759 0018 BA314BE1 		strh	r3, [fp, #-26]	@ movhi
 381:../CX3RDKOV5640.c ****     CyU3PDmaBuffer_t DmaBuffer;
 382:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 760              		.loc 1 382 0
 761 001c 0030A0E3 		mov	r3, #0
 762 0020 08300BE5 		str	r3, [fp, #-8]
 383:../CX3RDKOV5640.c **** 
 384:../CX3RDKOV5640.c ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 763              		.loc 1 384 0
 764 0024 BA315BE1 		ldrh	r3, [fp, #-26]
 765 0028 080053E3 		cmp	r3, #8
 766 002c 5800001A 		bne	.L28
 385:../CX3RDKOV5640.c ****     {
 386:../CX3RDKOV5640.c ****         /* This is a produce event notification to the CPU. This notification is
 387:../CX3RDKOV5640.c ****          * received upon reception of every buffer. The buffer will not be sent
 388:../CX3RDKOV5640.c ****          * out unless it is explicitly committed. The call shall fail if there
 389:../CX3RDKOV5640.c ****          * is a bus reset / usb disconnect or if there is any application error. */
 390:../CX3RDKOV5640.c **** 
 391:../CX3RDKOV5640.c ****         /* Disable USB 3.0 LPM while Buffer is being transmitted out*/
 392:../CX3RDKOV5640.c ****         if ((CyU3PUsbGetSpeed () == CY_U3P_SUPER_SPEED) && (doLpmDisable))
 767              		.loc 1 392 0
 768 0030 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 769 0034 0030A0E1 		mov	r3, r0
 770 0038 030053E3 		cmp	r3, #3
 771 003c 0B00001A 		bne	.L29
 772              		.loc 1 392 0 is_stmt 0 discriminator 1
 773 0040 38339FE5 		ldr	r3, .L42
 774 0044 003093E5 		ldr	r3, [r3]
 775 0048 000053E3 		cmp	r3, #0
 776 004c 0700000A 		beq	.L29
 393:../CX3RDKOV5640.c ****         {
 394:../CX3RDKOV5640.c ****             CyU3PUsbLPMDisable ();
 777              		.loc 1 394 0 is_stmt 1
 778 0050 FEFFFFEB 		bl	CyU3PUsbLPMDisable
 395:../CX3RDKOV5640.c ****             CyU3PUsbSetLinkPowerState (CyU3PUsbLPM_U0);
 779              		.loc 1 395 0
 780 0054 0000A0E3 		mov	r0, #0
 781 0058 FEFFFFEB 		bl	CyU3PUsbSetLinkPowerState
 396:../CX3RDKOV5640.c ****             CyU3PBusyWait (200);
 782              		.loc 1 396 0
 783 005c C800A0E3 		mov	r0, #200
 784 0060 FEFFFFEB 		bl	CyFx3BusyWait
 397:../CX3RDKOV5640.c **** 
 398:../CX3RDKOV5640.c ****             doLpmDisable = CyFalse;
 785              		.loc 1 398 0
 786 0064 14339FE5 		ldr	r3, .L42
 787 0068 0020A0E3 		mov	r2, #0
 788 006c 002083E5 		str	r2, [r3]
 789              	.L29:
 399:../CX3RDKOV5640.c ****         }
 400:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
 401:../CX3RDKOV5640.c ****             CyU3PTimerStart (&UvcTimer);
 790              		.loc 1 401 0
 791 0070 0C039FE5 		ldr	r0, .L42+4
 792 0074 FEFFFFEB 		bl	_txe_timer_activate
 402:../CX3RDKOV5640.c **** #endif
 403:../CX3RDKOV5640.c **** 
 404:../CX3RDKOV5640.c ****         status = CyU3PDmaMultiChannelGetBuffer(chHandle, &DmaBuffer, CYU3P_NO_WAIT);
 793              		.loc 1 404 0
 794 0078 14304BE2 		sub	r3, fp, #20
 795 007c 18001BE5 		ldr	r0, [fp, #-24]
 796 0080 0310A0E1 		mov	r1, r3
 797 0084 0020A0E3 		mov	r2, #0
 798 0088 FEFFFFEB 		bl	CyU3PDmaMultiChannelGetBuffer
 799 008c 08000BE5 		str	r0, [fp, #-8]
 405:../CX3RDKOV5640.c **** #ifdef VISDebug
 406:../CX3RDKOV5640.c **** //    CyU3PDebugPrint (4, "\n\rAppDmaCallback:CY_U3P_DMA_CB_PROD_EVENT CyU3PDmaMultiChannelGetBuffe
 407:../CX3RDKOV5640.c **** #endif
 408:../CX3RDKOV5640.c ****         while (status == CY_U3P_SUCCESS)
 800              		.loc 1 408 0
 801 0090 3B0000EA 		b	.L30
 802              	.L35:
 409:../CX3RDKOV5640.c ****         {
 410:../CX3RDKOV5640.c ****             /* Add Headers*/
 411:../CX3RDKOV5640.c ****             if(DmaBuffer.count < ES_UVC_DATA_BUF_SIZE)
 803              		.loc 1 411 0
 804 0094 B0215BE1 		ldrh	r2, [fp, #-16]
 805 0098 E8329FE5 		ldr	r3, .L42+8
 806 009c B030D3E1 		ldrh	r3, [r3]
 807 00a0 030052E1 		cmp	r2, r3
 808 00a4 0800002A 		bcs	.L31
 412:../CX3RDKOV5640.c ****             {
 413:../CX3RDKOV5640.c ****                 esUVCUvcAddHeader ((DmaBuffer.buffer - ES_UVC_PROD_HEADER), ES_UVC_HEADER_EOF);
 809              		.loc 1 413 0
 810 00a8 14301BE5 		ldr	r3, [fp, #-20]
 811 00ac 0C3043E2 		sub	r3, r3, #12
 812 00b0 0300A0E1 		mov	r0, r3
 813 00b4 0210A0E3 		mov	r1, #2
 814 00b8 FEFFFFEB 		bl	esUVCUvcAddHeader
 414:../CX3RDKOV5640.c ****                 glHitFV = CyTrue;
 815              		.loc 1 414 0
 816 00bc C8329FE5 		ldr	r3, .L42+12
 817 00c0 0120A0E3 		mov	r2, #1
 818 00c4 002083E5 		str	r2, [r3]
 819 00c8 040000EA 		b	.L32
 820              	.L31:
 415:../CX3RDKOV5640.c **** #ifdef VISDebug
 416:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppDmaCallback:CY_U3P_DMA_CB_PROD_EVENT count %x glDMATxCount++ %x", D
 417:../CX3RDKOV5640.c **** #endif
 418:../CX3RDKOV5640.c **** 
 419:../CX3RDKOV5640.c ****             }
 420:../CX3RDKOV5640.c ****             else
 421:../CX3RDKOV5640.c ****             {
 422:../CX3RDKOV5640.c ****                 esUVCUvcAddHeader ((DmaBuffer.buffer - ES_UVC_PROD_HEADER), ES_UVC_HEADER_FRAME);
 821              		.loc 1 422 0
 822 00cc 14301BE5 		ldr	r3, [fp, #-20]
 823 00d0 0C3043E2 		sub	r3, r3, #12
 824 00d4 0300A0E1 		mov	r0, r3
 825 00d8 0010A0E3 		mov	r1, #0
 826 00dc FEFFFFEB 		bl	esUVCUvcAddHeader
 827              	.L32:
 423:../CX3RDKOV5640.c ****             }
 424:../CX3RDKOV5640.c **** 
 425:../CX3RDKOV5640.c ****             /* Commit Buffer to USB*/
 426:../CX3RDKOV5640.c ****             status = CyU3PDmaMultiChannelCommitBuffer (chHandle, (DmaBuffer.count + 12), 0);
 828              		.loc 1 426 0
 829 00e0 B0315BE1 		ldrh	r3, [fp, #-16]
 830 00e4 0C3083E2 		add	r3, r3, #12
 831 00e8 0338A0E1 		mov	r3, r3, asl #16
 832 00ec 2338A0E1 		mov	r3, r3, lsr #16
 833 00f0 18001BE5 		ldr	r0, [fp, #-24]
 834 00f4 0310A0E1 		mov	r1, r3
 835 00f8 0020A0E3 		mov	r2, #0
 836 00fc FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 837 0100 08000BE5 		str	r0, [fp, #-8]
 427:../CX3RDKOV5640.c ****             if (status != CY_U3P_SUCCESS)
 838              		.loc 1 427 0
 839 0104 08301BE5 		ldr	r3, [fp, #-8]
 840 0108 000053E3 		cmp	r3, #0
 841 010c 0500000A 		beq	.L33
 428:../CX3RDKOV5640.c ****             {
 429:../CX3RDKOV5640.c ****                    CyU3PEventSet(&glTimerEvent, ES_TIMER_RESET_EVENT,CYU3P_EVENT_OR);
 842              		.loc 1 429 0
 843 0110 78029FE5 		ldr	r0, .L42+16
 844 0114 1010A0E3 		mov	r1, #16
 845 0118 0020A0E3 		mov	r2, #0
 846 011c FEFFFFEB 		bl	_txe_event_flags_set
 430:../CX3RDKOV5640.c ****                    break;
 847              		.loc 1 430 0
 848 0120 0000A0E1 		mov	r0, r0	@ nop
 849 0124 930000EA 		b	.L27
 850              	.L33:
 431:../CX3RDKOV5640.c ****             }
 432:../CX3RDKOV5640.c ****             else
 433:../CX3RDKOV5640.c ****             {
 434:../CX3RDKOV5640.c ****                 glDMATxCount++;
 851              		.loc 1 434 0
 852 0128 64329FE5 		ldr	r3, .L42+20
 853 012c 003093E5 		ldr	r3, [r3]
 854 0130 012083E2 		add	r2, r3, #1
 855 0134 58329FE5 		ldr	r3, .L42+20
 856 0138 002083E5 		str	r2, [r3]
 435:../CX3RDKOV5640.c ****                 glDmaDone++;
 857              		.loc 1 435 0
 858 013c 54329FE5 		ldr	r3, .L42+24
 859 0140 003093E5 		ldr	r3, [r3]
 860 0144 012083E2 		add	r2, r3, #1
 861 0148 48329FE5 		ldr	r3, .L42+24
 862 014c 002083E5 		str	r2, [r3]
 436:../CX3RDKOV5640.c ****             }
 437:../CX3RDKOV5640.c **** 
 438:../CX3RDKOV5640.c ****             glActiveSocket ^= 1; /* Toggle the Active Socket */
 863              		.loc 1 438 0
 864 0150 44329FE5 		ldr	r3, .L42+28
 865 0154 0030D3E5 		ldrb	r3, [r3]
 866 0158 FF3003E2 		and	r3, r3, #255
 867 015c 013023E2 		eor	r3, r3, #1
 868 0160 FF2003E2 		and	r2, r3, #255
 869 0164 30329FE5 		ldr	r3, .L42+28
 870 0168 0020C3E5 		strb	r2, [r3]
 439:../CX3RDKOV5640.c ****             status = CyU3PDmaMultiChannelGetBuffer(chHandle, &DmaBuffer, CYU3P_NO_WAIT);
 871              		.loc 1 439 0
 872 016c 14304BE2 		sub	r3, fp, #20
 873 0170 18001BE5 		ldr	r0, [fp, #-24]
 874 0174 0310A0E1 		mov	r1, r3
 875 0178 0020A0E3 		mov	r2, #0
 876 017c FEFFFFEB 		bl	CyU3PDmaMultiChannelGetBuffer
 877 0180 08000BE5 		str	r0, [fp, #-8]
 878              	.L30:
 408:../CX3RDKOV5640.c ****         {
 879              		.loc 1 408 0 discriminator 1
 880 0184 08301BE5 		ldr	r3, [fp, #-8]
 881 0188 000053E3 		cmp	r3, #0
 882 018c C0FFFF0A 		beq	.L35
 883 0190 780000EA 		b	.L27
 884              	.L28:
 440:../CX3RDKOV5640.c ****         }
 441:../CX3RDKOV5640.c ****     }
 442:../CX3RDKOV5640.c ****     else if(type == CY_U3P_DMA_CB_CONS_EVENT)
 885              		.loc 1 442 0
 886 0194 BA315BE1 		ldrh	r3, [fp, #-26]
 887 0198 100053E3 		cmp	r3, #16
 888 019c 7500001A 		bne	.L27
 443:../CX3RDKOV5640.c ****     {
 444:../CX3RDKOV5640.c ****         glDmaDone--;
 889              		.loc 1 444 0
 890 01a0 F0319FE5 		ldr	r3, .L42+24
 891 01a4 003093E5 		ldr	r3, [r3]
 892 01a8 012043E2 		sub	r2, r3, #1
 893 01ac E4319FE5 		ldr	r3, .L42+24
 894 01b0 002083E5 		str	r2, [r3]
 445:../CX3RDKOV5640.c **** 
 446:../CX3RDKOV5640.c ****         /* Check if Frame is completely transferred */
 447:../CX3RDKOV5640.c ****         glIsStreamingStarted = CyTrue;
 895              		.loc 1 447 0
 896 01b4 E4319FE5 		ldr	r3, .L42+32
 897 01b8 0120A0E3 		mov	r2, #1
 898 01bc 002083E5 		str	r2, [r3]
 448:../CX3RDKOV5640.c **** 
 449:../CX3RDKOV5640.c ****         if((glHitFV == CyTrue) && (glDmaDone == 0))
 899              		.loc 1 449 0
 900 01c0 C4319FE5 		ldr	r3, .L42+12
 901 01c4 003093E5 		ldr	r3, [r3]
 902 01c8 010053E3 		cmp	r3, #1
 903 01cc 6900001A 		bne	.L27
 904              		.loc 1 449 0 is_stmt 0 discriminator 1
 905 01d0 C0319FE5 		ldr	r3, .L42+24
 906 01d4 003093E5 		ldr	r3, [r3]
 907 01d8 000053E3 		cmp	r3, #0
 908 01dc 6500001A 		bne	.L27
 450:../CX3RDKOV5640.c ****         {
 451:../CX3RDKOV5640.c ****             glHitFV = CyFalse;
 909              		.loc 1 451 0 is_stmt 1
 910 01e0 A4319FE5 		ldr	r3, .L42+12
 911 01e4 0020A0E3 		mov	r2, #0
 912 01e8 002083E5 		str	r2, [r3]
 452:../CX3RDKOV5640.c ****             glDMATxCount=0;
 913              		.loc 1 452 0
 914 01ec A0319FE5 		ldr	r3, .L42+20
 915 01f0 0020A0E3 		mov	r2, #0
 916 01f4 002083E5 		str	r2, [r3]
 453:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
 454:../CX3RDKOV5640.c ****             CyU3PTimerStop (&UvcTimer);
 917              		.loc 1 454 0
 918 01f8 84019FE5 		ldr	r0, .L42+4
 919 01fc FEFFFFEB 		bl	_txe_timer_deactivate
 455:../CX3RDKOV5640.c **** #endif
 456:../CX3RDKOV5640.c **** 
 457:../CX3RDKOV5640.c ****             if (glActiveSocket)
 920              		.loc 1 457 0
 921 0200 94319FE5 		ldr	r3, .L42+28
 922 0204 0030D3E5 		ldrb	r3, [r3]
 923 0208 FF3003E2 		and	r3, r3, #255
 924 020c 000053E3 		cmp	r3, #0
 925 0210 0700000A 		beq	.L37
 458:../CX3RDKOV5640.c ****                 CyU3PGpifSMSwitch(ES_UVC_INVALID_GPIF_STATE, CX3_START_SCK1,
 926              		.loc 1 458 0
 927 0214 0230A0E3 		mov	r3, #2
 928 0218 00308DE5 		str	r3, [sp]
 929 021c 80019FE5 		ldr	r0, .L42+36
 930 0220 0D10A0E3 		mov	r1, #13
 931 0224 78219FE5 		ldr	r2, .L42+36
 932 0228 0030A0E3 		mov	r3, #0
 933 022c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 934 0230 060000EA 		b	.L38
 935              	.L37:
 459:../CX3RDKOV5640.c ****                 		ES_UVC_INVALID_GPIF_STATE, ALPHA_CX3_START_SCK1, ES_UVC_GPIF_SWITCH_TIMEOUT);
 460:../CX3RDKOV5640.c ****             else
 461:../CX3RDKOV5640.c ****                 CyU3PGpifSMSwitch(ES_UVC_INVALID_GPIF_STATE, CX3_START_SCK0,
 936              		.loc 1 461 0
 937 0234 0230A0E3 		mov	r3, #2
 938 0238 00308DE5 		str	r3, [sp]
 939 023c 60019FE5 		ldr	r0, .L42+36
 940 0240 0010A0E3 		mov	r1, #0
 941 0244 58219FE5 		ldr	r2, .L42+36
 942 0248 0030A0E3 		mov	r3, #0
 943 024c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 944              	.L38:
 462:../CX3RDKOV5640.c ****                 		ES_UVC_INVALID_GPIF_STATE, ALPHA_CX3_START_SCK0, ES_UVC_GPIF_SWITCH_TIMEOUT);
 463:../CX3RDKOV5640.c **** #ifdef VISDebug
 464:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppDmaCallback:CY_U3P_DMA_CB_CONS_EVENT glActiveSocket  %x", glActiveS
 465:../CX3RDKOV5640.c **** #endif
 466:../CX3RDKOV5640.c ****             CyU3PUsbLPMEnable ();
 945              		.loc 1 466 0
 946 0250 FEFFFFEB 		bl	CyU3PUsbLPMEnable
 467:../CX3RDKOV5640.c ****             doLpmDisable = CyTrue;
 947              		.loc 1 467 0
 948 0254 24319FE5 		ldr	r3, .L42
 949 0258 0120A0E3 		mov	r2, #1
 950 025c 002083E5 		str	r2, [r3]
 468:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
 469:../CX3RDKOV5640.c ****             CyU3PTimerModify (&UvcTimer, TIMER_PERIOD, 0);
 951              		.loc 1 469 0
 952 0260 1C019FE5 		ldr	r0, .L42+4
 953 0264 7D1FA0E3 		mov	r1, #500
 954 0268 0020A0E3 		mov	r2, #0
 955 026c FEFFFFEB 		bl	_txe_timer_change
 470:../CX3RDKOV5640.c **** #endif
 471:../CX3RDKOV5640.c **** 
 472:../CX3RDKOV5640.c ****             if(glStillCaptured == CyTrue)
 956              		.loc 1 472 0
 957 0270 30319FE5 		ldr	r3, .L42+40
 958 0274 003093E5 		ldr	r3, [r3]
 959 0278 010053E3 		cmp	r3, #1
 960 027c 1000001A 		bne	.L39
 473:../CX3RDKOV5640.c ****             {
 474:../CX3RDKOV5640.c ****             	glStillCaptured = CyFalse;
 961              		.loc 1 474 0
 962 0280 20319FE5 		ldr	r3, .L42+40
 963 0284 0020A0E3 		mov	r2, #0
 964 0288 002083E5 		str	r2, [r3]
 475:../CX3RDKOV5640.c ****             	glUVCHeader[1]^=ES_UVC_HEADER_STILL_IMAGE;
 965              		.loc 1 475 0
 966 028c 18319FE5 		ldr	r3, .L42+44
 967 0290 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 968 0294 203023E2 		eor	r3, r3, #32
 969 0298 FF2003E2 		and	r2, r3, #255
 970 029c 08319FE5 		ldr	r3, .L42+44
 971 02a0 0120C3E5 		strb	r2, [r3, #1]
 476:../CX3RDKOV5640.c ****             	glFrameIndexToSet = glCurrentFrameIndex;  //for still test
 972              		.loc 1 476 0
 973 02a4 04319FE5 		ldr	r3, .L42+48
 974 02a8 0020D3E5 		ldrb	r2, [r3]	@ zero_extendqisi2
 975 02ac 00319FE5 		ldr	r3, .L42+52
 976 02b0 0020C3E5 		strb	r2, [r3]
 477:../CX3RDKOV5640.c ****             	CyU3PEventSet(&glTimerEvent, ES_TIMER_RESET_EVENT,CYU3P_EVENT_OR);
 977              		.loc 1 477 0
 978 02b4 D4009FE5 		ldr	r0, .L42+16
 979 02b8 1010A0E3 		mov	r1, #16
 980 02bc 0020A0E3 		mov	r2, #0
 981 02c0 FEFFFFEB 		bl	_txe_event_flags_set
 982              	.L39:
 478:../CX3RDKOV5640.c ****             }
 479:../CX3RDKOV5640.c ****             if(glStillCaptureStart == CyTrue)
 983              		.loc 1 479 0
 984 02c4 EC309FE5 		ldr	r3, .L42+56
 985 02c8 003093E5 		ldr	r3, [r3]
 986 02cc 010053E3 		cmp	r3, #1
 987 02d0 2800001A 		bne	.L27
 480:../CX3RDKOV5640.c ****             {
 481:../CX3RDKOV5640.c ****             	if(glStillSkip >= 3)
 988              		.loc 1 481 0
 989 02d4 E0309FE5 		ldr	r3, .L42+60
 990 02d8 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 991 02dc 020053E3 		cmp	r3, #2
 992 02e0 0D00009A 		bls	.L40
 482:../CX3RDKOV5640.c **** 				{
 483:../CX3RDKOV5640.c ****             		glStillSkip--;
 993              		.loc 1 483 0
 994 02e4 D0309FE5 		ldr	r3, .L42+60
 995 02e8 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 996 02ec 013043E2 		sub	r3, r3, #1
 997 02f0 FF2003E2 		and	r2, r3, #255
 998 02f4 C0309FE5 		ldr	r3, .L42+60
 999 02f8 0020C3E5 		strb	r2, [r3]
 484:../CX3RDKOV5640.c ****             		glFrameIndexToSet = 4;
 1000              		.loc 1 484 0
 1001 02fc B0309FE5 		ldr	r3, .L42+52
 1002 0300 0420A0E3 		mov	r2, #4
 1003 0304 0020C3E5 		strb	r2, [r3]
 485:../CX3RDKOV5640.c **** 					CyU3PEventSet(&glTimerEvent, ES_TIMER_RESET_EVENT,CYU3P_EVENT_OR);
 1004              		.loc 1 485 0
 1005 0308 80009FE5 		ldr	r0, .L42+16
 1006 030c 1010A0E3 		mov	r1, #16
 1007 0310 0020A0E3 		mov	r2, #0
 1008 0314 FEFFFFEB 		bl	_txe_event_flags_set
 1009 0318 160000EA 		b	.L27
 1010              	.L40:
 486:../CX3RDKOV5640.c **** 					//CyU3PDebugPrint (4, "\n\rCY_U3P_USB_EVENT_SETINTF: glstillSkip 3");
 487:../CX3RDKOV5640.c **** 				}
 488:../CX3RDKOV5640.c ****             	else if(glStillSkip <= 0)
 1011              		.loc 1 488 0
 1012 031c 98309FE5 		ldr	r3, .L42+60
 1013 0320 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1014 0324 000053E3 		cmp	r3, #0
 1015 0328 0C00001A 		bne	.L41
 489:../CX3RDKOV5640.c ****             	{
 490:../CX3RDKOV5640.c ****             		glStillCaptureStart = CyFalse;
 1016              		.loc 1 490 0
 1017 032c 84309FE5 		ldr	r3, .L42+56
 1018 0330 0020A0E3 		mov	r2, #0
 1019 0334 002083E5 		str	r2, [r3]
 491:../CX3RDKOV5640.c **** 					glStillCaptured = CyTrue;
 1020              		.loc 1 491 0
 1021 0338 68309FE5 		ldr	r3, .L42+40
 1022 033c 0120A0E3 		mov	r2, #1
 1023 0340 002083E5 		str	r2, [r3]
 492:../CX3RDKOV5640.c **** 					glUVCHeader[1]^=ES_UVC_HEADER_STILL_IMAGE; //end still flag at still end
 1024              		.loc 1 492 0
 1025 0344 60309FE5 		ldr	r3, .L42+44
 1026 0348 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1027 034c 203023E2 		eor	r3, r3, #32
 1028 0350 FF2003E2 		and	r2, r3, #255
 1029 0354 50309FE5 		ldr	r3, .L42+44
 1030 0358 0120C3E5 		strb	r2, [r3, #1]
 1031 035c 050000EA 		b	.L27
 1032              	.L41:
 493:../CX3RDKOV5640.c **** 					//CyU3PDebugPrint (4, "\n\rset UVC__STILL_IMAGE: glstillSkip 0");
 494:../CX3RDKOV5640.c ****             	}
 495:../CX3RDKOV5640.c ****             	else
 496:../CX3RDKOV5640.c ****             		glStillSkip--;
 1033              		.loc 1 496 0
 1034 0360 54309FE5 		ldr	r3, .L42+60
 1035 0364 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1036 0368 013043E2 		sub	r3, r3, #1
 1037 036c FF2003E2 		and	r2, r3, #255
 1038 0370 44309FE5 		ldr	r3, .L42+60
 1039 0374 0020C3E5 		strb	r2, [r3]
 1040              	.L27:
 497:../CX3RDKOV5640.c ****             }
 498:../CX3RDKOV5640.c ****         }
 499:../CX3RDKOV5640.c ****     }
 500:../CX3RDKOV5640.c **** }
 1041              		.loc 1 500 0
 1042 0378 04D04BE2 		sub	sp, fp, #4
 1043              		@ sp needed
 1044 037c 0088BDE8 		ldmfd	sp!, {fp, pc}
 1045              	.L43:
 1046              		.align	2
 1047              	.L42:
 1048 0380 00000000 		.word	doLpmDisable
 1049 0384 00000000 		.word	UvcTimer
 1050 0388 00000000 		.word	ES_UVC_DATA_BUF_SIZE
 1051 038c 00000000 		.word	glHitFV
 1052 0390 00000000 		.word	glTimerEvent
 1053 0394 00000000 		.word	glDMATxCount
 1054 0398 00000000 		.word	glDmaDone
 1055 039c 00000000 		.word	glActiveSocket
 1056 03a0 00000000 		.word	glIsStreamingStarted
 1057 03a4 01010000 		.word	257
 1058 03a8 00000000 		.word	glStillCaptured
 1059 03ac 00000000 		.word	glUVCHeader
 1060 03b0 00000000 		.word	glCurrentFrameIndex
 1061 03b4 00000000 		.word	glFrameIndexToSet
 1062 03b8 00000000 		.word	glStillCaptureStart
 1063 03bc 00000000 		.word	glStillSkip
 1064              		.cfi_endproc
 1065              	.LFE6:
 1067              		.section	.text.esUVCUvcApplnUSBEventCB,"ax",%progbits
 1068              		.align	2
 1070              	esUVCUvcApplnUSBEventCB:
 1071              	.LFB7:
 501:../CX3RDKOV5640.c **** 
 502:../CX3RDKOV5640.c **** /* This is the Callback function to handle the USB Events */
 503:../CX3RDKOV5640.c ****     static void
 504:../CX3RDKOV5640.c **** esUVCUvcApplnUSBEventCB (
 505:../CX3RDKOV5640.c ****         CyU3PUsbEventType_t evtype,     /* Event type */
 506:../CX3RDKOV5640.c ****         uint16_t            evdata      /* Event data */
 507:../CX3RDKOV5640.c ****         )
 508:../CX3RDKOV5640.c **** {
 1072              		.loc 1 508 0
 1073              		.cfi_startproc
 1074              		@ args = 0, pretend = 0, frame = 16
 1075              		@ frame_needed = 1, uses_anonymous_args = 0
 1076 0000 00482DE9 		stmfd	sp!, {fp, lr}
 1077              	.LCFI14:
 1078              		.cfi_def_cfa_offset 8
 1079              		.cfi_offset 11, -8
 1080              		.cfi_offset 14, -4
 1081 0004 04B08DE2 		add	fp, sp, #4
 1082              	.LCFI15:
 1083              		.cfi_def_cfa 11, 4
 1084 0008 10D04DE2 		sub	sp, sp, #16
 1085 000c 0020A0E1 		mov	r2, r0
 1086 0010 0130A0E1 		mov	r3, r1
 1087 0014 0D204BE5 		strb	r2, [fp, #-13]
 1088 0018 B0314BE1 		strh	r3, [fp, #-16]	@ movhi
 509:../CX3RDKOV5640.c ****     uint8_t interface = 0, altSetting = 0;
 1089              		.loc 1 509 0
 1090 001c 0030A0E3 		mov	r3, #0
 1091 0020 05304BE5 		strb	r3, [fp, #-5]
 1092 0024 0030A0E3 		mov	r3, #0
 1093 0028 06304BE5 		strb	r3, [fp, #-6]
 510:../CX3RDKOV5640.c **** 
 511:../CX3RDKOV5640.c ****     switch (evtype)
 1094              		.loc 1 511 0
 1095 002c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1096 0030 070053E3 		cmp	r3, #7
 1097 0034 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1098 0038 530000EA 		b	.L57
 1099              	.L47:
 1100 003c 2C010000 		.word	.L46
 1101 0040 2C010000 		.word	.L46
 1102 0044 5C000000 		.word	.L48
 1103 0048 8C010000 		.word	.L57
 1104 004c 2C010000 		.word	.L46
 1105 0050 2C010000 		.word	.L46
 1106 0054 8C010000 		.word	.L57
 1107 0058 7C000000 		.word	.L49
 1108              	.L48:
 512:../CX3RDKOV5640.c ****     {
 513:../CX3RDKOV5640.c ****         case CY_U3P_USB_EVENT_SUSPEND:
 514:../CX3RDKOV5640.c ****             /* Suspend the device with Wake On Bus Activity set */
 515:../CX3RDKOV5640.c ****             glIsStreamingStarted = CyFalse;
 1109              		.loc 1 515 0
 1110 005c 34319FE5 		ldr	r3, .L58
 1111 0060 0020A0E3 		mov	r2, #0
 1112 0064 002083E5 		str	r2, [r3]
 516:../CX3RDKOV5640.c ****             CyU3PEventSet (&glTimerEvent, ES_USB_SUSP_EVENT_FLAG, CYU3P_EVENT_OR);
 1113              		.loc 1 516 0
 1114 0068 2C019FE5 		ldr	r0, .L58+4
 1115 006c 2010A0E3 		mov	r1, #32
 1116 0070 0020A0E3 		mov	r2, #0
 1117 0074 FEFFFFEB 		bl	_txe_event_flags_set
 517:../CX3RDKOV5640.c ****             break;
 1118              		.loc 1 517 0
 1119 0078 440000EA 		b	.L44
 1120              	.L49:
 518:../CX3RDKOV5640.c ****         case CY_U3P_USB_EVENT_SETINTF:
 519:../CX3RDKOV5640.c ****             /* Start the video streamer application if the
 520:../CX3RDKOV5640.c ****              * interface requested was 1. If not, stop the
 521:../CX3RDKOV5640.c ****              * streamer. */
 522:../CX3RDKOV5640.c ****             interface = CY_U3P_GET_MSB(evdata);
 1121              		.loc 1 522 0
 1122 007c B0315BE1 		ldrh	r3, [fp, #-16]
 1123 0080 2334A0E1 		mov	r3, r3, lsr #8
 1124 0084 0338A0E1 		mov	r3, r3, asl #16
 1125 0088 2338A0E1 		mov	r3, r3, lsr #16
 1126 008c 05304BE5 		strb	r3, [fp, #-5]
 523:../CX3RDKOV5640.c ****             altSetting = CY_U3P_GET_LSB(evdata);
 1127              		.loc 1 523 0
 1128 0090 B0315BE1 		ldrh	r3, [fp, #-16]	@ movhi
 1129 0094 06304BE5 		strb	r3, [fp, #-6]
 524:../CX3RDKOV5640.c **** 
 525:../CX3RDKOV5640.c ****             glIsStreamingStarted = CyFalse;
 1130              		.loc 1 525 0
 1131 0098 F8309FE5 		ldr	r3, .L58
 1132 009c 0020A0E3 		mov	r2, #0
 1133 00a0 002083E5 		str	r2, [r3]
 526:../CX3RDKOV5640.c **** 
 527:../CX3RDKOV5640.c ****             if ((altSetting == ES_UVC_STREAM_INTERFACE) && (interface == 1))
 1134              		.loc 1 527 0
 1135 00a4 06305BE5 		ldrb	r3, [fp, #-6]	@ zero_extendqisi2
 1136 00a8 010053E3 		cmp	r3, #1
 1137 00ac 0C00001A 		bne	.L51
 1138              		.loc 1 527 0 is_stmt 0 discriminator 1
 1139 00b0 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1140 00b4 010053E3 		cmp	r3, #1
 1141 00b8 0900001A 		bne	.L51
 528:../CX3RDKOV5640.c ****             {
 529:../CX3RDKOV5640.c ****                 /* Stop the application before re-starting. */
 530:../CX3RDKOV5640.c ****                 if (glIsApplnActive)
 1142              		.loc 1 530 0 is_stmt 1
 1143 00bc DC309FE5 		ldr	r3, .L58+8
 1144 00c0 003093E5 		ldr	r3, [r3]
 1145 00c4 000053E3 		cmp	r3, #0
 1146 00c8 0300000A 		beq	.L52
 531:../CX3RDKOV5640.c ****                 {
 532:../CX3RDKOV5640.c ****                 	glIsClearFeature = CyTrue;
 1147              		.loc 1 532 0
 1148 00cc D0309FE5 		ldr	r3, .L58+12
 1149 00d0 0120A0E3 		mov	r2, #1
 1150 00d4 002083E5 		str	r2, [r3]
 533:../CX3RDKOV5640.c ****                     esUVCUvcApplnStop ();
 1151              		.loc 1 533 0
 1152 00d8 FEFFFFEB 		bl	esUVCUvcApplnStop
 1153              	.L52:
 534:../CX3RDKOV5640.c **** #ifdef VISDebug
 535:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rCY_U3P_USB_EVENT_SETINTF&ES_UVC_STREAM_INTERFACE: esUVCUvcApplnStop");
 536:../CX3RDKOV5640.c **** #endif
 537:../CX3RDKOV5640.c ****                 }
 538:../CX3RDKOV5640.c ****                 esUVCUvcApplnStart ();
 1154              		.loc 1 538 0
 1155 00dc FEFFFFEB 		bl	esUVCUvcApplnStart
 1156 00e0 100000EA 		b	.L53
 1157              	.L51:
 539:../CX3RDKOV5640.c **** #ifdef VISDebug
 540:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rCY_U3P_USB_EVENT_SETINTF&ES_UVC_STREAM_INTERFACE: esUVCUvcApplnStart")
 541:../CX3RDKOV5640.c **** #endif
 542:../CX3RDKOV5640.c **** 
 543:../CX3RDKOV5640.c ****             }
 544:../CX3RDKOV5640.c ****             else if ((altSetting == 0x00) && (interface == 1))
 1158              		.loc 1 544 0
 1159 00e4 06305BE5 		ldrb	r3, [fp, #-6]	@ zero_extendqisi2
 1160 00e8 000053E3 		cmp	r3, #0
 1161 00ec 0D00001A 		bne	.L53
 1162              		.loc 1 544 0 is_stmt 0 discriminator 1
 1163 00f0 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1164 00f4 010053E3 		cmp	r3, #1
 1165 00f8 0A00001A 		bne	.L53
 545:../CX3RDKOV5640.c ****             {
 546:../CX3RDKOV5640.c ****             	glPreviewStarted = CyFalse;
 1166              		.loc 1 546 0 is_stmt 1
 1167 00fc A4309FE5 		ldr	r3, .L58+16
 1168 0100 0020A0E3 		mov	r2, #0
 1169 0104 002083E5 		str	r2, [r3]
 547:../CX3RDKOV5640.c ****             	/* Stop the application before re-starting. */
 548:../CX3RDKOV5640.c ****             	glIsClearFeature = CyTrue;
 1170              		.loc 1 548 0
 1171 0108 94309FE5 		ldr	r3, .L58+12
 1172 010c 0120A0E3 		mov	r2, #1
 1173 0110 002083E5 		str	r2, [r3]
 549:../CX3RDKOV5640.c **** 				esUVCUvcApplnStop ();
 1174              		.loc 1 549 0
 1175 0114 FEFFFFEB 		bl	esUVCUvcApplnStop
 550:../CX3RDKOV5640.c **** 
 551:../CX3RDKOV5640.c **** 				glcommitcount = 0;
 1176              		.loc 1 551 0
 1177 0118 8C309FE5 		ldr	r3, .L58+20
 1178 011c 0020A0E3 		mov	r2, #0
 1179 0120 0020C3E5 		strb	r2, [r3]
 552:../CX3RDKOV5640.c **** #ifdef VISDebug
 553:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rCY_U3P_USB_EVENT_SETINTF: esUVCUvcApplnStop");
 554:../CX3RDKOV5640.c **** #endif
 555:../CX3RDKOV5640.c ****             }
 556:../CX3RDKOV5640.c ****             break;
 1180              		.loc 1 556 0
 1181 0124 190000EA 		b	.L44
 1182              	.L53:
 1183 0128 180000EA 		b	.L44
 1184              	.L46:
 557:../CX3RDKOV5640.c **** 
 558:../CX3RDKOV5640.c ****             /* Fall-through. */
 559:../CX3RDKOV5640.c **** 
 560:../CX3RDKOV5640.c ****         case CY_U3P_USB_EVENT_SETCONF:
 561:../CX3RDKOV5640.c ****         case CY_U3P_USB_EVENT_RESET:
 562:../CX3RDKOV5640.c ****         case CY_U3P_USB_EVENT_DISCONNECT:
 563:../CX3RDKOV5640.c ****         case CY_U3P_USB_EVENT_CONNECT:
 564:../CX3RDKOV5640.c ****             glIsStreamingStarted = CyFalse;
 1185              		.loc 1 564 0
 1186 012c 64309FE5 		ldr	r3, .L58
 1187 0130 0020A0E3 		mov	r2, #0
 1188 0134 002083E5 		str	r2, [r3]
 565:../CX3RDKOV5640.c ****             if (evtype == CY_U3P_USB_EVENT_SETCONF)
 1189              		.loc 1 565 0
 1190 0138 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1191 013c 050053E3 		cmp	r3, #5
 1192 0140 0300001A 		bne	.L54
 566:../CX3RDKOV5640.c ****                 glIsConfigured = CyTrue;
 1193              		.loc 1 566 0
 1194 0144 64309FE5 		ldr	r3, .L58+24
 1195 0148 0120A0E3 		mov	r2, #1
 1196 014c 002083E5 		str	r2, [r3]
 1197 0150 020000EA 		b	.L55
 1198              	.L54:
 567:../CX3RDKOV5640.c ****             else
 568:../CX3RDKOV5640.c ****                 glIsConfigured = CyFalse;
 1199              		.loc 1 568 0
 1200 0154 54309FE5 		ldr	r3, .L58+24
 1201 0158 0020A0E3 		mov	r2, #0
 1202 015c 002083E5 		str	r2, [r3]
 1203              	.L55:
 569:../CX3RDKOV5640.c **** 
 570:../CX3RDKOV5640.c ****             /* Stop the video streamer application and enable LPM. */
 571:../CX3RDKOV5640.c ****             CyU3PUsbLPMEnable ();
 1204              		.loc 1 571 0
 1205 0160 FEFFFFEB 		bl	CyU3PUsbLPMEnable
 572:../CX3RDKOV5640.c ****             if (glIsApplnActive)
 1206              		.loc 1 572 0
 1207 0164 34309FE5 		ldr	r3, .L58+8
 1208 0168 003093E5 		ldr	r3, [r3]
 1209 016c 000053E3 		cmp	r3, #0
 1210 0170 0400000A 		beq	.L56
 573:../CX3RDKOV5640.c ****             {
 574:../CX3RDKOV5640.c ****             	glIsClearFeature = CyTrue;
 1211              		.loc 1 574 0
 1212 0174 28309FE5 		ldr	r3, .L58+12
 1213 0178 0120A0E3 		mov	r2, #1
 1214 017c 002083E5 		str	r2, [r3]
 575:../CX3RDKOV5640.c ****                 esUVCUvcApplnStop ();
 1215              		.loc 1 575 0
 1216 0180 FEFFFFEB 		bl	esUVCUvcApplnStop
 576:../CX3RDKOV5640.c **** #ifdef VISDebug
 577:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rEvent %x: esUVCUvcApplnStop", evtype);
 578:../CX3RDKOV5640.c **** #endif
 579:../CX3RDKOV5640.c ****             }
 580:../CX3RDKOV5640.c ****             break;
 1217              		.loc 1 580 0
 1218 0184 010000EA 		b	.L44
 1219              	.L56:
 1220 0188 000000EA 		b	.L44
 1221              	.L57:
 581:../CX3RDKOV5640.c ****         default:
 582:../CX3RDKOV5640.c ****             break;
 1222              		.loc 1 582 0
 1223 018c 0000A0E1 		mov	r0, r0	@ nop
 1224              	.L44:
 583:../CX3RDKOV5640.c ****     }
 584:../CX3RDKOV5640.c **** }
 1225              		.loc 1 584 0
 1226 0190 04D04BE2 		sub	sp, fp, #4
 1227              		@ sp needed
 1228 0194 0088BDE8 		ldmfd	sp!, {fp, pc}
 1229              	.L59:
 1230              		.align	2
 1231              	.L58:
 1232 0198 00000000 		.word	glIsStreamingStarted
 1233 019c 00000000 		.word	glTimerEvent
 1234 01a0 00000000 		.word	glIsApplnActive
 1235 01a4 00000000 		.word	glIsClearFeature
 1236 01a8 00000000 		.word	glPreviewStarted
 1237 01ac 00000000 		.word	glcommitcount
 1238 01b0 00000000 		.word	glIsConfigured
 1239              		.cfi_endproc
 1240              	.LFE7:
 1242              		.section	.text.esUVCApplnLPMRqtCB,"ax",%progbits
 1243              		.align	2
 1245              	esUVCApplnLPMRqtCB:
 1246              	.LFB8:
 585:../CX3RDKOV5640.c **** 
 586:../CX3RDKOV5640.c **** /* Callback for LPM requests. Always return true to allow host to transition device
 587:../CX3RDKOV5640.c ****  * into required LPM state U1/U2/U3. When data transmission is active LPM management
 588:../CX3RDKOV5640.c ****  * is explicitly disabled to prevent data transmission errors.
 589:../CX3RDKOV5640.c ****  */
 590:../CX3RDKOV5640.c **** static CyBool_t esUVCApplnLPMRqtCB (
 591:../CX3RDKOV5640.c ****         CyU3PUsbLinkPowerMode link_mode         /*USB 3.0 linkmode requested by Host */
 592:../CX3RDKOV5640.c ****         )
 593:../CX3RDKOV5640.c **** {
 1247              		.loc 1 593 0
 1248              		.cfi_startproc
 1249              		@ args = 0, pretend = 0, frame = 8
 1250              		@ frame_needed = 1, uses_anonymous_args = 0
 1251              		@ link register save eliminated.
 1252 0000 04B02DE5 		str	fp, [sp, #-4]!
 1253              	.LCFI16:
 1254              		.cfi_def_cfa_offset 4
 1255              		.cfi_offset 11, -4
 1256 0004 00B08DE2 		add	fp, sp, #0
 1257              	.LCFI17:
 1258              		.cfi_def_cfa_register 11
 1259 0008 0CD04DE2 		sub	sp, sp, #12
 1260 000c 0030A0E1 		mov	r3, r0
 1261 0010 05304BE5 		strb	r3, [fp, #-5]
 594:../CX3RDKOV5640.c ****     return CyTrue;
 1262              		.loc 1 594 0
 1263 0014 0130A0E3 		mov	r3, #1
 595:../CX3RDKOV5640.c **** }
 1264              		.loc 1 595 0
 1265 0018 0300A0E1 		mov	r0, r3
 1266 001c 00D04BE2 		sub	sp, fp, #0
 1267              		@ sp needed
 1268 0020 04B09DE4 		ldr	fp, [sp], #4
 1269 0024 1EFF2FE1 		bx	lr
 1270              		.cfi_endproc
 1271              	.LFE8:
 1273              		.section	.rodata
 1274              		.align	2
 1275              	.LC5:
 1276 00a8 0A0D6573 		.ascii	"\012\015esSetCameraResolution %d\000"
 1276      53657443 
 1276      616D6572 
 1276      61526573 
 1276      6F6C7574 
 1277 00c3 00       		.align	2
 1278              	.LC6:
 1279 00c4 0A0D5553 		.ascii	"\012\015USBStpCB:SetIntfParams SS1 Err = 0x%x\000"
 1279      42537470 
 1279      43423A53 
 1279      6574496E 
 1279      74665061 
 1280              		.align	2
 1281              	.LC7:
 1282 00ec 0A0D5553 		.ascii	"\012\015USBStpCB:SetIntfParams FS Err = 0x%x\000"
 1282      42537470 
 1282      43423A53 
 1282      6574496E 
 1282      74665061 
 1283 0113 00       		.align	2
 1284              	.LC8:
 1285 0114 0A0D5553 		.ascii	"\012\015USBStpCB:SetIntfParams SS2 Err = 0x%x\000"
 1285      42537470 
 1285      43423A53 
 1285      6574496E 
 1285      74665061 
 1286              		.align	2
 1287              	.LC9:
 1288 013c 0A0D5553 		.ascii	"\012\015USBStpCB:SetIntfParams HS Err = 0x%x\000"
 1288      42537470 
 1288      43423A53 
 1288      6574496E 
 1288      74665061 
 1289              		.section	.text.esSetCameraResolution,"ax",%progbits
 1290              		.align	2
 1291              		.global	esSetCameraResolution
 1293              	esSetCameraResolution:
 1294              	.LFB9:
 596:../CX3RDKOV5640.c **** 
 597:../CX3RDKOV5640.c **** //TODO Change this function with "Sensor Specific" function to write the sensor settings & configur
 598:../CX3RDKOV5640.c **** void esSetCameraResolution(uint8_t FrameIndex)
 599:../CX3RDKOV5640.c **** {
 1295              		.loc 1 599 0
 1296              		.cfi_startproc
 1297              		@ args = 0, pretend = 0, frame = 16
 1298              		@ frame_needed = 1, uses_anonymous_args = 0
 1299 0000 00482DE9 		stmfd	sp!, {fp, lr}
 1300              	.LCFI18:
 1301              		.cfi_def_cfa_offset 8
 1302              		.cfi_offset 11, -8
 1303              		.cfi_offset 14, -4
 1304 0004 04B08DE2 		add	fp, sp, #4
 1305              	.LCFI19:
 1306              		.cfi_def_cfa 11, 4
 1307 0008 10D04DE2 		sub	sp, sp, #16
 1308 000c 0030A0E1 		mov	r3, r0
 1309 0010 0D304BE5 		strb	r3, [fp, #-13]
 600:../CX3RDKOV5640.c **** 	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 1310              		.loc 1 600 0
 1311 0014 0030A0E3 		mov	r3, #0
 1312 0018 08300BE5 		str	r3, [fp, #-8]
 601:../CX3RDKOV5640.c **** 	CyU3PDebugPrint (4, "\n\resSetCameraResolution %d", FrameIndex);
 1313              		.loc 1 601 0
 1314 001c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1315 0020 0400A0E3 		mov	r0, #4
 1316 0024 80119FE5 		ldr	r1, .L74
 1317 0028 0320A0E1 		mov	r2, r3
 1318 002c FEFFFFEB 		bl	CyU3PDebugPrint
 602:../CX3RDKOV5640.c **** 	FrameIndex = 0x03; //force to set VGA 30fps -debug
 1319              		.loc 1 602 0
 1320 0030 0330A0E3 		mov	r3, #3
 1321 0034 0D304BE5 		strb	r3, [fp, #-13]
 603:../CX3RDKOV5640.c **** 	/* Super Speed USB Streams*/
 604:../CX3RDKOV5640.c **** 	if (CyU3PUsbGetSpeed () == CY_U3P_SUPER_SPEED)
 1322              		.loc 1 604 0
 1323 0038 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1324 003c 0030A0E1 		mov	r3, r0
 1325 0040 030053E3 		cmp	r3, #3
 1326 0044 3B00001A 		bne	.L63
 605:../CX3RDKOV5640.c **** 	{
 606:../CX3RDKOV5640.c **** 		if(FrameIndex == 0x01)
 1327              		.loc 1 606 0
 1328 0048 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1329 004c 010053E3 		cmp	r3, #1
 1330 0050 0B00001A 		bne	.L64
 607:../CX3RDKOV5640.c **** 		{
 608:../CX3RDKOV5640.c **** 			/* Write 1080pSettings */
 609:../CX3RDKOV5640.c **** 			status = CyU3PMipicsiSetIntfParams (&cfgUvc1080p30NoMclk, CyTrue/*CyFalse*/);
 1331              		.loc 1 609 0
 1332 0054 54019FE5 		ldr	r0, .L74+4
 1333 0058 0110A0E3 		mov	r1, #1
 1334 005c FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 1335 0060 08000BE5 		str	r0, [fp, #-8]
 610:../CX3RDKOV5640.c **** 			if (status != CY_U3P_SUCCESS)
 1336              		.loc 1 610 0
 1337 0064 08301BE5 		ldr	r3, [fp, #-8]
 1338 0068 000053E3 		cmp	r3, #0
 1339 006c 4C00000A 		beq	.L62
 611:../CX3RDKOV5640.c **** 			{
 612:../CX3RDKOV5640.c **** 				CyU3PDebugPrint (4, "\n\rUSBStpCB:SetIntfParams SS1 Err = 0x%x", status);
 1340              		.loc 1 612 0
 1341 0070 0400A0E3 		mov	r0, #4
 1342 0074 38119FE5 		ldr	r1, .L74+8
 1343 0078 08201BE5 		ldr	r2, [fp, #-8]
 1344 007c FEFFFFEB 		bl	CyU3PDebugPrint
 1345 0080 470000EA 		b	.L62
 1346              	.L64:
 613:../CX3RDKOV5640.c **** 			}
 614:../CX3RDKOV5640.c **** 			//esOV5640_1080P_config();
 615:../CX3RDKOV5640.c **** 		}
 616:../CX3RDKOV5640.c **** 		else if(FrameIndex == 0x02)
 1347              		.loc 1 616 0
 1348 0084 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1349 0088 020053E3 		cmp	r3, #2
 1350 008c 0B00001A 		bne	.L67
 617:../CX3RDKOV5640.c **** 		{
 618:../CX3RDKOV5640.c **** 			/* Write VGA Settings */
 619:../CX3RDKOV5640.c **** 			status = CyU3PMipicsiSetIntfParams (&cfgUvcVga30NoMclk, CyTrue/*CyFalse*/);
 1351              		.loc 1 619 0
 1352 0090 20019FE5 		ldr	r0, .L74+12
 1353 0094 0110A0E3 		mov	r1, #1
 1354 0098 FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 1355 009c 08000BE5 		str	r0, [fp, #-8]
 620:../CX3RDKOV5640.c **** 			if (status != CY_U3P_SUCCESS)
 1356              		.loc 1 620 0
 1357 00a0 08301BE5 		ldr	r3, [fp, #-8]
 1358 00a4 000053E3 		cmp	r3, #0
 1359 00a8 3D00000A 		beq	.L62
 621:../CX3RDKOV5640.c **** 			{
 622:../CX3RDKOV5640.c **** 				CyU3PDebugPrint (4, "\n\rUSBStpCB:SetIntfParams FS Err = 0x%x", status);
 1360              		.loc 1 622 0
 1361 00ac 0400A0E3 		mov	r0, #4
 1362 00b0 04119FE5 		ldr	r1, .L74+16
 1363 00b4 08201BE5 		ldr	r2, [fp, #-8]
 1364 00b8 FEFFFFEB 		bl	CyU3PDebugPrint
 1365 00bc 380000EA 		b	.L62
 1366              	.L67:
 623:../CX3RDKOV5640.c **** 			}
 624:../CX3RDKOV5640.c **** 			//esOV5640_VGA_config(); //for experiment
 625:../CX3RDKOV5640.c **** 		}
 626:../CX3RDKOV5640.c **** 		else if(FrameIndex == 0x03)
 1367              		.loc 1 626 0
 1368 00c0 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1369 00c4 030053E3 		cmp	r3, #3
 1370 00c8 0B00001A 		bne	.L69
 627:../CX3RDKOV5640.c **** 		{
 628:../CX3RDKOV5640.c **** 			/* Write 720pSettings */
 629:../CX3RDKOV5640.c **** 			status = CyU3PMipicsiSetIntfParams (&cfgUvc720p60NoMclk, CyFalse);
 1371              		.loc 1 629 0
 1372 00cc EC009FE5 		ldr	r0, .L74+20
 1373 00d0 0010A0E3 		mov	r1, #0
 1374 00d4 FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 1375 00d8 08000BE5 		str	r0, [fp, #-8]
 630:../CX3RDKOV5640.c **** 			if (status != CY_U3P_SUCCESS)
 1376              		.loc 1 630 0
 1377 00dc 08301BE5 		ldr	r3, [fp, #-8]
 1378 00e0 000053E3 		cmp	r3, #0
 1379 00e4 2E00000A 		beq	.L62
 631:../CX3RDKOV5640.c **** 			{
 632:../CX3RDKOV5640.c **** 				CyU3PDebugPrint (4, "\n\rUSBStpCB:SetIntfParams SS2 Err = 0x%x", status);
 1380              		.loc 1 632 0
 1381 00e8 0400A0E3 		mov	r0, #4
 1382 00ec D0109FE5 		ldr	r1, .L74+24
 1383 00f0 08201BE5 		ldr	r2, [fp, #-8]
 1384 00f4 FEFFFFEB 		bl	CyU3PDebugPrint
 1385 00f8 290000EA 		b	.L62
 1386              	.L69:
 633:../CX3RDKOV5640.c **** 			}
 634:../CX3RDKOV5640.c **** 			//esOV5640_VGA_config();//esOV5640_720P_config(); //for experiment
 635:../CX3RDKOV5640.c **** 			//CyU3PThreadSleep(1000);
 636:../CX3RDKOV5640.c **** 			//SensorGetControl(0x02, 0x30);
 637:../CX3RDKOV5640.c **** 		}
 638:../CX3RDKOV5640.c **** 		else if(FrameIndex == 0x04)
 1387              		.loc 1 638 0
 1388 00fc 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1389 0100 040053E3 		cmp	r3, #4
 1390 0104 2600001A 		bne	.L62
 639:../CX3RDKOV5640.c **** 		{
 640:../CX3RDKOV5640.c **** 			status = CyU3PMipicsiSetIntfParams (&cfgUvc5Mp15NoMclk, CyTrue/*CyFalse*/);
 1391              		.loc 1 640 0
 1392 0108 B8009FE5 		ldr	r0, .L74+28
 1393 010c 0110A0E3 		mov	r1, #1
 1394 0110 FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 1395 0114 08000BE5 		str	r0, [fp, #-8]
 641:../CX3RDKOV5640.c **** 			if (status != CY_U3P_SUCCESS)
 1396              		.loc 1 641 0
 1397 0118 08301BE5 		ldr	r3, [fp, #-8]
 1398 011c 000053E3 		cmp	r3, #0
 1399 0120 1F00000A 		beq	.L62
 642:../CX3RDKOV5640.c **** 			{
 643:../CX3RDKOV5640.c **** 				CyU3PDebugPrint (4, "\n\rUSBStpCB:SetIntfParams SS2 Err = 0x%x", status);
 1400              		.loc 1 643 0
 1401 0124 0400A0E3 		mov	r0, #4
 1402 0128 94109FE5 		ldr	r1, .L74+24
 1403 012c 08201BE5 		ldr	r2, [fp, #-8]
 1404 0130 FEFFFFEB 		bl	CyU3PDebugPrint
 1405 0134 1A0000EA 		b	.L62
 1406              	.L63:
 644:../CX3RDKOV5640.c **** 			}
 645:../CX3RDKOV5640.c **** 			//esOV5640_5MP_config();
 646:../CX3RDKOV5640.c **** 		}
 647:../CX3RDKOV5640.c **** 	}
 648:../CX3RDKOV5640.c **** 	/* High Speed USB Streams*/
 649:../CX3RDKOV5640.c **** 	else if (CyU3PUsbGetSpeed () == CY_U3P_HIGH_SPEED)
 1407              		.loc 1 649 0
 1408 0138 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1409 013c 0030A0E1 		mov	r3, r0
 1410 0140 020053E3 		cmp	r3, #2
 1411 0144 0B00001A 		bne	.L72
 650:../CX3RDKOV5640.c **** 	{
 651:../CX3RDKOV5640.c **** 		/* Write VGA Settings */
 652:../CX3RDKOV5640.c **** 		status = CyU3PMipicsiSetIntfParams (&cfgUvcVga30NoMclk, CyFalse);
 1412              		.loc 1 652 0
 1413 0148 68009FE5 		ldr	r0, .L74+12
 1414 014c 0010A0E3 		mov	r1, #0
 1415 0150 FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 1416 0154 08000BE5 		str	r0, [fp, #-8]
 653:../CX3RDKOV5640.c **** 		if (status != CY_U3P_SUCCESS)
 1417              		.loc 1 653 0
 1418 0158 08301BE5 		ldr	r3, [fp, #-8]
 1419 015c 000053E3 		cmp	r3, #0
 1420 0160 0F00000A 		beq	.L62
 654:../CX3RDKOV5640.c **** 		{
 655:../CX3RDKOV5640.c **** 			CyU3PDebugPrint (4, "\n\rUSBStpCB:SetIntfParams HS Err = 0x%x", status);
 1421              		.loc 1 655 0
 1422 0164 0400A0E3 		mov	r0, #4
 1423 0168 5C109FE5 		ldr	r1, .L74+32
 1424 016c 08201BE5 		ldr	r2, [fp, #-8]
 1425 0170 FEFFFFEB 		bl	CyU3PDebugPrint
 1426 0174 0A0000EA 		b	.L62
 1427              	.L72:
 656:../CX3RDKOV5640.c **** 		}
 657:../CX3RDKOV5640.c **** 		//esOV5640_VGA_config();
 658:../CX3RDKOV5640.c **** 		//esOV5640_VGA_HS_config();
 659:../CX3RDKOV5640.c **** 	}
 660:../CX3RDKOV5640.c **** 	/* Full Speed USB Streams*/
 661:../CX3RDKOV5640.c **** 	else
 662:../CX3RDKOV5640.c **** 	{
 663:../CX3RDKOV5640.c **** 		/* Write VGA Settings */
 664:../CX3RDKOV5640.c **** 		//esOV5640_VGA_config();
 665:../CX3RDKOV5640.c **** 		status = CyU3PMipicsiSetIntfParams (&cfgUvcVga30NoMclk, CyFalse);
 1428              		.loc 1 665 0
 1429 0178 38009FE5 		ldr	r0, .L74+12
 1430 017c 0010A0E3 		mov	r1, #0
 1431 0180 FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 1432 0184 08000BE5 		str	r0, [fp, #-8]
 666:../CX3RDKOV5640.c **** 		if (status != CY_U3P_SUCCESS)
 1433              		.loc 1 666 0
 1434 0188 08301BE5 		ldr	r3, [fp, #-8]
 1435 018c 000053E3 		cmp	r3, #0
 1436 0190 0300000A 		beq	.L62
 667:../CX3RDKOV5640.c **** 		{
 668:../CX3RDKOV5640.c **** 			CyU3PDebugPrint (4, "\n\rUSBStpCB:SetIntfParams FS Err = 0x%x", status);
 1437              		.loc 1 668 0
 1438 0194 0400A0E3 		mov	r0, #4
 1439 0198 1C109FE5 		ldr	r1, .L74+16
 1440 019c 08201BE5 		ldr	r2, [fp, #-8]
 1441 01a0 FEFFFFEB 		bl	CyU3PDebugPrint
 1442              	.L62:
 669:../CX3RDKOV5640.c **** 		}
 670:../CX3RDKOV5640.c **** 	}
 671:../CX3RDKOV5640.c **** }
 1443              		.loc 1 671 0
 1444 01a4 04D04BE2 		sub	sp, fp, #4
 1445              		@ sp needed
 1446 01a8 0088BDE8 		ldmfd	sp!, {fp, pc}
 1447              	.L75:
 1448              		.align	2
 1449              	.L74:
 1450 01ac A8000000 		.word	.LC5
 1451 01b0 00000000 		.word	cfgUvc1080p30NoMclk
 1452 01b4 C4000000 		.word	.LC6
 1453 01b8 00000000 		.word	cfgUvcVga30NoMclk
 1454 01bc EC000000 		.word	.LC7
 1455 01c0 00000000 		.word	cfgUvc720p60NoMclk
 1456 01c4 14010000 		.word	.LC8
 1457 01c8 00000000 		.word	cfgUvc5Mp15NoMclk
 1458 01cc 3C010000 		.word	.LC9
 1459              		.cfi_endproc
 1460              	.LFE9:
 1462              		.section	.rodata
 1463 0163 00       		.align	2
 1464              	.LC10:
 1465 0164 0A0D6252 		.ascii	"\012\015bRType = 0x%x, bRequest = 0x%x, wValue = 0x"
 1465      54797065 
 1465      203D2030 
 1465      7825782C 
 1465      20625265 
 1466 0191 25782C20 		.ascii	"%x, wIndex = 0x%x, wLength= 0x%x\000"
 1466      77496E64 
 1466      6578203D 
 1466      20307825 
 1466      782C2077 
 1467 01b2 0000     		.align	2
 1468              	.LC11:
 1469 01b4 0A0D4675 		.ascii	"\012\015Full Speed Not Supported!\000"
 1469      6C6C2053 
 1469      70656564 
 1469      204E6F74 
 1469      20537570 
 1470              		.align	2
 1471              	.LC12:
 1472 01d0 0A0D5553 		.ascii	"\012\015USBStpCB:GET_CUR:SendEP0Data Err = 0x%x\000"
 1472      42537470 
 1472      43423A47 
 1472      45545F43 
 1472      55523A53 
 1473 01fa 0000     		.align	2
 1474              	.LC13:
 1475 01fc 0A0D5553 		.ascii	"\012\015USBStpCB:SET_CUR:GetEP0Data Err = 0x%x.\000"
 1475      42537470 
 1475      43423A53 
 1475      45545F43 
 1475      55523A47 
 1476 0226 0000     		.align	2
 1477              	.LC14:
 1478 0228 0A0D5553 		.ascii	"\012\015USBStpCB:Invalid SET_CUR Rqt Len.\000"
 1478      42537470 
 1478      43423A49 
 1478      6E76616C 
 1478      69642053 
 1479              		.align	2
 1480              	.LC15:
 1481 024c 0A0D5553 		.ascii	"\012\015USBStpCB:SET_CUR:still = 0x%x.\000"
 1481      42537470 
 1481      43423A53 
 1481      45545F43 
 1481      55523A73 
 1482 026d 000000   		.align	2
 1483              	.LC16:
 1484 0270 0A0D2025 		.ascii	"\012\015 %d %d %d %d %d %d %d %d %d %d %d\015\012\000"
 1484      64202564 
 1484      20256420 
 1484      25642025 
 1484      64202564 
 1485 0296 0000     		.align	2
 1486              	.LC17:
 1487 0298 0A0D5553 		.ascii	"\012\015USBStpCB:control interface wIndex = 0x%x wV"
 1487      42537470 
 1487      43423A63 
 1487      6F6E7472 
 1487      6F6C2069 
 1488 02c5 616C7565 		.ascii	"alue = 0x%x bRequest = 0x%x\000"
 1488      203D2030 
 1488      78257820 
 1488      62526571 
 1488      75657374 
 1489              		.section	.text.esUVCUvcApplnUSBSetupCB,"ax",%progbits
 1490              		.align	2
 1492              	esUVCUvcApplnUSBSetupCB:
 1493              	.LFB10:
 672:../CX3RDKOV5640.c **** 
 673:../CX3RDKOV5640.c **** /* Callback to handle the USB Setup Requests and UVC Class events */
 674:../CX3RDKOV5640.c ****     static CyBool_t
 675:../CX3RDKOV5640.c **** esUVCUvcApplnUSBSetupCB (
 676:../CX3RDKOV5640.c ****         uint32_t setupdat0,     /* SETUP Data 0 */
 677:../CX3RDKOV5640.c ****         uint32_t setupdat1      /* SETUP Data 1 */
 678:../CX3RDKOV5640.c ****         )
 679:../CX3RDKOV5640.c **** {
 1494              		.loc 1 679 0
 1495              		.cfi_startproc
 1496              		@ args = 0, pretend = 0, frame = 32
 1497              		@ frame_needed = 1, uses_anonymous_args = 0
 1498 0000 F0492DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, fp, lr}
 1499              	.LCFI20:
 1500              		.cfi_def_cfa_offset 28
 1501              		.cfi_offset 4, -28
 1502              		.cfi_offset 5, -24
 1503              		.cfi_offset 6, -20
 1504              		.cfi_offset 7, -16
 1505              		.cfi_offset 8, -12
 1506              		.cfi_offset 11, -8
 1507              		.cfi_offset 14, -4
 1508 0004 18B08DE2 		add	fp, sp, #24
 1509              	.LCFI21:
 1510              		.cfi_def_cfa 11, 4
 1511 0008 4CD04DE2 		sub	sp, sp, #76
 1512 000c 38000BE5 		str	r0, [fp, #-56]
 1513 0010 3C100BE5 		str	r1, [fp, #-60]
 680:../CX3RDKOV5640.c ****     uint8_t  bRequest, bType,bRType, bTarget;
 681:../CX3RDKOV5640.c ****     uint16_t wValue, wIndex, wLength;
 682:../CX3RDKOV5640.c ****     uint16_t readCount = 0;
 1514              		.loc 1 682 0
 1515 0014 0030A0E3 		mov	r3, #0
 1516 0018 B2334BE1 		strh	r3, [fp, #-50]	@ movhi
 683:../CX3RDKOV5640.c ****     uint8_t  ep0Buf[2];
 684:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 1517              		.loc 1 684 0
 1518 001c 0030A0E3 		mov	r3, #0
 1519 0020 24300BE5 		str	r3, [fp, #-36]
 685:../CX3RDKOV5640.c ****     uint8_t temp = 0;
 1520              		.loc 1 685 0
 1521 0024 0030A0E3 		mov	r3, #0
 1522 0028 25304BE5 		strb	r3, [fp, #-37]
 686:../CX3RDKOV5640.c ****     CyBool_t isHandled = CyFalse;
 1523              		.loc 1 686 0
 1524 002c 0030A0E3 		mov	r3, #0
 1525 0030 20300BE5 		str	r3, [fp, #-32]
 687:../CX3RDKOV5640.c ****     uint8_t RequestOption = 0;
 1526              		.loc 1 687 0
 1527 0034 0030A0E3 		mov	r3, #0
 1528 0038 26304BE5 		strb	r3, [fp, #-38]
 688:../CX3RDKOV5640.c **** 
 689:../CX3RDKOV5640.c ****     /* Decode the fields from the setup request. */
 690:../CX3RDKOV5640.c ****     bRType = (setupdat0 & CY_U3P_USB_REQUEST_TYPE_MASK);
 1529              		.loc 1 690 0
 1530 003c 38301BE5 		ldr	r3, [fp, #-56]
 1531 0040 27304BE5 		strb	r3, [fp, #-39]
 691:../CX3RDKOV5640.c ****     bType    = (bRType & CY_U3P_USB_TYPE_MASK);
 1532              		.loc 1 691 0
 1533 0044 27305BE5 		ldrb	r3, [fp, #-39]
 1534 0048 603003E2 		and	r3, r3, #96
 1535 004c 28304BE5 		strb	r3, [fp, #-40]
 692:../CX3RDKOV5640.c ****     bTarget  = (bRType & CY_U3P_USB_TARGET_MASK);
 1536              		.loc 1 692 0
 1537 0050 27305BE5 		ldrb	r3, [fp, #-39]
 1538 0054 033003E2 		and	r3, r3, #3
 1539 0058 29304BE5 		strb	r3, [fp, #-41]
 693:../CX3RDKOV5640.c ****     bRequest = ((setupdat0 & CY_U3P_USB_REQUEST_MASK) >> CY_U3P_USB_REQUEST_POS);
 1540              		.loc 1 693 0
 1541 005c 38301BE5 		ldr	r3, [fp, #-56]
 1542 0060 FF3C03E2 		and	r3, r3, #65280
 1543 0064 2334A0E1 		mov	r3, r3, lsr #8
 1544 0068 2A304BE5 		strb	r3, [fp, #-42]
 694:../CX3RDKOV5640.c ****     wValue   = ((setupdat0 & CY_U3P_USB_VALUE_MASK)   >> CY_U3P_USB_VALUE_POS);
 1545              		.loc 1 694 0
 1546 006c 38301BE5 		ldr	r3, [fp, #-56]
 1547 0070 2338A0E1 		mov	r3, r3, lsr #16
 1548 0074 BC324BE1 		strh	r3, [fp, #-44]	@ movhi
 695:../CX3RDKOV5640.c ****     wIndex   = ((setupdat1 & CY_U3P_USB_INDEX_MASK)   >> CY_U3P_USB_INDEX_POS);
 1549              		.loc 1 695 0
 1550 0078 3C301BE5 		ldr	r3, [fp, #-60]
 1551 007c BE324BE1 		strh	r3, [fp, #-46]	@ movhi
 696:../CX3RDKOV5640.c ****     wLength  = ((setupdat1 & CY_U3P_USB_LENGTH_MASK)  >> CY_U3P_USB_LENGTH_POS);
 1552              		.loc 1 696 0
 1553 0080 3C301BE5 		ldr	r3, [fp, #-60]
 1554 0084 2338A0E1 		mov	r3, r3, lsr #16
 1555 0088 B0334BE1 		strh	r3, [fp, #-48]	@ movhi
 697:../CX3RDKOV5640.c **** 
 698:../CX3RDKOV5640.c **** #if 1
 699:../CX3RDKOV5640.c ****    	CyU3PDebugPrint(4, "\n\rbRType = 0x%x, bRequest = 0x%x, wValue = 0x%x, wIndex = 0x%x, wLength= 
 1556              		.loc 1 699 0
 1557 008c 27205BE5 		ldrb	r2, [fp, #-39]	@ zero_extendqisi2
 1558 0090 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1559 0094 BCC25BE1 		ldrh	ip, [fp, #-44]
 1560 0098 BE025BE1 		ldrh	r0, [fp, #-46]
 1561 009c B0135BE1 		ldrh	r1, [fp, #-48]
 1562 00a0 00C08DE5 		str	ip, [sp]
 1563 00a4 04008DE5 		str	r0, [sp, #4]
 1564 00a8 08108DE5 		str	r1, [sp, #8]
 1565 00ac 0400A0E3 		mov	r0, #4
 1566 00b0 70179FE5 		ldr	r1, .L132
 1567 00b4 FEFFFFEB 		bl	CyU3PDebugPrint
 700:../CX3RDKOV5640.c **** #endif
 701:../CX3RDKOV5640.c **** 
 702:../CX3RDKOV5640.c ****     /* ClearFeature(Endpoint_Halt) received on the Streaming Endpoint. Stop Streaming */
 703:../CX3RDKOV5640.c ****     if((bTarget == CY_U3P_USB_TARGET_ENDPT) && (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 1568              		.loc 1 703 0
 1569 00b8 29305BE5 		ldrb	r3, [fp, #-41]	@ zero_extendqisi2
 1570 00bc 020053E3 		cmp	r3, #2
 1571 00c0 1C00001A 		bne	.L77
 1572              		.loc 1 703 0 is_stmt 0 discriminator 1
 1573 00c4 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1574 00c8 010053E3 		cmp	r3, #1
 1575 00cc 1900001A 		bne	.L77
 704:../CX3RDKOV5640.c ****             && (wIndex == ES_UVC_EP_BULK_VIDEO) && (wValue == CY_U3P_USBX_FS_EP_HALT))
 1576              		.loc 1 704 0 is_stmt 1
 1577 00d0 BE325BE1 		ldrh	r3, [fp, #-46]
 1578 00d4 830053E3 		cmp	r3, #131
 1579 00d8 1600001A 		bne	.L77
 1580              		.loc 1 704 0 is_stmt 0 discriminator 1
 1581 00dc BC325BE1 		ldrh	r3, [fp, #-44]
 1582 00e0 000053E3 		cmp	r3, #0
 1583 00e4 1300001A 		bne	.L77
 705:../CX3RDKOV5640.c ****     {
 706:../CX3RDKOV5640.c ****         if ((glIsApplnActive) && (glIsStreamingStarted))
 1584              		.loc 1 706 0 is_stmt 1
 1585 00e8 3C379FE5 		ldr	r3, .L132+4
 1586 00ec 003093E5 		ldr	r3, [r3]
 1587 00f0 000053E3 		cmp	r3, #0
 1588 00f4 0D00000A 		beq	.L78
 1589              		.loc 1 706 0 is_stmt 0 discriminator 1
 1590 00f8 30379FE5 		ldr	r3, .L132+8
 1591 00fc 003093E5 		ldr	r3, [r3]
 1592 0100 000053E3 		cmp	r3, #0
 1593 0104 0900000A 		beq	.L78
 707:../CX3RDKOV5640.c ****         {
 708:../CX3RDKOV5640.c ****         	glPreviewStarted = CyFalse;
 1594              		.loc 1 708 0 is_stmt 1
 1595 0108 24379FE5 		ldr	r3, .L132+12
 1596 010c 0020A0E3 		mov	r2, #0
 1597 0110 002083E5 		str	r2, [r3]
 709:../CX3RDKOV5640.c ****             glIsClearFeature = CyTrue;
 1598              		.loc 1 709 0
 1599 0114 1C379FE5 		ldr	r3, .L132+16
 1600 0118 0120A0E3 		mov	r2, #1
 1601 011c 002083E5 		str	r2, [r3]
 710:../CX3RDKOV5640.c ****             esUVCUvcApplnStop();
 1602              		.loc 1 710 0
 1603 0120 FEFFFFEB 		bl	esUVCUvcApplnStop
 711:../CX3RDKOV5640.c ****             glcommitcount = 0;
 1604              		.loc 1 711 0
 1605 0124 10379FE5 		ldr	r3, .L132+20
 1606 0128 0020A0E3 		mov	r2, #0
 1607 012c 0020C3E5 		strb	r2, [r3]
 1608              	.L78:
 712:../CX3RDKOV5640.c **** #ifdef VISDebug
 713:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rApplnUSBSetupCB: esUVCUvcApplnStop");
 714:../CX3RDKOV5640.c **** #endif
 715:../CX3RDKOV5640.c ****         }
 716:../CX3RDKOV5640.c ****         return CyFalse;
 1609              		.loc 1 716 0
 1610 0130 0030A0E3 		mov	r3, #0
 1611 0134 B80100EA 		b	.L130
 1612              	.L77:
 717:../CX3RDKOV5640.c ****     }
 718:../CX3RDKOV5640.c **** 
 719:../CX3RDKOV5640.c ****     if( bRType == CY_U3P_USB_GS_DEVICE)
 1613              		.loc 1 719 0
 1614 0138 27305BE5 		ldrb	r3, [fp, #-39]	@ zero_extendqisi2
 1615 013c 800053E3 		cmp	r3, #128
 1616 0140 0500001A 		bne	.L80
 720:../CX3RDKOV5640.c ****     {
 721:../CX3RDKOV5640.c ****         /* Make sure that we bring the link back to U0, so that the ERDY can be sent. */
 722:../CX3RDKOV5640.c ****         if (CyU3PUsbGetSpeed () == CY_U3P_SUPER_SPEED)
 1617              		.loc 1 722 0
 1618 0144 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1619 0148 0030A0E1 		mov	r3, r0
 1620 014c 030053E3 		cmp	r3, #3
 1621 0150 0100001A 		bne	.L80
 723:../CX3RDKOV5640.c ****             CyU3PUsbSetLinkPowerState (CyU3PUsbLPM_U0);
 1622              		.loc 1 723 0
 1623 0154 0000A0E3 		mov	r0, #0
 1624 0158 FEFFFFEB 		bl	CyU3PUsbSetLinkPowerState
 1625              	.L80:
 724:../CX3RDKOV5640.c ****     }
 725:../CX3RDKOV5640.c **** 
 726:../CX3RDKOV5640.c ****     if ((bTarget == CY_U3P_USB_TARGET_INTF) && ((bRequest == CY_U3P_USB_SC_SET_FEATURE)
 1626              		.loc 1 726 0
 1627 015c 29305BE5 		ldrb	r3, [fp, #-41]	@ zero_extendqisi2
 1628 0160 010053E3 		cmp	r3, #1
 1629 0164 1400001A 		bne	.L81
 1630              		.loc 1 726 0 is_stmt 0 discriminator 1
 1631 0168 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1632 016c 030053E3 		cmp	r3, #3
 1633 0170 0200000A 		beq	.L82
 727:../CX3RDKOV5640.c ****                 || (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)) && (wValue == 0))
 1634              		.loc 1 727 0 is_stmt 1
 1635 0174 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1636 0178 010053E3 		cmp	r3, #1
 1637 017c 0E00001A 		bne	.L81
 1638              	.L82:
 1639              		.loc 1 727 0 is_stmt 0 discriminator 1
 1640 0180 BC325BE1 		ldrh	r3, [fp, #-44]
 1641 0184 000053E3 		cmp	r3, #0
 1642 0188 0B00001A 		bne	.L81
 728:../CX3RDKOV5640.c ****     {
 729:../CX3RDKOV5640.c ****         if (glIsConfigured)
 1643              		.loc 1 729 0 is_stmt 1
 1644 018c AC369FE5 		ldr	r3, .L132+24
 1645 0190 003093E5 		ldr	r3, [r3]
 1646 0194 000053E3 		cmp	r3, #0
 1647 0198 0100000A 		beq	.L83
 730:../CX3RDKOV5640.c ****         {
 731:../CX3RDKOV5640.c ****             CyU3PUsbAckSetup ();
 1648              		.loc 1 731 0
 1649 019c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1650 01a0 030000EA 		b	.L84
 1651              	.L83:
 732:../CX3RDKOV5640.c ****         }
 733:../CX3RDKOV5640.c ****         else
 734:../CX3RDKOV5640.c ****         {
 735:../CX3RDKOV5640.c ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 1652              		.loc 1 735 0
 1653 01a4 0000A0E3 		mov	r0, #0
 1654 01a8 0110A0E3 		mov	r1, #1
 1655 01ac 0020A0E3 		mov	r2, #0
 1656 01b0 FEFFFFEB 		bl	CyU3PUsbStall
 1657              	.L84:
 736:../CX3RDKOV5640.c ****         }
 737:../CX3RDKOV5640.c ****         return CyTrue;
 1658              		.loc 1 737 0
 1659 01b4 0130A0E3 		mov	r3, #1
 1660 01b8 970100EA 		b	.L130
 1661              	.L81:
 738:../CX3RDKOV5640.c ****     }
 739:../CX3RDKOV5640.c **** 
 740:../CX3RDKOV5640.c ****     if ((bRequest == CY_U3P_USB_SC_GET_STATUS) &&
 1662              		.loc 1 740 0
 1663 01bc 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1664 01c0 000053E3 		cmp	r3, #0
 1665 01c4 1400001A 		bne	.L85
 1666              		.loc 1 740 0 is_stmt 0 discriminator 1
 1667 01c8 29305BE5 		ldrb	r3, [fp, #-41]	@ zero_extendqisi2
 1668 01cc 010053E3 		cmp	r3, #1
 1669 01d0 1100001A 		bne	.L85
 741:../CX3RDKOV5640.c ****             (bTarget == CY_U3P_USB_TARGET_INTF))
 742:../CX3RDKOV5640.c ****     {
 743:../CX3RDKOV5640.c ****         /* We support only interface 0. */
 744:../CX3RDKOV5640.c ****         if (wIndex == 0)
 1670              		.loc 1 744 0 is_stmt 1
 1671 01d4 BE325BE1 		ldrh	r3, [fp, #-46]
 1672 01d8 000053E3 		cmp	r3, #0
 1673 01dc 0800001A 		bne	.L86
 745:../CX3RDKOV5640.c ****         {
 746:../CX3RDKOV5640.c ****             ep0Buf[0] = 0;
 1674              		.loc 1 746 0
 1675 01e0 0030A0E3 		mov	r3, #0
 1676 01e4 34304BE5 		strb	r3, [fp, #-52]
 747:../CX3RDKOV5640.c ****             ep0Buf[1] = 0;
 1677              		.loc 1 747 0
 1678 01e8 0030A0E3 		mov	r3, #0
 1679 01ec 33304BE5 		strb	r3, [fp, #-51]
 748:../CX3RDKOV5640.c ****             CyU3PUsbSendEP0Data (0x02, ep0Buf);
 1680              		.loc 1 748 0
 1681 01f0 34304BE2 		sub	r3, fp, #52
 1682 01f4 0200A0E3 		mov	r0, #2
 1683 01f8 0310A0E1 		mov	r1, r3
 1684 01fc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1685 0200 030000EA 		b	.L87
 1686              	.L86:
 749:../CX3RDKOV5640.c ****         }
 750:../CX3RDKOV5640.c ****         else
 751:../CX3RDKOV5640.c ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 1687              		.loc 1 751 0
 1688 0204 0000A0E3 		mov	r0, #0
 1689 0208 0110A0E3 		mov	r1, #1
 1690 020c 0020A0E3 		mov	r2, #0
 1691 0210 FEFFFFEB 		bl	CyU3PUsbStall
 1692              	.L87:
 752:../CX3RDKOV5640.c ****         return CyTrue;
 1693              		.loc 1 752 0
 1694 0214 0130A0E3 		mov	r3, #1
 1695 0218 7F0100EA 		b	.L130
 1696              	.L85:
 753:../CX3RDKOV5640.c ****     }
 754:../CX3RDKOV5640.c **** 
 755:../CX3RDKOV5640.c ****     /* Check for UVC Class Requests */
 756:../CX3RDKOV5640.c ****     if (bType == CY_U3P_USB_CLASS_RQT)
 1697              		.loc 1 756 0
 1698 021c 28305BE5 		ldrb	r3, [fp, #-40]	@ zero_extendqisi2
 1699 0220 200053E3 		cmp	r3, #32
 1700 0224 7B01001A 		bne	.L88
 757:../CX3RDKOV5640.c ****     {
 758:../CX3RDKOV5640.c **** 
 759:../CX3RDKOV5640.c ****         /* UVC Class Requests */
 760:../CX3RDKOV5640.c ****         /* Requests to the Video Streaming Interface (IF 1) */
 761:../CX3RDKOV5640.c ****         if((wIndex & 0x00FF) == ES_UVC_STREAM_INTERFACE)
 1701              		.loc 1 761 0
 1702 0228 BE325BE1 		ldrh	r3, [fp, #-46]
 1703 022c FF3003E2 		and	r3, r3, #255
 1704 0230 010053E3 		cmp	r3, #1
 1705 0234 5001001A 		bne	.L89
 762:../CX3RDKOV5640.c ****         {
 763:../CX3RDKOV5640.c ****             /* GET_CUR Request Handling Probe/Commit Controls*/
 764:../CX3RDKOV5640.c ****             if ((bRequest == ES_UVC_USB_GET_CUR_REQ)||(bRequest == ES_UVC_USB_GET_MIN_REQ) || (bReq
 1706              		.loc 1 764 0
 1707 0238 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1708 023c 810053E3 		cmp	r3, #129
 1709 0240 0800000A 		beq	.L90
 1710              		.loc 1 764 0 is_stmt 0 discriminator 1
 1711 0244 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1712 0248 820053E3 		cmp	r3, #130
 1713 024c 0500000A 		beq	.L90
 1714 0250 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1715 0254 830053E3 		cmp	r3, #131
 1716 0258 0200000A 		beq	.L90
 1717 025c 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1718 0260 870053E3 		cmp	r3, #135
 1719 0264 5F00001A 		bne	.L91
 1720              	.L90:
 765:../CX3RDKOV5640.c ****             {
 766:../CX3RDKOV5640.c ****                 isHandled = CyTrue;
 1721              		.loc 1 766 0 is_stmt 1
 1722 0268 0130A0E3 		mov	r3, #1
 1723 026c 20300BE5 		str	r3, [fp, #-32]
 767:../CX3RDKOV5640.c ****                 if((wValue == ES_UVC_VS_PROBE_CONTROL) || (wValue == ES_UVC_VS_COMMIT_CONTROL))
 1724              		.loc 1 767 0
 1725 0270 BC325BE1 		ldrh	r3, [fp, #-44]
 1726 0274 010C53E3 		cmp	r3, #256
 1727 0278 0200000A 		beq	.L92
 1728              		.loc 1 767 0 is_stmt 0 discriminator 1
 1729 027c BC325BE1 		ldrh	r3, [fp, #-44]
 1730 0280 020C53E3 		cmp	r3, #512
 1731 0284 4000001A 		bne	.L93
 1732              	.L92:
 768:../CX3RDKOV5640.c ****                 {
 769:../CX3RDKOV5640.c ****                 	//TODO Modify this "glProbeCtrl" according to the Supported Preview Resolutions th
 770:../CX3RDKOV5640.c **** 
 771:../CX3RDKOV5640.c **** 					/* Host requests for probe data of 34 bytes (UVC 1.1) or 26 Bytes (UVC1.0). Send it over EP0. 
 772:../CX3RDKOV5640.c **** 					if (CyU3PUsbGetSpeed () == CY_U3P_SUPER_SPEED)
 1733              		.loc 1 772 0 is_stmt 1
 1734 0288 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1735 028c 0030A0E1 		mov	r3, r0
 1736 0290 030053E3 		cmp	r3, #3
 1737 0294 2300001A 		bne	.L94
 773:../CX3RDKOV5640.c **** 					{
 774:../CX3RDKOV5640.c **** 						if(glCurrentFrameIndex == 4)
 1738              		.loc 1 774 0
 1739 0298 A4359FE5 		ldr	r3, .L132+28
 1740 029c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1741 02a0 040053E3 		cmp	r3, #4
 1742 02a4 0400001A 		bne	.L95
 775:../CX3RDKOV5640.c **** 						{
 776:../CX3RDKOV5640.c **** 							CyU3PMemCopy(glProbeCtrl, (uint8_t *)gl5MpProbeCtrl, ES_UVC_MAX_PROBE_SETTING);
 1743              		.loc 1 776 0
 1744 02a8 98059FE5 		ldr	r0, .L132+32
 1745 02ac 98159FE5 		ldr	r1, .L132+36
 1746 02b0 1A20A0E3 		mov	r2, #26
 1747 02b4 FEFFFFEB 		bl	CyU3PMemCopy
 1748 02b8 260000EA 		b	.L99
 1749              	.L95:
 777:../CX3RDKOV5640.c **** 						}
 778:../CX3RDKOV5640.c **** 						/* Probe Control for 1280x720 stream*/
 779:../CX3RDKOV5640.c **** 						else if(glCurrentFrameIndex == 3)
 1750              		.loc 1 779 0
 1751 02bc 80359FE5 		ldr	r3, .L132+28
 1752 02c0 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1753 02c4 030053E3 		cmp	r3, #3
 1754 02c8 0400001A 		bne	.L97
 780:../CX3RDKOV5640.c **** 						{
 781:../CX3RDKOV5640.c **** 							CyU3PMemCopy(glProbeCtrl, (uint8_t *)gl720pProbeCtrl, ES_UVC_MAX_PROBE_SETTING);
 1755              		.loc 1 781 0
 1756 02cc 74059FE5 		ldr	r0, .L132+32
 1757 02d0 78159FE5 		ldr	r1, .L132+40
 1758 02d4 1A20A0E3 		mov	r2, #26
 1759 02d8 FEFFFFEB 		bl	CyU3PMemCopy
 1760 02dc 1D0000EA 		b	.L99
 1761              	.L97:
 782:../CX3RDKOV5640.c **** 						}
 783:../CX3RDKOV5640.c **** 						/* Probe Control for 640x480 stream*/
 784:../CX3RDKOV5640.c **** 						else  if(glCurrentFrameIndex == 2)
 1762              		.loc 1 784 0
 1763 02e0 5C359FE5 		ldr	r3, .L132+28
 1764 02e4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1765 02e8 020053E3 		cmp	r3, #2
 1766 02ec 0400001A 		bne	.L98
 785:../CX3RDKOV5640.c **** 						{
 786:../CX3RDKOV5640.c **** 							CyU3PMemCopy(glProbeCtrl, (uint8_t *)glVga60ProbeCtrl, ES_UVC_MAX_PROBE_SETTING);
 1767              		.loc 1 786 0
 1768 02f0 50059FE5 		ldr	r0, .L132+32
 1769 02f4 58159FE5 		ldr	r1, .L132+44
 1770 02f8 1A20A0E3 		mov	r2, #26
 1771 02fc FEFFFFEB 		bl	CyU3PMemCopy
 1772 0300 140000EA 		b	.L99
 1773              	.L98:
 787:../CX3RDKOV5640.c **** 						}
 788:../CX3RDKOV5640.c **** 						/* Probe Control for 1920x1080 stream*/
 789:../CX3RDKOV5640.c **** 						else  if(glCurrentFrameIndex == 1)
 1774              		.loc 1 789 0
 1775 0304 38359FE5 		ldr	r3, .L132+28
 1776 0308 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1777 030c 010053E3 		cmp	r3, #1
 1778 0310 1000001A 		bne	.L99
 790:../CX3RDKOV5640.c **** 						{
 791:../CX3RDKOV5640.c **** 							CyU3PMemCopy(glProbeCtrl, (uint8_t *)gl1080pProbeCtrl, ES_UVC_MAX_PROBE_SETTING);
 1779              		.loc 1 791 0
 1780 0314 2C059FE5 		ldr	r0, .L132+32
 1781 0318 38159FE5 		ldr	r1, .L132+48
 1782 031c 1A20A0E3 		mov	r2, #26
 1783 0320 FEFFFFEB 		bl	CyU3PMemCopy
 1784 0324 0B0000EA 		b	.L99
 1785              	.L94:
 792:../CX3RDKOV5640.c **** 						}
 793:../CX3RDKOV5640.c **** 
 794:../CX3RDKOV5640.c **** 					}
 795:../CX3RDKOV5640.c **** 					else if (CyU3PUsbGetSpeed () == CY_U3P_HIGH_SPEED)
 1786              		.loc 1 795 0
 1787 0328 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1788 032c 0030A0E1 		mov	r3, r0
 1789 0330 020053E3 		cmp	r3, #2
 1790 0334 0400001A 		bne	.L100
 796:../CX3RDKOV5640.c **** 					{
 797:../CX3RDKOV5640.c **** 						/* Probe Control for 640x480 stream*/
 798:../CX3RDKOV5640.c **** 						CyU3PMemCopy(glProbeCtrl, (uint8_t *)glVga30ProbeCtrl, ES_UVC_MAX_PROBE_SETTING);
 1791              		.loc 1 798 0
 1792 0338 08059FE5 		ldr	r0, .L132+32
 1793 033c 18159FE5 		ldr	r1, .L132+52
 1794 0340 1A20A0E3 		mov	r2, #26
 1795 0344 FEFFFFEB 		bl	CyU3PMemCopy
 1796 0348 020000EA 		b	.L99
 1797              	.L100:
 799:../CX3RDKOV5640.c **** 					}
 800:../CX3RDKOV5640.c **** 					else /* FULL-Speed*/
 801:../CX3RDKOV5640.c **** 					{
 802:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rFull Speed Not Supported!");
 1798              		.loc 1 802 0
 1799 034c 0400A0E3 		mov	r0, #4
 1800 0350 08159FE5 		ldr	r1, .L132+56
 1801 0354 FEFFFFEB 		bl	CyU3PDebugPrint
 1802              	.L99:
 803:../CX3RDKOV5640.c **** 					}
 804:../CX3RDKOV5640.c **** 
 805:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(ES_UVC_MAX_PROBE_SETTING, glProbeCtrl);
 1803              		.loc 1 805 0
 1804 0358 1A00A0E3 		mov	r0, #26
 1805 035c E4149FE5 		ldr	r1, .L132+32
 1806 0360 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1807 0364 24000BE5 		str	r0, [fp, #-36]
 806:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 1808              		.loc 1 806 0
 1809 0368 24301BE5 		ldr	r3, [fp, #-36]
 1810 036c 000053E3 		cmp	r3, #0
 1811 0370 0400000A 		beq	.L101
 807:../CX3RDKOV5640.c **** 					{
 808:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:GET_CUR:SendEP0Data Err = 0x%x", status);
 1812              		.loc 1 808 0
 1813 0374 0400A0E3 		mov	r0, #4
 1814 0378 E4149FE5 		ldr	r1, .L132+60
 1815 037c 24201BE5 		ldr	r2, [fp, #-36]
 1816 0380 FEFFFFEB 		bl	CyU3PDebugPrint
 806:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 1817              		.loc 1 806 0
 1818 0384 160000EA 		b	.L102
 1819              	.L101:
 806:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 1820              		.loc 1 806 0 is_stmt 0 discriminator 1
 1821 0388 150000EA 		b	.L102
 1822              	.L93:
 809:../CX3RDKOV5640.c **** 					}
 810:../CX3RDKOV5640.c ****                 }
 811:../CX3RDKOV5640.c ****                 else if((wValue == ES_UVC_STILL_PROBE_CONTROL) || (wValue == ES_UVC_STILL_COMMIT_CO
 1823              		.loc 1 811 0 is_stmt 1
 1824 038c BC325BE1 		ldrh	r3, [fp, #-44]
 1825 0390 030C53E3 		cmp	r3, #768
 1826 0394 0200000A 		beq	.L103
 1827              		.loc 1 811 0 is_stmt 0 discriminator 1
 1828 0398 BC325BE1 		ldrh	r3, [fp, #-44]
 1829 039c 010B53E3 		cmp	r3, #1024
 1830 03a0 0F00001A 		bne	.L102
 1831              	.L103:
 812:../CX3RDKOV5640.c ****                 {
 813:../CX3RDKOV5640.c ****                 	if (CyU3PUsbGetSpeed () == CY_U3P_SUPER_SPEED)
 1832              		.loc 1 813 0 is_stmt 1
 1833 03a4 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1834 03a8 0030A0E1 		mov	r3, r0
 1835 03ac 030053E3 		cmp	r3, #3
 1836 03b0 0B00001A 		bne	.L102
 814:../CX3RDKOV5640.c ****                 	{
 815:../CX3RDKOV5640.c **** 						status = CyU3PUsbSendEP0Data(ES_UVC_MAX_STILL_PROBE_SETTING, glStillProbeCtrl);
 1837              		.loc 1 815 0
 1838 03b4 0B00A0E3 		mov	r0, #11
 1839 03b8 A8149FE5 		ldr	r1, .L132+64
 1840 03bc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1841 03c0 24000BE5 		str	r0, [fp, #-36]
 816:../CX3RDKOV5640.c **** 						if (status != CY_U3P_SUCCESS)
 1842              		.loc 1 816 0
 1843 03c4 24301BE5 		ldr	r3, [fp, #-36]
 1844 03c8 000053E3 		cmp	r3, #0
 1845 03cc 0400000A 		beq	.L102
 817:../CX3RDKOV5640.c **** 						{
 818:../CX3RDKOV5640.c **** 							CyU3PDebugPrint (4, "\n\rUSBStpCB:GET_CUR:SendEP0Data Err = 0x%x", status);
 1846              		.loc 1 818 0
 1847 03d0 0400A0E3 		mov	r0, #4
 1848 03d4 88149FE5 		ldr	r1, .L132+60
 1849 03d8 24201BE5 		ldr	r2, [fp, #-36]
 1850 03dc FEFFFFEB 		bl	CyU3PDebugPrint
 767:../CX3RDKOV5640.c ****                 {
 1851              		.loc 1 767 0
 1852 03e0 E40000EA 		b	.L104
 1853              	.L102:
 1854 03e4 E30000EA 		b	.L104
 1855              	.L91:
 819:../CX3RDKOV5640.c **** 						}
 820:../CX3RDKOV5640.c ****                 	}
 821:../CX3RDKOV5640.c ****                 }
 822:../CX3RDKOV5640.c ****             }
 823:../CX3RDKOV5640.c ****             /* SET_CUR request handling Probe/Commit controls */
 824:../CX3RDKOV5640.c ****             else if (bRequest == ES_UVC_USB_SET_CUR_REQ)
 1856              		.loc 1 824 0
 1857 03e8 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1858 03ec 010053E3 		cmp	r3, #1
 1859 03f0 DD00001A 		bne	.L105
 825:../CX3RDKOV5640.c ****             {
 826:../CX3RDKOV5640.c ****                 isHandled = CyTrue;
 1860              		.loc 1 826 0
 1861 03f4 0130A0E3 		mov	r3, #1
 1862 03f8 20300BE5 		str	r3, [fp, #-32]
 827:../CX3RDKOV5640.c ****                 if((wValue == ES_UVC_VS_PROBE_CONTROL) || (wValue == ES_UVC_VS_COMMIT_CONTROL))
 1863              		.loc 1 827 0
 1864 03fc BC325BE1 		ldrh	r3, [fp, #-44]
 1865 0400 010C53E3 		cmp	r3, #256
 1866 0404 0200000A 		beq	.L106
 1867              		.loc 1 827 0 is_stmt 0 discriminator 1
 1868 0408 BC325BE1 		ldrh	r3, [fp, #-44]
 1869 040c 020C53E3 		cmp	r3, #512
 1870 0410 5700001A 		bne	.L107
 1871              	.L106:
 828:../CX3RDKOV5640.c ****                 {
 829:../CX3RDKOV5640.c **** 					/* Get the UVC probe/commit control data from EP0 */
 830:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(ES_UVC_MAX_PROBE_SETTING_ALIGNED,
 1872              		.loc 1 830 0 is_stmt 1
 1873 0414 32304BE2 		sub	r3, fp, #50
 1874 0418 2000A0E3 		mov	r0, #32
 1875 041c 48149FE5 		ldr	r1, .L132+68
 1876 0420 0320A0E1 		mov	r2, r3
 1877 0424 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1878 0428 24000BE5 		str	r0, [fp, #-36]
 831:../CX3RDKOV5640.c **** 							glCommitCtrl, &readCount);
 832:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 1879              		.loc 1 832 0
 1880 042c 24301BE5 		ldr	r3, [fp, #-36]
 1881 0430 000053E3 		cmp	r3, #0
 1882 0434 0300000A 		beq	.L108
 833:../CX3RDKOV5640.c **** 					{
 834:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:SET_CUR:GetEP0Data Err = 0x%x.", status);
 1883              		.loc 1 834 0
 1884 0438 0400A0E3 		mov	r0, #4
 1885 043c 2C149FE5 		ldr	r1, .L132+72
 1886 0440 24201BE5 		ldr	r2, [fp, #-36]
 1887 0444 FEFFFFEB 		bl	CyU3PDebugPrint
 1888              	.L108:
 835:../CX3RDKOV5640.c **** 					}
 836:../CX3RDKOV5640.c **** 					/* Check the read count. Expecting a count of CX3_UVC_MAX_PROBE_SETTING bytes. */
 837:../CX3RDKOV5640.c **** 					if (readCount > (uint16_t)ES_UVC_MAX_PROBE_SETTING)
 1889              		.loc 1 837 0
 1890 0448 B2335BE1 		ldrh	r3, [fp, #-50]
 1891 044c 1A0053E3 		cmp	r3, #26
 1892 0450 0300009A 		bls	.L109
 838:../CX3RDKOV5640.c **** 					{
 839:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:Invalid SET_CUR Rqt Len.");
 1893              		.loc 1 839 0
 1894 0454 0400A0E3 		mov	r0, #4
 1895 0458 14149FE5 		ldr	r1, .L132+76
 1896 045c FEFFFFEB 		bl	CyU3PDebugPrint
 1897 0460 420000EA 		b	.L110
 1898              	.L109:
 840:../CX3RDKOV5640.c **** 					}
 841:../CX3RDKOV5640.c **** 					else
 842:../CX3RDKOV5640.c **** 					{
 843:../CX3RDKOV5640.c **** 						/* Set Probe Control */
 844:../CX3RDKOV5640.c **** 						if(wValue == ES_UVC_VS_PROBE_CONTROL)
 1899              		.loc 1 844 0
 1900 0464 BC325BE1 		ldrh	r3, [fp, #-44]
 1901 0468 010C53E3 		cmp	r3, #256
 1902 046c 0400001A 		bne	.L111
 845:../CX3RDKOV5640.c **** 						{
 846:../CX3RDKOV5640.c **** 							glCurrentFrameIndex = glCommitCtrl[3];
 1903              		.loc 1 846 0
 1904 0470 F4339FE5 		ldr	r3, .L132+68
 1905 0474 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 1906 0478 C4339FE5 		ldr	r3, .L132+28
 1907 047c 0020C3E5 		strb	r2, [r3]
 1908 0480 3A0000EA 		b	.L110
 1909              	.L111:
 847:../CX3RDKOV5640.c **** 						}
 848:../CX3RDKOV5640.c **** 						/* Set Commit Control and Start Streaming*/
 849:../CX3RDKOV5640.c **** 						else if(wValue == ES_UVC_VS_COMMIT_CONTROL)
 1910              		.loc 1 849 0
 1911 0484 BC325BE1 		ldrh	r3, [fp, #-44]
 1912 0488 020C53E3 		cmp	r3, #512
 1913 048c 3700001A 		bne	.L110
 850:../CX3RDKOV5640.c **** 						{
 851:../CX3RDKOV5640.c **** 
 852:../CX3RDKOV5640.c **** 							if((glcommitcount==0)||(glcheckframe!=glCommitCtrl[3]))
 1914              		.loc 1 852 0
 1915 0490 A4339FE5 		ldr	r3, .L132+20
 1916 0494 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1917 0498 000053E3 		cmp	r3, #0
 1918 049c 0500000A 		beq	.L112
 1919              		.loc 1 852 0 is_stmt 0 discriminator 1
 1920 04a0 C4339FE5 		ldr	r3, .L132+68
 1921 04a4 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 1922 04a8 C8339FE5 		ldr	r3, .L132+80
 1923 04ac 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1924 04b0 030052E1 		cmp	r2, r3
 1925 04b4 2900000A 		beq	.L113
 1926              	.L112:
 853:../CX3RDKOV5640.c **** 							{
 854:../CX3RDKOV5640.c **** 								glcommitcount++;
 1927              		.loc 1 854 0 is_stmt 1
 1928 04b8 7C339FE5 		ldr	r3, .L132+20
 1929 04bc 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1930 04c0 013083E2 		add	r3, r3, #1
 1931 04c4 FF2003E2 		and	r2, r3, #255
 1932 04c8 6C339FE5 		ldr	r3, .L132+20
 1933 04cc 0020C3E5 		strb	r2, [r3]
 855:../CX3RDKOV5640.c **** 								glcheckframe=glCommitCtrl[3];
 1934              		.loc 1 855 0
 1935 04d0 94339FE5 		ldr	r3, .L132+68
 1936 04d4 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 1937 04d8 98339FE5 		ldr	r3, .L132+80
 1938 04dc 0020C3E5 		strb	r2, [r3]
 856:../CX3RDKOV5640.c **** 							glCurrentFrameIndex = glCommitCtrl[3];
 1939              		.loc 1 856 0
 1940 04e0 84339FE5 		ldr	r3, .L132+68
 1941 04e4 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 1942 04e8 54339FE5 		ldr	r3, .L132+28
 1943 04ec 0020C3E5 		strb	r2, [r3]
 857:../CX3RDKOV5640.c **** 							glFrameIndexToSet = glCurrentFrameIndex;
 1944              		.loc 1 857 0
 1945 04f0 4C339FE5 		ldr	r3, .L132+28
 1946 04f4 0020D3E5 		ldrb	r2, [r3]	@ zero_extendqisi2
 1947 04f8 7C339FE5 		ldr	r3, .L132+84
 1948 04fc 0020C3E5 		strb	r2, [r3]
 858:../CX3RDKOV5640.c **** 							glPreviewStarted = CyTrue;
 1949              		.loc 1 858 0
 1950 0500 2C339FE5 		ldr	r3, .L132+12
 1951 0504 0120A0E3 		mov	r2, #1
 1952 0508 002083E5 		str	r2, [r3]
 859:../CX3RDKOV5640.c **** 
 860:../CX3RDKOV5640.c **** 							//TODO Change this function with "Sensor Specific" function to write the sensor settings & c
 861:../CX3RDKOV5640.c **** 						//	esSetCameraResolution(glCurrentFrameIndex);
 862:../CX3RDKOV5640.c **** 							esSetCameraResolution(glCommitCtrl[3]);
 1953              		.loc 1 862 0
 1954 050c 58339FE5 		ldr	r3, .L132+68
 1955 0510 0330D3E5 		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 1956 0514 0300A0E1 		mov	r0, r3
 1957 0518 FEFFFFEB 		bl	esSetCameraResolution
 863:../CX3RDKOV5640.c **** 
 864:../CX3RDKOV5640.c **** 							if (glIsApplnActive)
 1958              		.loc 1 864 0
 1959 051c 08339FE5 		ldr	r3, .L132+4
 1960 0520 003093E5 		ldr	r3, [r3]
 1961 0524 000053E3 		cmp	r3, #0
 1962 0528 0B00000A 		beq	.L114
 865:../CX3RDKOV5640.c **** 							{
 866:../CX3RDKOV5640.c **** 								if(glcommitcount)
 1963              		.loc 1 866 0
 1964 052c 08339FE5 		ldr	r3, .L132+20
 1965 0530 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1966 0534 000053E3 		cmp	r3, #0
 1967 0538 0300000A 		beq	.L115
 867:../CX3RDKOV5640.c **** 									glIsClearFeature = CyFalse;
 1968              		.loc 1 867 0
 1969 053c F4329FE5 		ldr	r3, .L132+16
 1970 0540 0020A0E3 		mov	r2, #0
 1971 0544 002083E5 		str	r2, [r3]
 1972 0548 020000EA 		b	.L116
 1973              	.L115:
 868:../CX3RDKOV5640.c **** 								else
 869:../CX3RDKOV5640.c **** 									glIsClearFeature = CyTrue;
 1974              		.loc 1 869 0
 1975 054c E4329FE5 		ldr	r3, .L132+16
 1976 0550 0120A0E3 		mov	r2, #1
 1977 0554 002083E5 		str	r2, [r3]
 1978              	.L116:
 870:../CX3RDKOV5640.c **** 
 871:../CX3RDKOV5640.c **** 								esUVCUvcApplnStop();
 1979              		.loc 1 871 0
 1980 0558 FEFFFFEB 		bl	esUVCUvcApplnStop
 1981              	.L114:
 872:../CX3RDKOV5640.c **** #ifdef VISDebug
 873:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rApplnUSBSetupCB:ES_UVC_VS_COMMIT_CONTROL esUVCUvcApplnStop");
 874:../CX3RDKOV5640.c **** #endif
 875:../CX3RDKOV5640.c **** 							}
 876:../CX3RDKOV5640.c **** 							esUVCUvcApplnStart();
 1982              		.loc 1 876 0
 1983 055c FEFFFFEB 		bl	esUVCUvcApplnStart
 1984              	.L113:
 877:../CX3RDKOV5640.c **** #ifdef VISDebug
 878:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rApplnUSBSetupCB:ES_UVC_VS_COMMIT_CONTROL esUVCUvcApplnStart");
 879:../CX3RDKOV5640.c **** #endif
 880:../CX3RDKOV5640.c **** 							}
 881:../CX3RDKOV5640.c **** 							//CyU3PThreadSleep(1000);
 882:../CX3RDKOV5640.c **** 							SensorGetControl(0x02, 0x30); //the start up mechanism is in the microcode.
 1985              		.loc 1 882 0
 1986 0560 0200A0E3 		mov	r0, #2
 1987 0564 3010A0E3 		mov	r1, #48
 1988 0568 FEFFFFEB 		bl	SensorGetControl
 837:../CX3RDKOV5640.c **** 					{
 1989              		.loc 1 837 0
 1990 056c 7D0000EA 		b	.L117
 1991              	.L110:
 1992 0570 7C0000EA 		b	.L117
 1993              	.L107:
 883:../CX3RDKOV5640.c **** 						}
 884:../CX3RDKOV5640.c **** 					}
 885:../CX3RDKOV5640.c ****                 }
 886:../CX3RDKOV5640.c ****                 else if((wValue == ES_UVC_STILL_PROBE_CONTROL) || (wValue == ES_UVC_STILL_COMMIT_CO
 1994              		.loc 1 886 0
 1995 0574 BC325BE1 		ldrh	r3, [fp, #-44]
 1996 0578 030C53E3 		cmp	r3, #768
 1997 057c 0200000A 		beq	.L118
 1998              		.loc 1 886 0 is_stmt 0 discriminator 1
 1999 0580 BC325BE1 		ldrh	r3, [fp, #-44]
 2000 0584 010B53E3 		cmp	r3, #1024
 2001 0588 5400001A 		bne	.L119
 2002              	.L118:
 887:../CX3RDKOV5640.c ****                 {
 888:../CX3RDKOV5640.c ****                 	/* Get the UVC STILL probe/commit control data from EP0 */
 889:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(ES_UVC_MAX_STILL_PROBE_SETTING_ALIGNED,glStillCommitCtrl, &readCou
 2003              		.loc 1 889 0 is_stmt 1
 2004 058c 32304BE2 		sub	r3, fp, #50
 2005 0590 2000A0E3 		mov	r0, #32
 2006 0594 E4129FE5 		ldr	r1, .L132+88
 2007 0598 0320A0E1 		mov	r2, r3
 2008 059c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2009 05a0 24000BE5 		str	r0, [fp, #-36]
 890:../CX3RDKOV5640.c **** 					CyU3PDebugPrint (4, "\n\rUSBStpCB:SET_CUR:still = 0x%x.", wValue);
 2010              		.loc 1 890 0
 2011 05a4 BC325BE1 		ldrh	r3, [fp, #-44]
 2012 05a8 0400A0E3 		mov	r0, #4
 2013 05ac D0129FE5 		ldr	r1, .L132+92
 2014 05b0 0320A0E1 		mov	r2, r3
 2015 05b4 FEFFFFEB 		bl	CyU3PDebugPrint
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 892:../CX3RDKOV5640.c ****                     		glStillCommitCtrl[0], glStillCommitCtrl[1],  glStillCommitCtrl[2], glStillCom
 2016              		.loc 1 892 0
 2017 05b8 C0329FE5 		ldr	r3, .L132+88
 2018 05bc 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2019              		.loc 1 891 0
 2020 05c0 0320A0E1 		mov	r2, r3
 2021              		.loc 1 892 0
 2022 05c4 B4329FE5 		ldr	r3, .L132+88
 2023 05c8 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2024 05cc AC129FE5 		ldr	r1, .L132+88
 2025 05d0 0210D1E5 		ldrb	r1, [r1, #2]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2026              		.loc 1 891 0
 2027 05d4 0180A0E1 		mov	r8, r1
 2028              		.loc 1 892 0
 2029 05d8 A0129FE5 		ldr	r1, .L132+88
 2030 05dc 0310D1E5 		ldrb	r1, [r1, #3]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2031              		.loc 1 891 0
 2032 05e0 0170A0E1 		mov	r7, r1
 893:../CX3RDKOV5640.c ****                     		glStillCommitCtrl[4], glStillCommitCtrl[5],  glStillCommitCtrl[6], glStillCom
 2033              		.loc 1 893 0
 2034 05e4 94129FE5 		ldr	r1, .L132+88
 2035 05e8 0410D1E5 		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2036              		.loc 1 891 0
 2037 05ec 0160A0E1 		mov	r6, r1
 2038              		.loc 1 893 0
 2039 05f0 88129FE5 		ldr	r1, .L132+88
 2040 05f4 0510D1E5 		ldrb	r1, [r1, #5]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2041              		.loc 1 891 0
 2042 05f8 0150A0E1 		mov	r5, r1
 2043              		.loc 1 893 0
 2044 05fc 7C129FE5 		ldr	r1, .L132+88
 2045 0600 0610D1E5 		ldrb	r1, [r1, #6]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2046              		.loc 1 891 0
 2047 0604 0140A0E1 		mov	r4, r1
 2048              		.loc 1 893 0
 2049 0608 70129FE5 		ldr	r1, .L132+88
 2050 060c 0710D1E5 		ldrb	r1, [r1, #7]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2051              		.loc 1 891 0
 2052 0610 01E0A0E1 		mov	lr, r1
 894:../CX3RDKOV5640.c ****                     		glStillCommitCtrl[8], glStillCommitCtrl[9], glStillCommitCtrl[10]);
 2053              		.loc 1 894 0
 2054 0614 64129FE5 		ldr	r1, .L132+88
 2055 0618 0810D1E5 		ldrb	r1, [r1, #8]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2056              		.loc 1 891 0
 2057 061c 01C0A0E1 		mov	ip, r1
 2058              		.loc 1 894 0
 2059 0620 58129FE5 		ldr	r1, .L132+88
 2060 0624 0910D1E5 		ldrb	r1, [r1, #9]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2061              		.loc 1 891 0
 2062 0628 0100A0E1 		mov	r0, r1
 2063              		.loc 1 894 0
 2064 062c 4C129FE5 		ldr	r1, .L132+88
 2065 0630 0A10D1E5 		ldrb	r1, [r1, #10]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2066              		.loc 1 891 0
 2067 0634 00808DE5 		str	r8, [sp]
 2068 0638 04708DE5 		str	r7, [sp, #4]
 2069 063c 08608DE5 		str	r6, [sp, #8]
 2070 0640 0C508DE5 		str	r5, [sp, #12]
 2071 0644 10408DE5 		str	r4, [sp, #16]
 2072 0648 14E08DE5 		str	lr, [sp, #20]
 2073 064c 18C08DE5 		str	ip, [sp, #24]
 2074 0650 1C008DE5 		str	r0, [sp, #28]
 2075 0654 20108DE5 		str	r1, [sp, #32]
 2076 0658 0400A0E3 		mov	r0, #4
 2077 065c 24129FE5 		ldr	r1, .L132+96
 2078 0660 FEFFFFEB 		bl	CyU3PDebugPrint
 895:../CX3RDKOV5640.c **** 
 896:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 2079              		.loc 1 896 0
 2080 0664 24301BE5 		ldr	r3, [fp, #-36]
 2081 0668 000053E3 		cmp	r3, #0
 2082 066c 0300000A 		beq	.L120
 897:../CX3RDKOV5640.c **** 					{
 898:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:SET_CUR:GetEP0Data Err = 0x%x.", status);
 2083              		.loc 1 898 0
 2084 0670 0400A0E3 		mov	r0, #4
 2085 0674 F4119FE5 		ldr	r1, .L132+72
 2086 0678 24201BE5 		ldr	r2, [fp, #-36]
 2087 067c FEFFFFEB 		bl	CyU3PDebugPrint
 2088              	.L120:
 899:../CX3RDKOV5640.c **** 					}
 900:../CX3RDKOV5640.c **** 					/* Check the read count. Expecting a count of CX3_UVC_MAX_PROBE_SETTING bytes. */
 901:../CX3RDKOV5640.c **** 					if (readCount > (uint16_t)ES_UVC_MAX_STILL_PROBE_SETTING)
 2089              		.loc 1 901 0
 2090 0680 B2335BE1 		ldrh	r3, [fp, #-50]
 2091 0684 0B0053E3 		cmp	r3, #11
 2092 0688 0300009A 		bls	.L121
 902:../CX3RDKOV5640.c **** 					{
 903:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:Invalid SET_CUR Rqt Len.");
 2093              		.loc 1 903 0
 2094 068c 0400A0E3 		mov	r0, #4
 2095 0690 DC119FE5 		ldr	r1, .L132+76
 2096 0694 FEFFFFEB 		bl	CyU3PDebugPrint
 2097 0698 0F0000EA 		b	.L122
 2098              	.L121:
 904:../CX3RDKOV5640.c **** 					}
 905:../CX3RDKOV5640.c **** 					else
 906:../CX3RDKOV5640.c **** 					{
 907:../CX3RDKOV5640.c **** 						/* Set Probe Control */
 908:../CX3RDKOV5640.c **** 						if(wValue == ES_UVC_STILL_PROBE_CONTROL)
 2099              		.loc 1 908 0
 2100 069c BC325BE1 		ldrh	r3, [fp, #-44]
 2101 06a0 030C53E3 		cmp	r3, #768
 2102 06a4 0400001A 		bne	.L123
 909:../CX3RDKOV5640.c **** 						{
 910:../CX3RDKOV5640.c **** 							glCurrentStillFrameIndex = glStillCommitCtrl[1];
 2103              		.loc 1 910 0
 2104 06a8 D0319FE5 		ldr	r3, .L132+88
 2105 06ac 0120D3E5 		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 2106 06b0 D4319FE5 		ldr	r3, .L132+100
 2107 06b4 0020C3E5 		strb	r2, [r3]
 2108 06b8 070000EA 		b	.L122
 2109              	.L123:
 911:../CX3RDKOV5640.c **** 						}
 912:../CX3RDKOV5640.c **** 						/* Set Commit Control and Start Streaming*/
 913:../CX3RDKOV5640.c **** 						else if(wValue == ES_UVC_STILL_COMMIT_CONTROL)
 2110              		.loc 1 913 0
 2111 06bc BC325BE1 		ldrh	r3, [fp, #-44]
 2112 06c0 010B53E3 		cmp	r3, #1024
 2113 06c4 0400001A 		bne	.L122
 914:../CX3RDKOV5640.c **** 						{
 915:../CX3RDKOV5640.c **** 							glCurrentStillFrameIndex = glStillCommitCtrl[1];
 2114              		.loc 1 915 0
 2115 06c8 B0319FE5 		ldr	r3, .L132+88
 2116 06cc 0120D3E5 		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 2117 06d0 B4319FE5 		ldr	r3, .L132+100
 2118 06d4 0020C3E5 		strb	r2, [r3]
 901:../CX3RDKOV5640.c **** 					{
 2119              		.loc 1 901 0
 2120 06d8 220000EA 		b	.L117
 2121              	.L122:
 2122 06dc 210000EA 		b	.L117
 2123              	.L119:
 916:../CX3RDKOV5640.c **** 						}
 917:../CX3RDKOV5640.c **** 					}
 918:../CX3RDKOV5640.c **** 
 919:../CX3RDKOV5640.c ****                 }
 920:../CX3RDKOV5640.c ****                 else if(wValue == ES_UVC_STILL_TRIGGER)
 2124              		.loc 1 920 0
 2125 06e0 BC325BE1 		ldrh	r3, [fp, #-44]
 2126 06e4 050C53E3 		cmp	r3, #1280
 2127 06e8 4A00001A 		bne	.L88
 921:../CX3RDKOV5640.c ****                 {
 922:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(ES_UVC_STILL_TRIGGER_ALIGNED,&glStillTriggerCtrl, &readCount);
 2128              		.loc 1 922 0
 2129 06ec 32304BE2 		sub	r3, fp, #50
 2130 06f0 1000A0E3 		mov	r0, #16
 2131 06f4 94119FE5 		ldr	r1, .L132+104
 2132 06f8 0320A0E1 		mov	r2, r3
 2133 06fc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2134 0700 24000BE5 		str	r0, [fp, #-36]
 923:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 2135              		.loc 1 923 0
 2136 0704 24301BE5 		ldr	r3, [fp, #-36]
 2137 0708 000053E3 		cmp	r3, #0
 2138 070c 0300000A 		beq	.L124
 924:../CX3RDKOV5640.c **** 					{
 925:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:SET_CUR:GetEP0Data Err = 0x%x.", status);
 2139              		.loc 1 925 0
 2140 0710 0400A0E3 		mov	r0, #4
 2141 0714 54119FE5 		ldr	r1, .L132+72
 2142 0718 24201BE5 		ldr	r2, [fp, #-36]
 2143 071c FEFFFFEB 		bl	CyU3PDebugPrint
 2144              	.L124:
 926:../CX3RDKOV5640.c **** 					}
 927:../CX3RDKOV5640.c **** 					/* Check the read count. Expecting a count of CX3_UVC_MAX_PROBE_SETTING bytes. */
 928:../CX3RDKOV5640.c **** 					if (readCount > (uint16_t)ES_UVC_STILL_TRIGGER_COUNT)
 2145              		.loc 1 928 0
 2146 0720 B2335BE1 		ldrh	r3, [fp, #-50]
 2147 0724 010053E3 		cmp	r3, #1
 2148 0728 0300009A 		bls	.L125
 929:../CX3RDKOV5640.c **** 					{
 930:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:Invalid SET_CUR Rqt Len.");
 2149              		.loc 1 930 0
 2150 072c 0400A0E3 		mov	r0, #4
 2151 0730 3C119FE5 		ldr	r1, .L132+76
 2152 0734 FEFFFFEB 		bl	CyU3PDebugPrint
 2153 0738 360000EA 		b	.L88
 2154              	.L125:
 931:../CX3RDKOV5640.c **** 					}
 932:../CX3RDKOV5640.c **** 					else
 933:../CX3RDKOV5640.c **** 					{
 934:../CX3RDKOV5640.c **** 						if(glStillTriggerCtrl == 0x01)
 2155              		.loc 1 934 0
 2156 073c 4C319FE5 		ldr	r3, .L132+104
 2157 0740 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2158 0744 010053E3 		cmp	r3, #1
 2159 0748 3200001A 		bne	.L88
 935:../CX3RDKOV5640.c **** 						{
 936:../CX3RDKOV5640.c **** 							glStillSkip = 3; //for still test 0;//
 2160              		.loc 1 936 0
 2161 074c 40319FE5 		ldr	r3, .L132+108
 2162 0750 0320A0E3 		mov	r2, #3
 2163 0754 0020C3E5 		strb	r2, [r3]
 937:../CX3RDKOV5640.c **** 							glStillCaptureStart = CyTrue;
 2164              		.loc 1 937 0
 2165 0758 38319FE5 		ldr	r3, .L132+112
 2166 075c 0120A0E3 		mov	r2, #1
 2167 0760 002083E5 		str	r2, [r3]
 2168 0764 2B0000EA 		b	.L88
 2169              	.L117:
 2170 0768 2A0000EA 		b	.L88
 2171              	.L105:
 938:../CX3RDKOV5640.c **** 						}
 939:../CX3RDKOV5640.c **** 					}
 940:../CX3RDKOV5640.c ****                 }
 941:../CX3RDKOV5640.c ****             }
 942:../CX3RDKOV5640.c ****             else
 943:../CX3RDKOV5640.c ****             {
 944:../CX3RDKOV5640.c ****                 /* Mark with error. */
 945:../CX3RDKOV5640.c ****                 status = CY_U3P_ERROR_FAILURE;
 2172              		.loc 1 945 0
 2173 076c 4A30A0E3 		mov	r3, #74
 2174 0770 24300BE5 		str	r3, [fp, #-36]
 2175 0774 270000EA 		b	.L88
 2176              	.L104:
 2177 0778 260000EA 		b	.L88
 2178              	.L89:
 946:../CX3RDKOV5640.c ****             }
 947:../CX3RDKOV5640.c ****         }
 948:../CX3RDKOV5640.c ****         else if((wIndex & 0x00FF) == ES_UVC_CONTROL_INTERFACE) /* Video Control Interface */
 2179              		.loc 1 948 0
 2180 077c BE325BE1 		ldrh	r3, [fp, #-46]
 2181 0780 FF3003E2 		and	r3, r3, #255
 2182 0784 000053E3 		cmp	r3, #0
 2183 0788 2200001A 		bne	.L88
 949:../CX3RDKOV5640.c ****         {
 950:../CX3RDKOV5640.c ****             isHandled = CyTrue;
 2184              		.loc 1 950 0
 2185 078c 0130A0E3 		mov	r3, #1
 2186 0790 20300BE5 		str	r3, [fp, #-32]
 951:../CX3RDKOV5640.c ****             /* Respond to VC_REQUEST_ERROR_CODE_CONTROL and stall every other request as this examp
 952:../CX3RDKOV5640.c ****                any of the Video Control features */
 953:../CX3RDKOV5640.c **** #if 0 /* the two controls handler test */
 954:../CX3RDKOV5640.c ****             if((wIndex == 0x200) && (wValue == 0x200))/*Brightness*/
 955:../CX3RDKOV5640.c ****             {
 956:../CX3RDKOV5640.c ****             	switch(bRequest)
 957:../CX3RDKOV5640.c ****             	{
 958:../CX3RDKOV5640.c ****             	case ES_UVC_USB_GET_INFO_REQ:
 959:../CX3RDKOV5640.c ****             		glGet_Info=0x03;
 960:../CX3RDKOV5640.c ****             		status = CyU3PUsbSendEP0Data(1,&glGet_Info);
 961:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 962:../CX3RDKOV5640.c **** 					{
 963:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
 964:../CX3RDKOV5640.c **** 					}
 965:../CX3RDKOV5640.c **** 					break;
 966:../CX3RDKOV5640.c ****             	case ES_UVC_USB_GET_MIN_REQ:
 967:../CX3RDKOV5640.c **** 					glGet_Info=0x00;
 968:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,&glGet_Info);
 969:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 970:../CX3RDKOV5640.c **** 					{
 971:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
 972:../CX3RDKOV5640.c **** 					}
 973:../CX3RDKOV5640.c **** 					break;
 974:../CX3RDKOV5640.c ****             	case ES_UVC_USB_GET_MAX_REQ:
 975:../CX3RDKOV5640.c **** 					glGet_Info=0xFF;
 976:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,&glGet_Info);
 977:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 978:../CX3RDKOV5640.c **** 					{
 979:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
 980:../CX3RDKOV5640.c **** 					}
 981:../CX3RDKOV5640.c **** 					break;
 982:../CX3RDKOV5640.c ****             	case ES_UVC_USB_GET_RES_REQ:
 983:../CX3RDKOV5640.c **** 					glGet_Info=0x01;
 984:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,&glGet_Info);
 985:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 986:../CX3RDKOV5640.c **** 					{
 987:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
 988:../CX3RDKOV5640.c **** 					}
 989:../CX3RDKOV5640.c **** 					break;
 990:../CX3RDKOV5640.c ****             	case ES_UVC_USB_GET_CUR_REQ:
 991:../CX3RDKOV5640.c ****             	case ES_UVC_USB_GET_DEF_REQ:
 992:../CX3RDKOV5640.c ****             		RequestOption = (bRequest & 0x0F);
 993:../CX3RDKOV5640.c **** 
 994:../CX3RDKOV5640.c ****             		//TODO Change this function with the "Sensor specific" function to Service all the GE
 995:../CX3RDKOV5640.c ****             		gl16GetControl = SensorGetControl(AExReferleveReg0, I2C_EAGLESDP_ADDR);//esOV5640_Get
 996:../CX3RDKOV5640.c ****             		status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
 997:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 998:../CX3RDKOV5640.c **** 					{
 999:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1000:../CX3RDKOV5640.c **** 					}
1001:../CX3RDKOV5640.c ****             		break;
1002:../CX3RDKOV5640.c ****             	case ES_UVC_USB_SET_CUR_REQ:
1003:../CX3RDKOV5640.c ****             		status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1004:../CX3RDKOV5640.c ****             		if (status != CY_U3P_SUCCESS)
1005:../CX3RDKOV5640.c **** 					{
1006:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1007:../CX3RDKOV5640.c **** 					}
1008:../CX3RDKOV5640.c ****             		//TODO Change this function with the "Sensor specific" function to Service the SET re
1009:../CX3RDKOV5640.c ****             		SensorSetControl(AExReferleveReg0, I2C_EAGLESDP_ADDR, (int8_t)gl16SetControl);//esOV5
1010:../CX3RDKOV5640.c **** 					break;
1011:../CX3RDKOV5640.c ****             	}
1012:../CX3RDKOV5640.c ****             }
1013:../CX3RDKOV5640.c ****             else if((wIndex == 0x100) && (wValue == 0x200))/*Auto Exposure*/
1014:../CX3RDKOV5640.c **** 			{
1015:../CX3RDKOV5640.c ****             //	CyU3PDebugPrint (4, "\n\rAuto Exposure");
1016:../CX3RDKOV5640.c **** 				switch(bRequest)
1017:../CX3RDKOV5640.c **** 				{
1018:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1019:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1020:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1021:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1022:../CX3RDKOV5640.c **** 					{
1023:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1024:../CX3RDKOV5640.c **** 					}
1025:../CX3RDKOV5640.c **** 					break;
1026:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1027:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1028:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1029:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1030:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1031:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1032:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1033:../CX3RDKOV5640.c **** 					gl8GetControl = SensorGetControl(AExModeReg, I2C_EAGLESDP_ADDR);//esOV5640_GetAutoExposure(Req
1034:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,(uint8_t*)&gl8GetControl);
1035:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1036:../CX3RDKOV5640.c **** 					{
1037:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1038:../CX3RDKOV5640.c **** 					}
1039:../CX3RDKOV5640.c **** 					break;
1040:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1041:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl8SetControl,&readCount);
1042:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1043:../CX3RDKOV5640.c **** 					{
1044:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1045:../CX3RDKOV5640.c **** 					}
1046:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1047:../CX3RDKOV5640.c **** 				//	CyU3PDebugPrint (4, "\n\rAuto Exposure= %d",gl8SetControl);
1048:../CX3RDKOV5640.c **** 					SensorSetControl(AExModeReg, I2C_EAGLESDP_ADDR, (int8_t)gl16SetControl);//esOV5640_SetAutoExpo
1049:../CX3RDKOV5640.c **** 					break;
1050:../CX3RDKOV5640.c **** 				}
1051:../CX3RDKOV5640.c **** 			}
1052:../CX3RDKOV5640.c ****             else if((wIndex == 0x300) && (wValue == 0x300))/*Mirror (Contrast)*/
1053:../CX3RDKOV5640.c ****             {
1054:../CX3RDKOV5640.c ****             	switch(bRequest)
1055:../CX3RDKOV5640.c **** 				{
1056:../CX3RDKOV5640.c ****             	case CY_FX_USB_UVC_GET_LEN_REQ:
1057:../CX3RDKOV5640.c **** 					glGet_Info=0x02;
1058:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2, &glGet_Info);
1059:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1060:../CX3RDKOV5640.c **** 					{
1061:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1062:../CX3RDKOV5640.c **** 					}
1063:../CX3RDKOV5640.c **** 					CyU3PDebugPrint (4, "\n\rUSB_Ext: Mirror SendEP0Data = %d data %d", status, glGet_Info);
1064:../CX3RDKOV5640.c **** 					break;
1065:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1066:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1067:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1068:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1069:../CX3RDKOV5640.c **** 					{
1070:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1071:../CX3RDKOV5640.c **** 					}
1072:../CX3RDKOV5640.c **** 					break;
1073:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1074:../CX3RDKOV5640.c **** 					glGet_Info=0x00;
1075:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,&glGet_Info);
1076:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1077:../CX3RDKOV5640.c **** 					{
1078:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1079:../CX3RDKOV5640.c **** 					}
1080:../CX3RDKOV5640.c **** 					break;
1081:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1082:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1083:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,&glGet_Info);
1084:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1085:../CX3RDKOV5640.c **** 					{
1086:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1087:../CX3RDKOV5640.c **** 					}
1088:../CX3RDKOV5640.c **** 					break;
1089:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1090:../CX3RDKOV5640.c **** 					glGet_Info=0x01;
1091:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,&glGet_Info);
1092:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1093:../CX3RDKOV5640.c **** 					{
1094:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1095:../CX3RDKOV5640.c **** 					}
1096:../CX3RDKOV5640.c **** 					break;
1097:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1098:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1099:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1100:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1101:../CX3RDKOV5640.c **** 					gl16GetControl = SensorGetControl(MirrModeReg, I2C_EAGLESDP_ADDR);//esOV5640_GetContrast(Reque
1102:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
1103:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1104:../CX3RDKOV5640.c **** 					{
1105:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1106:../CX3RDKOV5640.c **** 					}
1107:../CX3RDKOV5640.c **** 					break;
1108:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1109:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1110:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1111:../CX3RDKOV5640.c **** 					{
1112:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1113:../CX3RDKOV5640.c **** 					}
1114:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1115:../CX3RDKOV5640.c **** 					SensorSetControl(MirrModeReg, I2C_EAGLESDP_ADDR, (int8_t)gl16SetControl);//esOV5640_SetContras
1116:../CX3RDKOV5640.c **** 					break;
1117:../CX3RDKOV5640.c **** 				}
1118:../CX3RDKOV5640.c ****             }
1119:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x100) && (wValue == 0x400))/*Manual Exposure*/
1120:../CX3RDKOV5640.c **** 			{
1121:../CX3RDKOV5640.c ****             	//CyU3PDebugPrint (4, "\n\rManual Exposure ");
1122:../CX3RDKOV5640.c **** 				switch(bRequest)
1123:../CX3RDKOV5640.c **** 				{
1124:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1125:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1126:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1127:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1128:../CX3RDKOV5640.c **** 					{
1129:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1130:../CX3RDKOV5640.c **** 					}
1131:../CX3RDKOV5640.c **** 					break;
1132:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1133:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1134:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1135:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1136:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1137:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1138:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1139:../CX3RDKOV5640.c **** 					gl32GetControl = esOV5640_GetExposure(RequestOption);
1140:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(4,(uint8_t*)&gl32GetControl);
1141:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1142:../CX3RDKOV5640.c **** 					{
1143:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1144:../CX3RDKOV5640.c **** 					}
1145:../CX3RDKOV5640.c **** 					break;
1146:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1147:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl32SetControl,&readCount);
1148:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1149:../CX3RDKOV5640.c **** 					{
1150:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1151:../CX3RDKOV5640.c **** 					}
1152:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1153:../CX3RDKOV5640.c **** 				//	CyU3PDebugPrint (4, "\n\rManual Exposure = %d", gl32SetControl);
1154:../CX3RDKOV5640.c **** 					esOV5640_SetExposure(gl32SetControl);
1155:../CX3RDKOV5640.c **** 					break;
1156:../CX3RDKOV5640.c **** 				}
1157:../CX3RDKOV5640.c **** 			}
1158:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x200) && (wValue == 0x600))/*Hue*/
1159:../CX3RDKOV5640.c **** 			{
1160:../CX3RDKOV5640.c **** 				switch(bRequest)
1161:../CX3RDKOV5640.c **** 				{
1162:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1163:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1164:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1165:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1166:../CX3RDKOV5640.c **** 					{
1167:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1168:../CX3RDKOV5640.c **** 					}
1169:../CX3RDKOV5640.c **** 					break;
1170:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1171:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1172:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1173:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1174:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1175:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1176:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1177:../CX3RDKOV5640.c **** 					gl32GetControl = (int32_t)esOV5640_GetHue(RequestOption);
1178:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(4,(uint8_t*)&gl32GetControl);
1179:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1180:../CX3RDKOV5640.c **** 					{
1181:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1182:../CX3RDKOV5640.c **** 					}
1183:../CX3RDKOV5640.c **** 					break;
1184:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1185:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl32SetControl,&readCount);
1186:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1187:../CX3RDKOV5640.c **** 					{
1188:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1189:../CX3RDKOV5640.c **** 					}
1190:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1191:../CX3RDKOV5640.c **** 					esOV5640_SetHue((int8_t)gl32SetControl);
1192:../CX3RDKOV5640.c **** 					break;
1193:../CX3RDKOV5640.c **** 				}
1194:../CX3RDKOV5640.c **** 			}
1195:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x100) && (wValue == 0x600))/*Manual Focus*/
1196:../CX3RDKOV5640.c **** 			{
1197:../CX3RDKOV5640.c ****             	//CyU3PDebugPrint (4, "\n\rManual Focus ");
1198:../CX3RDKOV5640.c **** 				switch(bRequest)
1199:../CX3RDKOV5640.c **** 				{
1200:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1201:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1202:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1203:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1204:../CX3RDKOV5640.c **** 					{
1205:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1206:../CX3RDKOV5640.c **** 					}
1207:../CX3RDKOV5640.c **** 					break;
1208:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1209:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1210:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1211:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1212:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1213:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1214:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1215:../CX3RDKOV5640.c **** 					gl16GetControl = esOV5640_GetManualfocus(RequestOption);
1216:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
1217:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1218:../CX3RDKOV5640.c **** 					{
1219:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1220:../CX3RDKOV5640.c **** 					}
1221:../CX3RDKOV5640.c **** 					break;
1222:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1223:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1224:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1225:../CX3RDKOV5640.c **** 					{
1226:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1227:../CX3RDKOV5640.c **** 					}
1228:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1229:../CX3RDKOV5640.c **** 				//	CyU3PDebugPrint (4, "\n\rManual Focus= %d",gl16SetControl);
1230:../CX3RDKOV5640.c **** 					esOV5640_SetManualfocus((uint16_t)gl16SetControl);
1231:../CX3RDKOV5640.c **** 					g_IsAutoFocus = 0;
1232:../CX3RDKOV5640.c **** 					break;
1233:../CX3RDKOV5640.c **** 				}
1234:../CX3RDKOV5640.c **** 			}
1235:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x200) && (wValue == 0x700))/*Saturation*/
1236:../CX3RDKOV5640.c **** 			{
1237:../CX3RDKOV5640.c **** 				switch(bRequest)
1238:../CX3RDKOV5640.c **** 				{
1239:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1240:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1241:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1242:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1243:../CX3RDKOV5640.c **** 					{
1244:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1245:../CX3RDKOV5640.c **** 					}
1246:../CX3RDKOV5640.c **** 					break;
1247:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1248:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1249:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1250:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1251:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1252:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1253:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1254:../CX3RDKOV5640.c **** 					gl16GetControl = esOV5640_GetSaturation(RequestOption);
1255:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
1256:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1257:../CX3RDKOV5640.c **** 					{
1258:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1259:../CX3RDKOV5640.c **** 					}
1260:../CX3RDKOV5640.c **** 					break;
1261:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1262:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1263:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1264:../CX3RDKOV5640.c **** 					{
1265:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1266:../CX3RDKOV5640.c **** 					}
1267:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1268:../CX3RDKOV5640.c **** 					esOV5640_SetSaturation((uint32_t)gl16SetControl);
1269:../CX3RDKOV5640.c **** 					break;
1270:../CX3RDKOV5640.c **** 				}
1271:../CX3RDKOV5640.c **** 			}
1272:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x200) && (wValue == 0x800))/*Sharpness*/
1273:../CX3RDKOV5640.c **** 			{
1274:../CX3RDKOV5640.c **** 				switch(bRequest)
1275:../CX3RDKOV5640.c **** 				{
1276:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1277:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1278:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1279:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1280:../CX3RDKOV5640.c **** 					{
1281:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1282:../CX3RDKOV5640.c **** 					}
1283:../CX3RDKOV5640.c **** 					break;
1284:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1285:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1286:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1287:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1288:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1289:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1290:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1291:../CX3RDKOV5640.c **** 					gl16GetControl = esOV5640_GetSharpness(RequestOption);
1292:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
1293:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1294:../CX3RDKOV5640.c **** 					{
1295:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1296:../CX3RDKOV5640.c **** 					}
1297:../CX3RDKOV5640.c **** 					break;
1298:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1299:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1300:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1301:../CX3RDKOV5640.c **** 					{
1302:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1303:../CX3RDKOV5640.c **** 					}
1304:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1305:../CX3RDKOV5640.c **** 					esOV5640_SetSharpness((uint8_t)gl16SetControl);
1306:../CX3RDKOV5640.c **** 					break;
1307:../CX3RDKOV5640.c **** 				}
1308:../CX3RDKOV5640.c **** 			}
1309:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x100) && (wValue == 0x800))/*Auto Focus*/
1310:../CX3RDKOV5640.c **** 			{
1311:../CX3RDKOV5640.c ****             	CyU3PDebugPrint (4, "\n\rAuto Focus");
1312:../CX3RDKOV5640.c **** 				switch(bRequest)
1313:../CX3RDKOV5640.c **** 				{
1314:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1315:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1316:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1317:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1318:../CX3RDKOV5640.c **** 					{
1319:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1320:../CX3RDKOV5640.c **** 					}
1321:../CX3RDKOV5640.c **** 					break;
1322:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1323:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1324:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1325:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1326:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1327:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1328:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1329:../CX3RDKOV5640.c **** 					gl8GetControl = esOV5640_GetAutofocus(RequestOption);
1330:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl8GetControl);
1331:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1332:../CX3RDKOV5640.c **** 					{
1333:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1334:../CX3RDKOV5640.c **** 					}
1335:../CX3RDKOV5640.c **** 					break;
1336:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1337:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl8SetControl,&readCount);
1338:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1339:../CX3RDKOV5640.c **** 					{
1340:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1341:../CX3RDKOV5640.c **** 					}
1342:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1343:../CX3RDKOV5640.c **** 				//	CyU3PDebugPrint (4, "\n\rAuto Focus =%d",gl8SetControl);
1344:../CX3RDKOV5640.c **** 					esOV5640_SetAutofocus((uint8_t)gl8SetControl);
1345:../CX3RDKOV5640.c **** 					g_IsAutoFocus = 1;
1346:../CX3RDKOV5640.c **** 					break;
1347:../CX3RDKOV5640.c **** 				}
1348:../CX3RDKOV5640.c **** 			}
1349:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x200) && (wValue == 0xA00))/*White Balance manual*/
1350:../CX3RDKOV5640.c **** 			{
1351:../CX3RDKOV5640.c **** 				switch(bRequest)
1352:../CX3RDKOV5640.c **** 				{
1353:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1354:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1355:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1356:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1357:../CX3RDKOV5640.c **** 					{
1358:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1359:../CX3RDKOV5640.c **** 					}
1360:../CX3RDKOV5640.c **** 					break;
1361:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1362:../CX3RDKOV5640.c **** 					glGet_Info=0x00;
1363:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&glGet_Info);
1364:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1365:../CX3RDKOV5640.c **** 					{
1366:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1367:../CX3RDKOV5640.c **** 					}
1368:../CX3RDKOV5640.c **** 					break;
1369:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1370:../CX3RDKOV5640.c **** 					glGet_Info=0xFF;
1371:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&glGet_Info);
1372:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1373:../CX3RDKOV5640.c **** 					{
1374:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1375:../CX3RDKOV5640.c **** 					}
1376:../CX3RDKOV5640.c **** 					break;
1377:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1378:../CX3RDKOV5640.c **** 					glGet_Info=0x1;
1379:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&glGet_Info);
1380:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1381:../CX3RDKOV5640.c **** 					{
1382:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1383:../CX3RDKOV5640.c **** 					}
1384:../CX3RDKOV5640.c **** 					break;
1385:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1386:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1387:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1388:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1389:../CX3RDKOV5640.c **** 					gl16GetControl = esOV5640_GetWhiteBalance(RequestOption);
1390:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
1391:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1392:../CX3RDKOV5640.c **** 					{
1393:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1394:../CX3RDKOV5640.c **** 					}
1395:../CX3RDKOV5640.c **** 					break;
1396:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1397:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1398:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1399:../CX3RDKOV5640.c **** 					{
1400:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1401:../CX3RDKOV5640.c **** 					}
1402:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1403:../CX3RDKOV5640.c **** 					esOV5640_SetWhiteBalance((uint8_t)gl16SetControl);
1404:../CX3RDKOV5640.c **** 					break;
1405:../CX3RDKOV5640.c **** 				}
1406:../CX3RDKOV5640.c **** 			}
1407:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x200) && (wValue == 0xB00))/*White Balance Auto*/
1408:../CX3RDKOV5640.c **** 			{
1409:../CX3RDKOV5640.c **** 				switch(bRequest)
1410:../CX3RDKOV5640.c **** 				{
1411:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1412:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1413:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1414:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1415:../CX3RDKOV5640.c **** 					{
1416:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1417:../CX3RDKOV5640.c **** 					}
1418:../CX3RDKOV5640.c **** 					break;
1419:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1420:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1421:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1422:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1423:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1424:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1425:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1426:../CX3RDKOV5640.c **** 					gl16GetControl = esOV5640_GetAutoWhiteBalance(RequestOption);
1427:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
1428:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1429:../CX3RDKOV5640.c **** 					{
1430:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1431:../CX3RDKOV5640.c **** 					}
1432:../CX3RDKOV5640.c **** 					break;
1433:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1434:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1435:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1436:../CX3RDKOV5640.c **** 					{
1437:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1438:../CX3RDKOV5640.c **** 					}
1439:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1440:../CX3RDKOV5640.c **** 					esOV5640_SetAutoWhiteBalance((uint8_t)gl16SetControl);
1441:../CX3RDKOV5640.c **** 					break;
1442:../CX3RDKOV5640.c **** 				}
1443:../CX3RDKOV5640.c **** 			}
1444:../CX3RDKOV5640.c ****             else if((wValue == ES_UVC_VC_REQUEST_ERROR_CODE_CONTROL) && (wIndex == 0x00))
1445:../CX3RDKOV5640.c ****             {
1446:../CX3RDKOV5640.c ****                 temp = ES_UVC_ERROR_INVALID_CONTROL;
1447:../CX3RDKOV5640.c ****                 status = CyU3PUsbSendEP0Data(0x01, &temp);
1448:../CX3RDKOV5640.c ****                 if (status != CY_U3P_SUCCESS)
1449:../CX3RDKOV5640.c ****                 {
1450:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1451:../CX3RDKOV5640.c ****                 }
1452:../CX3RDKOV5640.c ****             }
1453:../CX3RDKOV5640.c ****             else
1454:../CX3RDKOV5640.c ****                 CyU3PUsbStall(0,CyTrue, CyTrue);
1455:../CX3RDKOV5640.c **** #else
1456:../CX3RDKOV5640.c ****             /* the new UVC control requests handler */
1457:../CX3RDKOV5640.c ****         	switch ((wIndex >> 8))
 2187              		.loc 1 1457 0
 2188 0794 BE325BE1 		ldrh	r3, [fp, #-46]
 2189 0798 2334A0E1 		mov	r3, r3, lsr #8
 2190 079c 0338A0E1 		mov	r3, r3, asl #16
 2191 07a0 2338A0E1 		mov	r3, r3, lsr #16
 2192 07a4 020053E3 		cmp	r3, #2
 2193 07a8 0200000A 		beq	.L127
 2194 07ac 030053E3 		cmp	r3, #3
 2195 07b0 0600000A 		beq	.L128
 2196 07b4 0B0000EA 		b	.L131
 2197              	.L127:
1458:../CX3RDKOV5640.c ****             {
1459:../CX3RDKOV5640.c **** 
1460:../CX3RDKOV5640.c ****                 case CY_FX_UVC_PROCESSING_UNIT_ID:
1461:../CX3RDKOV5640.c ****                     UVCHandleProcessingUnitRqts (wValue, bRequest);
 2198              		.loc 1 1461 0
 2199 07b8 BC225BE1 		ldrh	r2, [fp, #-44]
 2200 07bc 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 2201 07c0 0200A0E1 		mov	r0, r2
 2202 07c4 0310A0E1 		mov	r1, r3
 2203 07c8 FEFFFFEB 		bl	UVCHandleProcessingUnitRqts
1462:../CX3RDKOV5640.c ****                     break;
 2204              		.loc 1 1462 0
 2205 07cc 0A0000EA 		b	.L129
 2206              	.L128:
1463:../CX3RDKOV5640.c ****                 case CY_FX_UVC_EXTENSION_UNIT_ID:
1464:../CX3RDKOV5640.c ****                     UVCHandleExtensionUnitRqts (wValue, bRequest);
 2207              		.loc 1 1464 0
 2208 07d0 BC225BE1 		ldrh	r2, [fp, #-44]
 2209 07d4 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 2210 07d8 0200A0E1 		mov	r0, r2
 2211 07dc 0310A0E1 		mov	r1, r3
 2212 07e0 FEFFFFEB 		bl	UVCHandleExtensionUnitRqts
1465:../CX3RDKOV5640.c ****                     break;
 2213              		.loc 1 1465 0
 2214 07e4 040000EA 		b	.L129
 2215              	.L131:
1466:../CX3RDKOV5640.c ****                 case CY_FX_UVC_CAMERA_TERMINAL_ID:
1467:../CX3RDKOV5640.c ****                     //UVCHandleCameraTerminalRqts ();
1468:../CX3RDKOV5640.c ****                     //break;
1469:../CX3RDKOV5640.c ****                 case CY_FX_UVC_INTERFACE_CTRL:
1470:../CX3RDKOV5640.c ****                     //UVCHandleInterfaceCtrlRqts ();
1471:../CX3RDKOV5640.c ****                     //break;
1472:../CX3RDKOV5640.c **** 
1473:../CX3RDKOV5640.c ****                 default:
1474:../CX3RDKOV5640.c ****                     /* Unsupported request. Fail by stalling the control endpoint. */
1475:../CX3RDKOV5640.c ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
 2216              		.loc 1 1475 0
 2217 07e8 0000A0E3 		mov	r0, #0
 2218 07ec 0110A0E3 		mov	r1, #1
 2219 07f0 0020A0E3 		mov	r2, #0
 2220 07f4 FEFFFFEB 		bl	CyU3PUsbStall
1476:../CX3RDKOV5640.c ****                     break;
 2221              		.loc 1 1476 0
 2222 07f8 0000A0E1 		mov	r0, r0	@ nop
 2223              	.L129:
1477:../CX3RDKOV5640.c ****             }
1478:../CX3RDKOV5640.c ****         	CyU3PDebugPrint (4, "\n\rUSBStpCB:control interface wIndex = 0x%x wValue = 0x%x bRequest =
 2224              		.loc 1 1478 0
 2225 07fc BE225BE1 		ldrh	r2, [fp, #-46]
 2226 0800 BC325BE1 		ldrh	r3, [fp, #-44]
 2227 0804 2A105BE5 		ldrb	r1, [fp, #-42]	@ zero_extendqisi2
 2228 0808 00108DE5 		str	r1, [sp]
 2229 080c 0400A0E3 		mov	r0, #4
 2230 0810 84109FE5 		ldr	r1, .L132+116
 2231 0814 FEFFFFEB 		bl	CyU3PDebugPrint
 2232              	.L88:
1479:../CX3RDKOV5640.c ****         	/* the end of the controls handler */
1480:../CX3RDKOV5640.c **** #endif
1481:../CX3RDKOV5640.c ****         }
1482:../CX3RDKOV5640.c ****     }
1483:../CX3RDKOV5640.c ****     return isHandled;
 2233              		.loc 1 1483 0
 2234 0818 20301BE5 		ldr	r3, [fp, #-32]
 2235              	.L130:
1484:../CX3RDKOV5640.c **** }
 2236              		.loc 1 1484 0
 2237 081c 0300A0E1 		mov	r0, r3
 2238 0820 18D04BE2 		sub	sp, fp, #24
 2239              		@ sp needed
 2240 0824 F089BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, fp, pc}
 2241              	.L133:
 2242              		.align	2
 2243              	.L132:
 2244 0828 64010000 		.word	.LC10
 2245 082c 00000000 		.word	glIsApplnActive
 2246 0830 00000000 		.word	glIsStreamingStarted
 2247 0834 00000000 		.word	glPreviewStarted
 2248 0838 00000000 		.word	glIsClearFeature
 2249 083c 00000000 		.word	glcommitcount
 2250 0840 00000000 		.word	glIsConfigured
 2251 0844 00000000 		.word	glCurrentFrameIndex
 2252 0848 00000000 		.word	glProbeCtrl
 2253 084c 00000000 		.word	gl5MpProbeCtrl
 2254 0850 00000000 		.word	gl720pProbeCtrl
 2255 0854 00000000 		.word	glVga60ProbeCtrl
 2256 0858 00000000 		.word	gl1080pProbeCtrl
 2257 085c 00000000 		.word	glVga30ProbeCtrl
 2258 0860 B4010000 		.word	.LC11
 2259 0864 D0010000 		.word	.LC12
 2260 0868 00000000 		.word	glStillProbeCtrl
 2261 086c 00000000 		.word	glCommitCtrl
 2262 0870 FC010000 		.word	.LC13
 2263 0874 28020000 		.word	.LC14
 2264 0878 00000000 		.word	glcheckframe
 2265 087c 00000000 		.word	glFrameIndexToSet
 2266 0880 00000000 		.word	glStillCommitCtrl
 2267 0884 4C020000 		.word	.LC15
 2268 0888 70020000 		.word	.LC16
 2269 088c 00000000 		.word	glCurrentStillFrameIndex
 2270 0890 00000000 		.word	glStillTriggerCtrl
 2271 0894 00000000 		.word	glStillSkip
 2272 0898 00000000 		.word	glStillCaptureStart
 2273 089c 98020000 		.word	.LC17
 2274              		.cfi_endproc
 2275              	.LFE10:
 2277              		.section	.rodata
 2278 02e1 000000   		.align	2
 2279              	.LC18:
 2280 02e4 0A0D4170 		.ascii	"\012\015AppInit:I2CInit Err = 0x%x.\000"
 2280      70496E69 
 2280      743A4932 
 2280      43496E69 
 2280      74204572 
 2281 0302 0000     		.align	2
 2282              	.LC19:
 2283 0304 0A0D4170 		.ascii	"\012\015AppInit:GPIOInit Err = 0x%x\000"
 2283      70496E69 
 2283      743A4750 
 2283      494F496E 
 2283      69742045 
 2284 0322 0000     		.align	2
 2285              	.LC20:
 2286 0324 0A0D4170 		.ascii	"\012\015AppInit:PIBInit Err = 0x%x\000"
 2286      70496E69 
 2286      743A5049 
 2286      42496E69 
 2286      74204572 
 2287 0341 000000   		.align	2
 2288              	.LC21:
 2289 0344 0A0D4170 		.ascii	"\012\015AppInit:UsbStart Err = 0x%x\000"
 2289      70496E69 
 2289      743A5573 
 2289      62537461 
 2289      72742045 
 2290 0362 0000     		.align	2
 2291              	.LC22:
 2292 0364 0A0D4170 		.ascii	"\012\015AppInit:Set_SS_Device_Dscr Err = 0x%x\000"
 2292      70496E69 
 2292      743A5365 
 2292      745F5353 
 2292      5F446576 
 2293              		.align	2
 2294              	.LC23:
 2295 038c 0A0D4170 		.ascii	"\012\015AppInit:Set_HS_Device_Dscr Err = 0x%x\000"
 2295      70496E69 
 2295      743A5365 
 2295      745F4853 
 2295      5F446576 
 2296              		.align	2
 2297              	.LC24:
 2298 03b4 0A0D4170 		.ascii	"\012\015AppInit:Set_BOS_Dscr Err = 0x%x\000"
 2298      70496E69 
 2298      743A5365 
 2298      745F424F 
 2298      535F4473 
 2299 03d6 0000     		.align	2
 2300              	.LC25:
 2301 03d8 0A0D4170 		.ascii	"\012\015AppInit:Set_DEVQUAL_Dscr Err = 0x%x\000"
 2301      70496E69 
 2301      743A5365 
 2301      745F4445 
 2301      56515541 
 2302 03fe 0000     		.align	2
 2303              	.LC26:
 2304 0400 0A0D4170 		.ascii	"\012\015AppInit:Set_SS_CFG_Dscr Err = 0x%x\000"
 2304      70496E69 
 2304      743A5365 
 2304      745F5353 
 2304      5F434647 
 2305 0425 000000   		.align	2
 2306              	.LC27:
 2307 0428 0A0D4170 		.ascii	"\012\015AppInit:Set_HS_CFG_Dscr Err = 0x%x\000"
 2307      70496E69 
 2307      743A5365 
 2307      745F4853 
 2307      5F434647 
 2308 044d 000000   		.align	2
 2309              	.LC28:
 2310 0450 0A0D4170 		.ascii	"\012\015AppInit:Set_FS_CFG_Dscr Err = 0x%x\000"
 2310      70496E69 
 2310      743A5365 
 2310      745F4653 
 2310      5F434647 
 2311 0475 000000   		.align	2
 2312              	.LC29:
 2313 0478 0A0D4170 		.ascii	"\012\015AppInit:Set_STRNG_Dscr0 Err = 0x%x\000"
 2313      70496E69 
 2313      743A5365 
 2313      745F5354 
 2313      524E475F 
 2314 049d 000000   		.align	2
 2315              	.LC30:
 2316 04a0 0A0D4170 		.ascii	"\012\015AppInit:Set_STRNG_Dscr1 Err = 0x%x\000"
 2316      70496E69 
 2316      743A5365 
 2316      745F5354 
 2316      524E475F 
 2317 04c5 000000   		.align	2
 2318              	.LC31:
 2319 04c8 0A0D4170 		.ascii	"\012\015AppInit:Set_STRNG_Dscr2 Err = 0x%x\000"
 2319      70496E69 
 2319      743A5365 
 2319      745F5354 
 2319      524E475F 
 2320 04ed 000000   		.align	2
 2321              	.LC32:
 2322 04f0 0A0D4170 		.ascii	"\012\015AppInit:Set_STRNG_Dscr3 Err = 0x%x\000"
 2322      70496E69 
 2322      743A5365 
 2322      745F5354 
 2322      524E475F 
 2323 0515 000000   		.align	2
 2324              	.LC33:
 2325 0518 0A0D4170 		.ascii	"\012\015AppInit:Set_STRNG_Dscr4 Err = 0x%x\000"
 2325      70496E69 
 2325      743A5365 
 2325      745F5354 
 2325      524E475F 
 2326 053d 000000   		.align	2
 2327              	.LC34:
 2328 0540 0A0D4170 		.ascii	"\012\015AppInit:Set_STRNG_Dscr5 Err = 0x%x\000"
 2328      70496E69 
 2328      743A5365 
 2328      745F5354 
 2328      524E475F 
 2329 0565 000000   		.align	2
 2330              	.LC35:
 2331 0568 0A0D4170 		.ascii	"\012\015AppInit:ConnectState Err = 0x%x\000"
 2331      70496E69 
 2331      743A436F 
 2331      6E6E6563 
 2331      74537461 
 2332 058a 0000     		.align	2
 2333              	.LC36:
 2334 058c 0A0D4170 		.ascii	"\012\015AppInit:CyU3PSetEpConfig CtrlEp Err = 0x%x\000"
 2334      70496E69 
 2334      743A4379 
 2334      55335053 
 2334      65744570 
 2335 05b9 000000   		.align	2
 2336              	.LC37:
 2337 05bc 0A0D4170 		.ascii	"\012\015AppInit:CyU3PSetEpConfig BulkEp Err = 0x%x\000"
 2337      70496E69 
 2337      743A4379 
 2337      55335053 
 2337      65744570 
 2338 05e9 000000   		.align	2
 2339              	.LC38:
 2340 05ec 0A0D4170 		.ascii	"\012\015AppInit:DmaMultiChannelCreate Err = 0x%x\000"
 2340      70496E69 
 2340      743A446D 
 2340      614D756C 
 2340      74694368 
 2341 0617 00       		.align	2
 2342              	.LC39:
 2343 0618 0A0D4170 		.ascii	"\012\015AppInit:MultiChannelReset Err = 0x%x\000"
 2343      70496E69 
 2343      743A4D75 
 2343      6C746943 
 2343      68616E6E 
 2344 063f 00       		.align	2
 2345              	.LC40:
 2346 0640 0A0D4170 		.ascii	"\012\015AppInit:MipicsiGpifLoad Err = 0x%x\000"
 2346      70496E69 
 2346      743A4D69 
 2346      70696373 
 2346      69477069 
 2347 0665 000000   		.align	2
 2348              	.LC41:
 2349 0668 0A0D4170 		.ascii	"\012\015AppInit:GpifSMStart Err = 0x%x\000"
 2349      70496E69 
 2349      743A4770 
 2349      6966534D 
 2349      53746172 
 2350 0689 000000   		.align	2
 2351              	.LC42:
 2352 068c 0A0D4170 		.ascii	"\012\015AppInit:MipicsiInit Err = 0x%x\000"
 2352      70496E69 
 2352      743A4D69 
 2352      70696373 
 2352      69496E69 
 2353 06ad 000000   		.align	2
 2354              	.LC43:
 2355 06b0 0A0D4170 		.ascii	"\012\015AppInit:MipicsiSetIntfParams Err = 0x%x\000"
 2355      70496E69 
 2355      743A4D69 
 2355      70696373 
 2355      69536574 
 2356 06da 0000     		.align	2
 2357              	.LC44:
 2358 06dc 0A0D4669 		.ascii	"\012\015Firmware Version: %d.%d.%d.%d\000"
 2358      726D7761 
 2358      72652056 
 2358      65727369 
 2358      6F6E3A20 
 2359              		.section	.text.esUVCUvcApplnInit,"ax",%progbits
 2360              		.align	2
 2361              		.global	esUVCUvcApplnInit
 2363              	esUVCUvcApplnInit:
 2364              	.LFB11:
1485:../CX3RDKOV5640.c **** 
1486:../CX3RDKOV5640.c **** 
1487:../CX3RDKOV5640.c **** /* This function initializes the USB Module, creates event group,
1488:../CX3RDKOV5640.c ****    sets the enumeration descriptors, configures the Endpoints and
1489:../CX3RDKOV5640.c ****    configures the DMA module for the UVC Application */
1490:../CX3RDKOV5640.c ****     void
1491:../CX3RDKOV5640.c **** esUVCUvcApplnInit (void)
1492:../CX3RDKOV5640.c **** {
 2365              		.loc 1 1492 0
 2366              		.cfi_startproc
 2367              		@ args = 0, pretend = 0, frame = 56
 2368              		@ frame_needed = 1, uses_anonymous_args = 0
 2369 0000 00482DE9 		stmfd	sp!, {fp, lr}
 2370              	.LCFI22:
 2371              		.cfi_def_cfa_offset 8
 2372              		.cfi_offset 11, -8
 2373              		.cfi_offset 14, -4
 2374 0004 04B08DE2 		add	fp, sp, #4
 2375              	.LCFI23:
 2376              		.cfi_def_cfa 11, 4
 2377 0008 48D04DE2 		sub	sp, sp, #72
1493:../CX3RDKOV5640.c ****     CyU3PEpConfig_t endPointConfig;
1494:../CX3RDKOV5640.c ****     CyU3PDmaMultiChannelConfig_t dmaCfg;
1495:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 2378              		.loc 1 1495 0
 2379 000c 0030A0E3 		mov	r3, #0
 2380 0010 08300BE5 		str	r3, [fp, #-8]
1496:../CX3RDKOV5640.c **** 
1497:../CX3RDKOV5640.c ****     /* Initialize the I2C interface for Mipi Block Usage and Camera. */
1498:../CX3RDKOV5640.c ****     status = CyU3PMipicsiInitializeI2c (CY_U3P_MIPICSI_I2C_400KHZ);
 2381              		.loc 1 1498 0
 2382 0014 0100A0E3 		mov	r0, #1
 2383 0018 FEFFFFEB 		bl	CyU3PMipicsiInitializeI2c
 2384 001c 08000BE5 		str	r0, [fp, #-8]
1499:../CX3RDKOV5640.c ****     if( status != CY_U3P_SUCCESS)
 2385              		.loc 1 1499 0
 2386 0020 08301BE5 		ldr	r3, [fp, #-8]
 2387 0024 000053E3 		cmp	r3, #0
 2388 0028 0500000A 		beq	.L135
1500:../CX3RDKOV5640.c ****     {
1501:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:I2CInit Err = 0x%x.",status);
 2389              		.loc 1 1501 0
 2390 002c 0400A0E3 		mov	r0, #4
 2391 0030 70179FE5 		ldr	r1, .L166
 2392 0034 08201BE5 		ldr	r2, [fp, #-8]
 2393 0038 FEFFFFEB 		bl	CyU3PDebugPrint
1502:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2394              		.loc 1 1502 0
 2395 003c 08001BE5 		ldr	r0, [fp, #-8]
 2396 0040 FEFFFFEB 		bl	esUVCAppErrorHandler
 2397              	.L135:
1503:../CX3RDKOV5640.c ****     }
1504:../CX3RDKOV5640.c **** #ifdef VISDebug
1505:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:I2CInit");
1506:../CX3RDKOV5640.c **** #endif
1507:../CX3RDKOV5640.c ****     /* Initialize GPIO module. */
1508:../CX3RDKOV5640.c ****     status = CyU3PMipicsiInitializeGPIO ();
 2398              		.loc 1 1508 0
 2399 0044 FEFFFFEB 		bl	CyU3PMipicsiInitializeGPIO
 2400 0048 08000BE5 		str	r0, [fp, #-8]
1509:../CX3RDKOV5640.c ****     if( status != CY_U3P_SUCCESS)
 2401              		.loc 1 1509 0
 2402 004c 08301BE5 		ldr	r3, [fp, #-8]
 2403 0050 000053E3 		cmp	r3, #0
 2404 0054 0500000A 		beq	.L136
1510:../CX3RDKOV5640.c ****     {
1511:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:GPIOInit Err = 0x%x",status);
 2405              		.loc 1 1511 0
 2406 0058 0400A0E3 		mov	r0, #4
 2407 005c 48179FE5 		ldr	r1, .L166+4
 2408 0060 08201BE5 		ldr	r2, [fp, #-8]
 2409 0064 FEFFFFEB 		bl	CyU3PDebugPrint
1512:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2410              		.loc 1 1512 0
 2411 0068 08001BE5 		ldr	r0, [fp, #-8]
 2412 006c FEFFFFEB 		bl	esUVCAppErrorHandler
 2413              	.L136:
1513:../CX3RDKOV5640.c ****     }
1514:../CX3RDKOV5640.c **** #ifdef VISDebug
1515:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:GPIOInit");
1516:../CX3RDKOV5640.c **** #endif
1517:../CX3RDKOV5640.c ****     /* Initialize the PIB block */
1518:../CX3RDKOV5640.c ****     status = CyU3PMipicsiInitializePIB ();
 2414              		.loc 1 1518 0
 2415 0070 FEFFFFEB 		bl	CyU3PMipicsiInitializePIB
 2416 0074 08000BE5 		str	r0, [fp, #-8]
1519:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2417              		.loc 1 1519 0
 2418 0078 08301BE5 		ldr	r3, [fp, #-8]
 2419 007c 000053E3 		cmp	r3, #0
 2420 0080 0500000A 		beq	.L137
1520:../CX3RDKOV5640.c ****     {
1521:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:PIBInit Err = 0x%x",status);
 2421              		.loc 1 1521 0
 2422 0084 0400A0E3 		mov	r0, #4
 2423 0088 20179FE5 		ldr	r1, .L166+8
 2424 008c 08201BE5 		ldr	r2, [fp, #-8]
 2425 0090 FEFFFFEB 		bl	CyU3PDebugPrint
1522:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2426              		.loc 1 1522 0
 2427 0094 08001BE5 		ldr	r0, [fp, #-8]
 2428 0098 FEFFFFEB 		bl	esUVCAppErrorHandler
 2429              	.L137:
1523:../CX3RDKOV5640.c ****     }
1524:../CX3RDKOV5640.c **** #ifdef VISDebug
1525:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:PIBInit");
1526:../CX3RDKOV5640.c **** #endif
1527:../CX3RDKOV5640.c ****     /* Start the USB functionality */
1528:../CX3RDKOV5640.c ****     status = CyU3PUsbStart();
 2430              		.loc 1 1528 0
 2431 009c FEFFFFEB 		bl	CyU3PUsbStart
 2432 00a0 08000BE5 		str	r0, [fp, #-8]
1529:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2433              		.loc 1 1529 0
 2434 00a4 08301BE5 		ldr	r3, [fp, #-8]
 2435 00a8 000053E3 		cmp	r3, #0
 2436 00ac 0500000A 		beq	.L138
1530:../CX3RDKOV5640.c ****     {
1531:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:UsbStart Err = 0x%x",status);
 2437              		.loc 1 1531 0
 2438 00b0 0400A0E3 		mov	r0, #4
 2439 00b4 F8169FE5 		ldr	r1, .L166+12
 2440 00b8 08201BE5 		ldr	r2, [fp, #-8]
 2441 00bc FEFFFFEB 		bl	CyU3PDebugPrint
1532:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2442              		.loc 1 1532 0
 2443 00c0 08001BE5 		ldr	r0, [fp, #-8]
 2444 00c4 FEFFFFEB 		bl	esUVCAppErrorHandler
 2445              	.L138:
1533:../CX3RDKOV5640.c ****     }
1534:../CX3RDKOV5640.c **** #ifdef VISDebug
1535:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:UsbStart");
1536:../CX3RDKOV5640.c **** #endif
1537:../CX3RDKOV5640.c ****     /* The fast enumeration is the easiest way to setup a USB connection,
1538:../CX3RDKOV5640.c ****      * where all enumeration phase is handled by the library. Only the
1539:../CX3RDKOV5640.c ****      * class / vendor requests need to be handled by the application. */
1540:../CX3RDKOV5640.c ****     CyU3PUsbRegisterSetupCallback(esUVCUvcApplnUSBSetupCB, CyTrue);
 2446              		.loc 1 1540 0
 2447 00c8 E8069FE5 		ldr	r0, .L166+16
 2448 00cc 0110A0E3 		mov	r1, #1
 2449 00d0 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
1541:../CX3RDKOV5640.c **** 
1542:../CX3RDKOV5640.c ****     /* Setup the callback to handle the USB events */
1543:../CX3RDKOV5640.c ****     CyU3PUsbRegisterEventCallback(esUVCUvcApplnUSBEventCB);
 2450              		.loc 1 1543 0
 2451 00d4 E0069FE5 		ldr	r0, .L166+20
 2452 00d8 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
1544:../CX3RDKOV5640.c **** 
1545:../CX3RDKOV5640.c ****     /* Register a callback to handle LPM requests from the USB 3.0 host. */
1546:../CX3RDKOV5640.c ****     CyU3PUsbRegisterLPMRequestCallback (esUVCApplnLPMRqtCB);
 2453              		.loc 1 1546 0
 2454 00dc DC069FE5 		ldr	r0, .L166+24
 2455 00e0 FEFFFFEB 		bl	CyU3PUsbRegisterLPMRequestCallback
1547:../CX3RDKOV5640.c **** 
1548:../CX3RDKOV5640.c ****     /* Set the USB Enumeration descriptors */
1549:../CX3RDKOV5640.c **** 
1550:../CX3RDKOV5640.c ****     /* Super speed device descriptor. */
1551:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_DEVICE_DESCR, 0, (uint8_t *)esUVCUSB30DeviceDscr);
 2456              		.loc 1 1551 0
 2457 00e4 0000A0E3 		mov	r0, #0
 2458 00e8 0010A0E3 		mov	r1, #0
 2459 00ec D0269FE5 		ldr	r2, .L166+28
 2460 00f0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2461 00f4 08000BE5 		str	r0, [fp, #-8]
1552:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2462              		.loc 1 1552 0
 2463 00f8 08301BE5 		ldr	r3, [fp, #-8]
 2464 00fc 000053E3 		cmp	r3, #0
 2465 0100 0500000A 		beq	.L139
1553:../CX3RDKOV5640.c ****     {
1554:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_SS_Device_Dscr Err = 0x%x", status);
 2466              		.loc 1 1554 0
 2467 0104 0400A0E3 		mov	r0, #4
 2468 0108 B8169FE5 		ldr	r1, .L166+32
 2469 010c 08201BE5 		ldr	r2, [fp, #-8]
 2470 0110 FEFFFFEB 		bl	CyU3PDebugPrint
1555:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2471              		.loc 1 1555 0
 2472 0114 08001BE5 		ldr	r0, [fp, #-8]
 2473 0118 FEFFFFEB 		bl	esUVCAppErrorHandler
 2474              	.L139:
1556:../CX3RDKOV5640.c ****     }
1557:../CX3RDKOV5640.c **** #ifdef VISDebug
1558:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_SS_Device_Dscr");
1559:../CX3RDKOV5640.c **** #endif
1560:../CX3RDKOV5640.c ****     /* High speed device descriptor. */
1561:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_HS_DEVICE_DESCR, 0, (uint8_t *)esUVCUSB20DeviceDscr);
 2475              		.loc 1 1561 0
 2476 011c 0100A0E3 		mov	r0, #1
 2477 0120 0010A0E3 		mov	r1, #0
 2478 0124 A0269FE5 		ldr	r2, .L166+36
 2479 0128 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2480 012c 08000BE5 		str	r0, [fp, #-8]
1562:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2481              		.loc 1 1562 0
 2482 0130 08301BE5 		ldr	r3, [fp, #-8]
 2483 0134 000053E3 		cmp	r3, #0
 2484 0138 0500000A 		beq	.L140
1563:../CX3RDKOV5640.c ****     {
1564:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_HS_Device_Dscr Err = 0x%x", status);
 2485              		.loc 1 1564 0
 2486 013c 0400A0E3 		mov	r0, #4
 2487 0140 88169FE5 		ldr	r1, .L166+40
 2488 0144 08201BE5 		ldr	r2, [fp, #-8]
 2489 0148 FEFFFFEB 		bl	CyU3PDebugPrint
1565:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2490              		.loc 1 1565 0
 2491 014c 08001BE5 		ldr	r0, [fp, #-8]
 2492 0150 FEFFFFEB 		bl	esUVCAppErrorHandler
 2493              	.L140:
1566:../CX3RDKOV5640.c ****     }
1567:../CX3RDKOV5640.c **** #ifdef VISDebug
1568:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_HS_Device_Dscr");
1569:../CX3RDKOV5640.c **** #endif
1570:../CX3RDKOV5640.c ****     /* BOS descriptor */
1571:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_BOS_DESCR, 0, (uint8_t *)esUVCUSBBOSDscr);
 2494              		.loc 1 1571 0
 2495 0154 0700A0E3 		mov	r0, #7
 2496 0158 0010A0E3 		mov	r1, #0
 2497 015c 70269FE5 		ldr	r2, .L166+44
 2498 0160 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2499 0164 08000BE5 		str	r0, [fp, #-8]
1572:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2500              		.loc 1 1572 0
 2501 0168 08301BE5 		ldr	r3, [fp, #-8]
 2502 016c 000053E3 		cmp	r3, #0
 2503 0170 0500000A 		beq	.L141
1573:../CX3RDKOV5640.c ****     {
1574:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_BOS_Dscr Err = 0x%x", status);
 2504              		.loc 1 1574 0
 2505 0174 0400A0E3 		mov	r0, #4
 2506 0178 58169FE5 		ldr	r1, .L166+48
 2507 017c 08201BE5 		ldr	r2, [fp, #-8]
 2508 0180 FEFFFFEB 		bl	CyU3PDebugPrint
1575:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2509              		.loc 1 1575 0
 2510 0184 08001BE5 		ldr	r0, [fp, #-8]
 2511 0188 FEFFFFEB 		bl	esUVCAppErrorHandler
 2512              	.L141:
1576:../CX3RDKOV5640.c ****     }
1577:../CX3RDKOV5640.c **** #ifdef VISDebug
1578:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_BOS_Dscr");
1579:../CX3RDKOV5640.c **** #endif
1580:../CX3RDKOV5640.c ****     /* Device qualifier descriptor */
1581:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_DEVQUAL_DESCR, 0, (uint8_t *)esUVCUSBDeviceQualDscr);
 2513              		.loc 1 1581 0
 2514 018c 0200A0E3 		mov	r0, #2
 2515 0190 0010A0E3 		mov	r1, #0
 2516 0194 40269FE5 		ldr	r2, .L166+52
 2517 0198 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2518 019c 08000BE5 		str	r0, [fp, #-8]
1582:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2519              		.loc 1 1582 0
 2520 01a0 08301BE5 		ldr	r3, [fp, #-8]
 2521 01a4 000053E3 		cmp	r3, #0
 2522 01a8 0500000A 		beq	.L142
1583:../CX3RDKOV5640.c ****     {
1584:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_DEVQUAL_Dscr Err = 0x%x", status);
 2523              		.loc 1 1584 0
 2524 01ac 0400A0E3 		mov	r0, #4
 2525 01b0 28169FE5 		ldr	r1, .L166+56
 2526 01b4 08201BE5 		ldr	r2, [fp, #-8]
 2527 01b8 FEFFFFEB 		bl	CyU3PDebugPrint
1585:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2528              		.loc 1 1585 0
 2529 01bc 08001BE5 		ldr	r0, [fp, #-8]
 2530 01c0 FEFFFFEB 		bl	esUVCAppErrorHandler
 2531              	.L142:
1586:../CX3RDKOV5640.c ****     }
1587:../CX3RDKOV5640.c **** #ifdef VISDebug
1588:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_DEVQUAL_Dscr");
1589:../CX3RDKOV5640.c **** #endif
1590:../CX3RDKOV5640.c ****     /* Super speed configuration descriptor */
1591:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_CONFIG_DESCR, 0, (uint8_t *)esUVCUSBSSConfigDscr);
 2532              		.loc 1 1591 0
 2533 01c4 0600A0E3 		mov	r0, #6
 2534 01c8 0010A0E3 		mov	r1, #0
 2535 01cc 10269FE5 		ldr	r2, .L166+60
 2536 01d0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2537 01d4 08000BE5 		str	r0, [fp, #-8]
1592:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2538              		.loc 1 1592 0
 2539 01d8 08301BE5 		ldr	r3, [fp, #-8]
 2540 01dc 000053E3 		cmp	r3, #0
 2541 01e0 0500000A 		beq	.L143
1593:../CX3RDKOV5640.c ****     {
1594:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_SS_CFG_Dscr Err = 0x%x", status);
 2542              		.loc 1 1594 0
 2543 01e4 0400A0E3 		mov	r0, #4
 2544 01e8 F8159FE5 		ldr	r1, .L166+64
 2545 01ec 08201BE5 		ldr	r2, [fp, #-8]
 2546 01f0 FEFFFFEB 		bl	CyU3PDebugPrint
1595:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2547              		.loc 1 1595 0
 2548 01f4 08001BE5 		ldr	r0, [fp, #-8]
 2549 01f8 FEFFFFEB 		bl	esUVCAppErrorHandler
 2550              	.L143:
1596:../CX3RDKOV5640.c ****     }
1597:../CX3RDKOV5640.c **** #ifdef VISDebug
1598:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_SS_CFG_Dscr");
1599:../CX3RDKOV5640.c **** #endif
1600:../CX3RDKOV5640.c ****     /* High speed configuration descriptor */
1601:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_HS_CONFIG_DESCR, 0, (uint8_t *)esUVCUSBHSConfigDscr);
 2551              		.loc 1 1601 0
 2552 01fc 0400A0E3 		mov	r0, #4
 2553 0200 0010A0E3 		mov	r1, #0
 2554 0204 E0259FE5 		ldr	r2, .L166+68
 2555 0208 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2556 020c 08000BE5 		str	r0, [fp, #-8]
1602:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2557              		.loc 1 1602 0
 2558 0210 08301BE5 		ldr	r3, [fp, #-8]
 2559 0214 000053E3 		cmp	r3, #0
 2560 0218 0500000A 		beq	.L144
1603:../CX3RDKOV5640.c ****     {
1604:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_HS_CFG_Dscr Err = 0x%x", status);
 2561              		.loc 1 1604 0
 2562 021c 0400A0E3 		mov	r0, #4
 2563 0220 C8159FE5 		ldr	r1, .L166+72
 2564 0224 08201BE5 		ldr	r2, [fp, #-8]
 2565 0228 FEFFFFEB 		bl	CyU3PDebugPrint
1605:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2566              		.loc 1 1605 0
 2567 022c 08001BE5 		ldr	r0, [fp, #-8]
 2568 0230 FEFFFFEB 		bl	esUVCAppErrorHandler
 2569              	.L144:
1606:../CX3RDKOV5640.c ****     }
1607:../CX3RDKOV5640.c **** #ifdef VISDebug
1608:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_HS_CFG_Dscr");
1609:../CX3RDKOV5640.c **** #endif
1610:../CX3RDKOV5640.c ****     /* Full speed configuration descriptor */
1611:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_FS_CONFIG_DESCR, 0, (uint8_t *)esUVCUSBFSConfigDscr);
 2570              		.loc 1 1611 0
 2571 0234 0300A0E3 		mov	r0, #3
 2572 0238 0010A0E3 		mov	r1, #0
 2573 023c B0259FE5 		ldr	r2, .L166+76
 2574 0240 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2575 0244 08000BE5 		str	r0, [fp, #-8]
1612:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2576              		.loc 1 1612 0
 2577 0248 08301BE5 		ldr	r3, [fp, #-8]
 2578 024c 000053E3 		cmp	r3, #0
 2579 0250 0500000A 		beq	.L145
1613:../CX3RDKOV5640.c ****     {
1614:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_FS_CFG_Dscr Err = 0x%x", status);
 2580              		.loc 1 1614 0
 2581 0254 0400A0E3 		mov	r0, #4
 2582 0258 98159FE5 		ldr	r1, .L166+80
 2583 025c 08201BE5 		ldr	r2, [fp, #-8]
 2584 0260 FEFFFFEB 		bl	CyU3PDebugPrint
1615:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2585              		.loc 1 1615 0
 2586 0264 08001BE5 		ldr	r0, [fp, #-8]
 2587 0268 FEFFFFEB 		bl	esUVCAppErrorHandler
 2588              	.L145:
1616:../CX3RDKOV5640.c ****     }
1617:../CX3RDKOV5640.c **** #ifdef VISDebug
1618:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_FS_CFG_Dscr");
1619:../CX3RDKOV5640.c **** #endif
1620:../CX3RDKOV5640.c ****     /* String descriptor 0 */
1621:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)esUVCUSBStringLangIDDscr);
 2589              		.loc 1 1621 0
 2590 026c 0500A0E3 		mov	r0, #5
 2591 0270 0010A0E3 		mov	r1, #0
 2592 0274 80259FE5 		ldr	r2, .L166+84
 2593 0278 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2594 027c 08000BE5 		str	r0, [fp, #-8]
1622:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2595              		.loc 1 1622 0
 2596 0280 08301BE5 		ldr	r3, [fp, #-8]
 2597 0284 000053E3 		cmp	r3, #0
 2598 0288 0500000A 		beq	.L146
1623:../CX3RDKOV5640.c ****     {
1624:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_STRNG_Dscr0 Err = 0x%x", status);
 2599              		.loc 1 1624 0
 2600 028c 0400A0E3 		mov	r0, #4
 2601 0290 68159FE5 		ldr	r1, .L166+88
 2602 0294 08201BE5 		ldr	r2, [fp, #-8]
 2603 0298 FEFFFFEB 		bl	CyU3PDebugPrint
1625:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2604              		.loc 1 1625 0
 2605 029c 08001BE5 		ldr	r0, [fp, #-8]
 2606 02a0 FEFFFFEB 		bl	esUVCAppErrorHandler
 2607              	.L146:
1626:../CX3RDKOV5640.c ****     }
1627:../CX3RDKOV5640.c **** 
1628:../CX3RDKOV5640.c ****     /* String descriptor 1 */
1629:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)esUVCUSBManufactureDscr);
 2608              		.loc 1 1629 0
 2609 02a4 0500A0E3 		mov	r0, #5
 2610 02a8 0110A0E3 		mov	r1, #1
 2611 02ac 50259FE5 		ldr	r2, .L166+92
 2612 02b0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2613 02b4 08000BE5 		str	r0, [fp, #-8]
1630:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2614              		.loc 1 1630 0
 2615 02b8 08301BE5 		ldr	r3, [fp, #-8]
 2616 02bc 000053E3 		cmp	r3, #0
 2617 02c0 0500000A 		beq	.L147
1631:../CX3RDKOV5640.c ****     {
1632:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_STRNG_Dscr1 Err = 0x%x", status);
 2618              		.loc 1 1632 0
 2619 02c4 0400A0E3 		mov	r0, #4
 2620 02c8 38159FE5 		ldr	r1, .L166+96
 2621 02cc 08201BE5 		ldr	r2, [fp, #-8]
 2622 02d0 FEFFFFEB 		bl	CyU3PDebugPrint
1633:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2623              		.loc 1 1633 0
 2624 02d4 08001BE5 		ldr	r0, [fp, #-8]
 2625 02d8 FEFFFFEB 		bl	esUVCAppErrorHandler
 2626              	.L147:
1634:../CX3RDKOV5640.c ****     }
1635:../CX3RDKOV5640.c **** 
1636:../CX3RDKOV5640.c ****     /* String descriptor 2 */
1637:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)esUVCUSBProductDscr);
 2627              		.loc 1 1637 0
 2628 02dc 0500A0E3 		mov	r0, #5
 2629 02e0 0210A0E3 		mov	r1, #2
 2630 02e4 20259FE5 		ldr	r2, .L166+100
 2631 02e8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2632 02ec 08000BE5 		str	r0, [fp, #-8]
1638:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2633              		.loc 1 1638 0
 2634 02f0 08301BE5 		ldr	r3, [fp, #-8]
 2635 02f4 000053E3 		cmp	r3, #0
 2636 02f8 0500000A 		beq	.L148
1639:../CX3RDKOV5640.c ****     {
1640:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_STRNG_Dscr2 Err = 0x%x", status);
 2637              		.loc 1 1640 0
 2638 02fc 0400A0E3 		mov	r0, #4
 2639 0300 08159FE5 		ldr	r1, .L166+104
 2640 0304 08201BE5 		ldr	r2, [fp, #-8]
 2641 0308 FEFFFFEB 		bl	CyU3PDebugPrint
1641:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2642              		.loc 1 1641 0
 2643 030c 08001BE5 		ldr	r0, [fp, #-8]
 2644 0310 FEFFFFEB 		bl	esUVCAppErrorHandler
 2645              	.L148:
1642:../CX3RDKOV5640.c ****     }
1643:../CX3RDKOV5640.c ****     /* String descriptor 3 */
1644:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 3, (uint8_t *)esUVCUSBConfigSSDscr);
 2646              		.loc 1 1644 0
 2647 0314 0500A0E3 		mov	r0, #5
 2648 0318 0310A0E3 		mov	r1, #3
 2649 031c F0249FE5 		ldr	r2, .L166+108
 2650 0320 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2651 0324 08000BE5 		str	r0, [fp, #-8]
1645:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2652              		.loc 1 1645 0
 2653 0328 08301BE5 		ldr	r3, [fp, #-8]
 2654 032c 000053E3 		cmp	r3, #0
 2655 0330 0500000A 		beq	.L149
1646:../CX3RDKOV5640.c ****     {
1647:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_STRNG_Dscr3 Err = 0x%x", status);
 2656              		.loc 1 1647 0
 2657 0334 0400A0E3 		mov	r0, #4
 2658 0338 D8149FE5 		ldr	r1, .L166+112
 2659 033c 08201BE5 		ldr	r2, [fp, #-8]
 2660 0340 FEFFFFEB 		bl	CyU3PDebugPrint
1648:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2661              		.loc 1 1648 0
 2662 0344 08001BE5 		ldr	r0, [fp, #-8]
 2663 0348 FEFFFFEB 		bl	esUVCAppErrorHandler
 2664              	.L149:
1649:../CX3RDKOV5640.c ****     }
1650:../CX3RDKOV5640.c **** 
1651:../CX3RDKOV5640.c ****     /* String descriptor 4 */
1652:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 4, (uint8_t *)esUVCUSBConfigHSDscr);
 2665              		.loc 1 1652 0
 2666 034c 0500A0E3 		mov	r0, #5
 2667 0350 0410A0E3 		mov	r1, #4
 2668 0354 C0249FE5 		ldr	r2, .L166+116
 2669 0358 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2670 035c 08000BE5 		str	r0, [fp, #-8]
1653:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2671              		.loc 1 1653 0
 2672 0360 08301BE5 		ldr	r3, [fp, #-8]
 2673 0364 000053E3 		cmp	r3, #0
 2674 0368 0500000A 		beq	.L150
1654:../CX3RDKOV5640.c ****     {
1655:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_STRNG_Dscr4 Err = 0x%x", status);
 2675              		.loc 1 1655 0
 2676 036c 0400A0E3 		mov	r0, #4
 2677 0370 A8149FE5 		ldr	r1, .L166+120
 2678 0374 08201BE5 		ldr	r2, [fp, #-8]
 2679 0378 FEFFFFEB 		bl	CyU3PDebugPrint
1656:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2680              		.loc 1 1656 0
 2681 037c 08001BE5 		ldr	r0, [fp, #-8]
 2682 0380 FEFFFFEB 		bl	esUVCAppErrorHandler
 2683              	.L150:
1657:../CX3RDKOV5640.c ****     }
1658:../CX3RDKOV5640.c ****     /* String descriptor 2 */
1659:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 5, (uint8_t *)esUVCUSBConfigFSDscr);
 2684              		.loc 1 1659 0
 2685 0384 0500A0E3 		mov	r0, #5
 2686 0388 0510A0E3 		mov	r1, #5
 2687 038c 90249FE5 		ldr	r2, .L166+124
 2688 0390 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2689 0394 08000BE5 		str	r0, [fp, #-8]
1660:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2690              		.loc 1 1660 0
 2691 0398 08301BE5 		ldr	r3, [fp, #-8]
 2692 039c 000053E3 		cmp	r3, #0
 2693 03a0 0500000A 		beq	.L151
1661:../CX3RDKOV5640.c ****     {
1662:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_STRNG_Dscr5 Err = 0x%x", status);
 2694              		.loc 1 1662 0
 2695 03a4 0400A0E3 		mov	r0, #4
 2696 03a8 78149FE5 		ldr	r1, .L166+128
 2697 03ac 08201BE5 		ldr	r2, [fp, #-8]
 2698 03b0 FEFFFFEB 		bl	CyU3PDebugPrint
1663:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2699              		.loc 1 1663 0
 2700 03b4 08001BE5 		ldr	r0, [fp, #-8]
 2701 03b8 FEFFFFEB 		bl	esUVCAppErrorHandler
 2702              	.L151:
1664:../CX3RDKOV5640.c ****     }
1665:../CX3RDKOV5640.c **** 
1666:../CX3RDKOV5640.c ****     CyU3PUsbVBattEnable (CyTrue);
 2703              		.loc 1 1666 0
 2704 03bc 0100A0E3 		mov	r0, #1
 2705 03c0 FEFFFFEB 		bl	CyU3PUsbVBattEnable
1667:../CX3RDKOV5640.c ****     CyU3PUsbControlVBusDetect (CyFalse, CyTrue);
 2706              		.loc 1 1667 0
 2707 03c4 0000A0E3 		mov	r0, #0
 2708 03c8 0110A0E3 		mov	r1, #1
 2709 03cc FEFFFFEB 		bl	CyU3PUsbControlVBusDetect
1668:../CX3RDKOV5640.c **** 
1669:../CX3RDKOV5640.c ****     //TODO Change this function with the "Sensor specific" function to Write the Base I2C settings 
1670:../CX3RDKOV5640.c ****     /* Setup Image Sensor */
1671:../CX3RDKOV5640.c **** 	//esOV5640_Base_Config();
1672:../CX3RDKOV5640.c **** 	 //TODO Change this function with the "Sensor specific" function to Write the Base I2C settings fo
1673:../CX3RDKOV5640.c **** 	//esOV5640_Auto_Focus_Config();
1674:../CX3RDKOV5640.c **** 	//TODO Change this function with "Sensor Specific" PowerDown function to PowerDown the sensor
1675:../CX3RDKOV5640.c **** 	//esCamera_Power_Down();
1676:../CX3RDKOV5640.c **** 
1677:../CX3RDKOV5640.c ****     /* Connect the USB pins and enable super speed operation */
1678:../CX3RDKOV5640.c ****     status = CyU3PConnectState(CyTrue, CyTrue);
 2710              		.loc 1 1678 0
 2711 03d0 0100A0E3 		mov	r0, #1
 2712 03d4 0110A0E3 		mov	r1, #1
 2713 03d8 FEFFFFEB 		bl	CyU3PConnectState
 2714 03dc 08000BE5 		str	r0, [fp, #-8]
1679:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2715              		.loc 1 1679 0
 2716 03e0 08301BE5 		ldr	r3, [fp, #-8]
 2717 03e4 000053E3 		cmp	r3, #0
 2718 03e8 0500000A 		beq	.L152
1680:../CX3RDKOV5640.c ****     {
1681:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:ConnectState Err = 0x%x", status);
 2719              		.loc 1 1681 0
 2720 03ec 0400A0E3 		mov	r0, #4
 2721 03f0 34149FE5 		ldr	r1, .L166+132
 2722 03f4 08201BE5 		ldr	r2, [fp, #-8]
 2723 03f8 FEFFFFEB 		bl	CyU3PDebugPrint
1682:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2724              		.loc 1 1682 0
 2725 03fc 08001BE5 		ldr	r0, [fp, #-8]
 2726 0400 FEFFFFEB 		bl	esUVCAppErrorHandler
 2727              	.L152:
1683:../CX3RDKOV5640.c ****     }
1684:../CX3RDKOV5640.c **** #ifdef VISDebug
1685:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "n\rAppInit:ConnectState");
1686:../CX3RDKOV5640.c **** #endif
1687:../CX3RDKOV5640.c ****     /* Since the status interrupt endpoint is not used in this application,
1688:../CX3RDKOV5640.c ****      * just enable the EP in the beginning. */
1689:../CX3RDKOV5640.c ****     /* Control status interrupt endpoint configuration */
1690:../CX3RDKOV5640.c ****     endPointConfig.enable = 1;
 2728              		.loc 1 1690 0
 2729 0404 0130A0E3 		mov	r3, #1
 2730 0408 14300BE5 		str	r3, [fp, #-20]
1691:../CX3RDKOV5640.c ****     endPointConfig.epType = CY_U3P_USB_EP_INTR;
 2731              		.loc 1 1691 0
 2732 040c 0330A0E3 		mov	r3, #3
 2733 0410 10304BE5 		strb	r3, [fp, #-16]
1692:../CX3RDKOV5640.c ****     endPointConfig.pcktSize = 64;
 2734              		.loc 1 1692 0
 2735 0414 4030A0E3 		mov	r3, #64
 2736 0418 BC304BE1 		strh	r3, [fp, #-12]	@ movhi
1693:../CX3RDKOV5640.c ****     endPointConfig.isoPkts  = 1;
 2737              		.loc 1 1693 0
 2738 041c 0130A0E3 		mov	r3, #1
 2739 0420 09304BE5 		strb	r3, [fp, #-9]
1694:../CX3RDKOV5640.c ****     endPointConfig.burstLen = 1;
 2740              		.loc 1 1694 0
 2741 0424 0130A0E3 		mov	r3, #1
 2742 0428 0A304BE5 		strb	r3, [fp, #-10]
1695:../CX3RDKOV5640.c **** 
1696:../CX3RDKOV5640.c ****     status = CyU3PSetEpConfig(ES_UVC_EP_CONTROL_STATUS, &endPointConfig);
 2743              		.loc 1 1696 0
 2744 042c 14304BE2 		sub	r3, fp, #20
 2745 0430 8200A0E3 		mov	r0, #130
 2746 0434 0310A0E1 		mov	r1, r3
 2747 0438 FEFFFFEB 		bl	CyU3PSetEpConfig
 2748 043c 08000BE5 		str	r0, [fp, #-8]
1697:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2749              		.loc 1 1697 0
 2750 0440 08301BE5 		ldr	r3, [fp, #-8]
 2751 0444 000053E3 		cmp	r3, #0
 2752 0448 0500000A 		beq	.L153
1698:../CX3RDKOV5640.c ****     {
1699:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:CyU3PSetEpConfig CtrlEp Err = 0x%x", status);
 2753              		.loc 1 1699 0
 2754 044c 0400A0E3 		mov	r0, #4
 2755 0450 D8139FE5 		ldr	r1, .L166+136
 2756 0454 08201BE5 		ldr	r2, [fp, #-8]
 2757 0458 FEFFFFEB 		bl	CyU3PDebugPrint
1700:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2758              		.loc 1 1700 0
 2759 045c 08001BE5 		ldr	r0, [fp, #-8]
 2760 0460 FEFFFFEB 		bl	esUVCAppErrorHandler
 2761              	.L153:
1701:../CX3RDKOV5640.c ****     }
1702:../CX3RDKOV5640.c **** 
1703:../CX3RDKOV5640.c ****     CyU3PUsbFlushEp(ES_UVC_EP_CONTROL_STATUS);
 2762              		.loc 1 1703 0
 2763 0464 8200A0E3 		mov	r0, #130
 2764 0468 FEFFFFEB 		bl	CyU3PUsbFlushEp
1704:../CX3RDKOV5640.c **** 
1705:../CX3RDKOV5640.c ****     /* Setup the Bulk endpoint used for Video Streaming */
1706:../CX3RDKOV5640.c ****     endPointConfig.enable = CyTrue;
 2765              		.loc 1 1706 0
 2766 046c 0130A0E3 		mov	r3, #1
 2767 0470 14300BE5 		str	r3, [fp, #-20]
1707:../CX3RDKOV5640.c ****     endPointConfig.epType = CY_U3P_USB_EP_BULK;
 2768              		.loc 1 1707 0
 2769 0474 0230A0E3 		mov	r3, #2
 2770 0478 10304BE5 		strb	r3, [fp, #-16]
1708:../CX3RDKOV5640.c **** 
1709:../CX3RDKOV5640.c ****     endPointConfig.isoPkts  = 0;
 2771              		.loc 1 1709 0
 2772 047c 0030A0E3 		mov	r3, #0
 2773 0480 09304BE5 		strb	r3, [fp, #-9]
1710:../CX3RDKOV5640.c ****     endPointConfig.streams = 0;
 2774              		.loc 1 1710 0
 2775 0484 0030A0E3 		mov	r3, #0
 2776 0488 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
1711:../CX3RDKOV5640.c **** 
1712:../CX3RDKOV5640.c ****     CyU3PThreadSleep(1000);
 2777              		.loc 1 1712 0
 2778 048c FA0FA0E3 		mov	r0, #1000
 2779 0490 FEFFFFEB 		bl	_tx_thread_sleep
1713:../CX3RDKOV5640.c **** 
1714:../CX3RDKOV5640.c ****     switch(CyU3PUsbGetSpeed())
 2780              		.loc 1 1714 0
 2781 0494 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 2782 0498 0030A0E1 		mov	r3, r0
 2783 049c 010053E3 		cmp	r3, #1
 2784 04a0 0F00000A 		beq	.L155
 2785 04a4 020053E3 		cmp	r3, #2
 2786 04a8 1200001A 		bne	.L165
1715:../CX3RDKOV5640.c ****     {
1716:../CX3RDKOV5640.c ****         case CY_U3P_HIGH_SPEED:
1717:../CX3RDKOV5640.c ****             endPointConfig.pcktSize = 0x200;
 2787              		.loc 1 1717 0
 2788 04ac 023CA0E3 		mov	r3, #512
 2789 04b0 BC304BE1 		strh	r3, [fp, #-12]	@ movhi
1718:../CX3RDKOV5640.c ****             endPointConfig.burstLen = 1;
 2790              		.loc 1 1718 0
 2791 04b4 0130A0E3 		mov	r3, #1
 2792 04b8 0A304BE5 		strb	r3, [fp, #-10]
1719:../CX3RDKOV5640.c ****             ES_UVC_STREAM_BUF_SIZE 	= ES_UVC_HS_STREAM_BUF_SIZE;
 2793              		.loc 1 1719 0
 2794 04bc 70339FE5 		ldr	r3, .L166+140
 2795 04c0 032BA0E3 		mov	r2, #3072
 2796 04c4 B020C3E1 		strh	r2, [r3]	@ movhi
1720:../CX3RDKOV5640.c ****             ES_UVC_DATA_BUF_SIZE 	= ES_UVC_HS_DATA_BUF_SIZE;
 2797              		.loc 1 1720 0
 2798 04c8 68339FE5 		ldr	r3, .L166+144
 2799 04cc BF2EA0E3 		mov	r2, #3056
 2800 04d0 B020C3E1 		strh	r2, [r3]	@ movhi
1721:../CX3RDKOV5640.c ****             ES_UVC_STREAM_BUF_COUNT	= ES_UVC_HS_STREAM_BUF_COUNT;
 2801              		.loc 1 1721 0
 2802 04d4 60339FE5 		ldr	r3, .L166+148
 2803 04d8 0820A0E3 		mov	r2, #8
 2804 04dc 0020C3E5 		strb	r2, [r3]
1722:../CX3RDKOV5640.c ****             break;
 2805              		.loc 1 1722 0
 2806 04e0 120000EA 		b	.L157
 2807              	.L155:
1723:../CX3RDKOV5640.c **** 
1724:../CX3RDKOV5640.c ****         case CY_U3P_FULL_SPEED:
1725:../CX3RDKOV5640.c ****             endPointConfig.pcktSize = 0x40;
 2808              		.loc 1 1725 0
 2809 04e4 4030A0E3 		mov	r3, #64
 2810 04e8 BC304BE1 		strh	r3, [fp, #-12]	@ movhi
1726:../CX3RDKOV5640.c ****             endPointConfig.burstLen = 1;
 2811              		.loc 1 1726 0
 2812 04ec 0130A0E3 		mov	r3, #1
 2813 04f0 0A304BE5 		strb	r3, [fp, #-10]
1727:../CX3RDKOV5640.c ****             break;
 2814              		.loc 1 1727 0
 2815 04f4 0D0000EA 		b	.L157
 2816              	.L165:
1728:../CX3RDKOV5640.c **** 
1729:../CX3RDKOV5640.c ****         case CY_U3P_SUPER_SPEED:
1730:../CX3RDKOV5640.c ****         default:
1731:../CX3RDKOV5640.c ****             endPointConfig.pcktSize = ES_UVC_EP_BULK_VIDEO_PKT_SIZE;
 2817              		.loc 1 1731 0
 2818 04f8 013BA0E3 		mov	r3, #1024
 2819 04fc BC304BE1 		strh	r3, [fp, #-12]	@ movhi
1732:../CX3RDKOV5640.c ****             endPointConfig.burstLen = 16;
 2820              		.loc 1 1732 0
 2821 0500 1030A0E3 		mov	r3, #16
 2822 0504 0A304BE5 		strb	r3, [fp, #-10]
1733:../CX3RDKOV5640.c ****             ES_UVC_STREAM_BUF_SIZE 	= ES_UVC_SS_STREAM_BUF_SIZE;
 2823              		.loc 1 1733 0
 2824 0508 24339FE5 		ldr	r3, .L166+140
 2825 050c 062AA0E3 		mov	r2, #24576
 2826 0510 B020C3E1 		strh	r2, [r3]	@ movhi
1734:../CX3RDKOV5640.c ****             ES_UVC_DATA_BUF_SIZE 	= ES_UVC_SS_DATA_BUF_SIZE;
 2827              		.loc 1 1734 0
 2828 0514 1C339FE5 		ldr	r3, .L166+144
 2829 0518 20239FE5 		ldr	r2, .L166+152
 2830 051c B020C3E1 		strh	r2, [r3]	@ movhi
1735:../CX3RDKOV5640.c ****             ES_UVC_STREAM_BUF_COUNT	= ES_UVC_SS_STREAM_BUF_COUNT;
 2831              		.loc 1 1735 0
 2832 0520 14339FE5 		ldr	r3, .L166+148
 2833 0524 0420A0E3 		mov	r2, #4
 2834 0528 0020C3E5 		strb	r2, [r3]
1736:../CX3RDKOV5640.c ****             break;
 2835              		.loc 1 1736 0
 2836 052c 0000A0E1 		mov	r0, r0	@ nop
 2837              	.L157:
1737:../CX3RDKOV5640.c ****     }
1738:../CX3RDKOV5640.c **** 
1739:../CX3RDKOV5640.c ****     status = CyU3PSetEpConfig(ES_UVC_EP_BULK_VIDEO, &endPointConfig);
 2838              		.loc 1 1739 0
 2839 0530 14304BE2 		sub	r3, fp, #20
 2840 0534 8300A0E3 		mov	r0, #131
 2841 0538 0310A0E1 		mov	r1, r3
 2842 053c FEFFFFEB 		bl	CyU3PSetEpConfig
 2843 0540 08000BE5 		str	r0, [fp, #-8]
1740:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2844              		.loc 1 1740 0
 2845 0544 08301BE5 		ldr	r3, [fp, #-8]
 2846 0548 000053E3 		cmp	r3, #0
 2847 054c 0500000A 		beq	.L158
1741:../CX3RDKOV5640.c ****     {
1742:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:CyU3PSetEpConfig BulkEp Err = 0x%x", status);
 2848              		.loc 1 1742 0
 2849 0550 0400A0E3 		mov	r0, #4
 2850 0554 E8129FE5 		ldr	r1, .L166+156
 2851 0558 08201BE5 		ldr	r2, [fp, #-8]
 2852 055c FEFFFFEB 		bl	CyU3PDebugPrint
1743:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2853              		.loc 1 1743 0
 2854 0560 08001BE5 		ldr	r0, [fp, #-8]
 2855 0564 FEFFFFEB 		bl	esUVCAppErrorHandler
 2856              	.L158:
1744:../CX3RDKOV5640.c ****     }
1745:../CX3RDKOV5640.c **** #ifdef VISDebug
1746:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:CyU3PSetEpConfig BulkEp");
1747:../CX3RDKOV5640.c **** #endif
1748:../CX3RDKOV5640.c ****     CyU3PUsbEPSetBurstMode (ES_UVC_EP_BULK_VIDEO, CyTrue);
 2857              		.loc 1 1748 0
 2858 0568 8300A0E3 		mov	r0, #131
 2859 056c 0110A0E3 		mov	r1, #1
 2860 0570 FEFFFFEB 		bl	CyU3PUsbEPSetBurstMode
1749:../CX3RDKOV5640.c **** 
1750:../CX3RDKOV5640.c ****     /* Flush the endpoint memory */
1751:../CX3RDKOV5640.c ****     CyU3PUsbFlushEp(ES_UVC_EP_BULK_VIDEO);
 2861              		.loc 1 1751 0
 2862 0574 8300A0E3 		mov	r0, #131
 2863 0578 FEFFFFEB 		bl	CyU3PUsbFlushEp
1752:../CX3RDKOV5640.c **** 
1753:../CX3RDKOV5640.c ****     /* Create a DMA Manual OUT channel for streaming data */
1754:../CX3RDKOV5640.c ****     /* Video streaming Channel is not active till a stream request is received */
1755:../CX3RDKOV5640.c ****     dmaCfg.size                 = ES_UVC_STREAM_BUF_SIZE;
 2864              		.loc 1 1755 0
 2865 057c B0329FE5 		ldr	r3, .L166+140
 2866 0580 B030D3E1 		ldrh	r3, [r3]
 2867 0584 BC334BE1 		strh	r3, [fp, #-60]	@ movhi
1756:../CX3RDKOV5640.c ****     dmaCfg.count                = ES_UVC_STREAM_BUF_COUNT;
 2868              		.loc 1 1756 0
 2869 0588 AC329FE5 		ldr	r3, .L166+148
 2870 058c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2871 0590 BA334BE1 		strh	r3, [fp, #-58]	@ movhi
1757:../CX3RDKOV5640.c ****     dmaCfg.validSckCount        = 2;
 2872              		.loc 1 1757 0
 2873 0594 0230A0E3 		mov	r3, #2
 2874 0598 B8334BE1 		strh	r3, [fp, #-56]	@ movhi
1758:../CX3RDKOV5640.c **** 
1759:../CX3RDKOV5640.c ****     dmaCfg.prodSckId[0]         = ES_UVC_PRODUCER_PPORT_SOCKET_0;
 2875              		.loc 1 1759 0
 2876 059c 013CA0E3 		mov	r3, #256
 2877 05a0 B6334BE1 		strh	r3, [fp, #-54]	@ movhi
1760:../CX3RDKOV5640.c ****     dmaCfg.prodSckId[1]         = ES_UVC_PRODUCER_PPORT_SOCKET_1;
 2878              		.loc 1 1760 0
 2879 05a4 9C329FE5 		ldr	r3, .L166+160
 2880 05a8 B4334BE1 		strh	r3, [fp, #-52]	@ movhi
1761:../CX3RDKOV5640.c **** 
1762:../CX3RDKOV5640.c ****     dmaCfg.consSckId[0]         = ES_UVC_EP_VIDEO_CONS_SOCKET;
 2881              		.loc 1 1762 0
 2882 05ac 98329FE5 		ldr	r3, .L166+164
 2883 05b0 BE324BE1 		strh	r3, [fp, #-46]	@ movhi
1763:../CX3RDKOV5640.c ****     dmaCfg.dmaMode              = CY_U3P_DMA_MODE_BYTE;
 2884              		.loc 1 1763 0
 2885 05b4 0030A0E3 		mov	r3, #0
 2886 05b8 1E304BE5 		strb	r3, [fp, #-30]
1764:../CX3RDKOV5640.c ****     dmaCfg.notification         = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 2887              		.loc 1 1764 0
 2888 05bc 1830A0E3 		mov	r3, #24
 2889 05c0 1C300BE5 		str	r3, [fp, #-28]
1765:../CX3RDKOV5640.c ****     dmaCfg.cb                   = esUVCUvcAppDmaCallback;
 2890              		.loc 1 1765 0
 2891 05c4 84329FE5 		ldr	r3, .L166+168
 2892 05c8 18300BE5 		str	r3, [fp, #-24]
1766:../CX3RDKOV5640.c ****     dmaCfg.prodHeader           = ES_UVC_PROD_HEADER;
 2893              		.loc 1 1766 0
 2894 05cc 0C30A0E3 		mov	r3, #12
 2895 05d0 B4324BE1 		strh	r3, [fp, #-36]	@ movhi
1767:../CX3RDKOV5640.c ****     dmaCfg.prodFooter           = ES_UVC_PROD_FOOTER;
 2896              		.loc 1 1767 0
 2897 05d4 0430A0E3 		mov	r3, #4
 2898 05d8 B2324BE1 		strh	r3, [fp, #-34]	@ movhi
1768:../CX3RDKOV5640.c ****     dmaCfg.consHeader           = 0;
 2899              		.loc 1 1768 0
 2900 05dc 0030A0E3 		mov	r3, #0
 2901 05e0 B0324BE1 		strh	r3, [fp, #-32]	@ movhi
1769:../CX3RDKOV5640.c ****     dmaCfg.prodAvailCount       = 0;
 2902              		.loc 1 1769 0
 2903 05e4 0030A0E3 		mov	r3, #0
 2904 05e8 B6324BE1 		strh	r3, [fp, #-38]	@ movhi
1770:../CX3RDKOV5640.c **** 
1771:../CX3RDKOV5640.c ****     status = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO_ONE ,
 2905              		.loc 1 1771 0
 2906 05ec 3C304BE2 		sub	r3, fp, #60
 2907 05f0 5C029FE5 		ldr	r0, .L166+172
 2908 05f4 0710A0E3 		mov	r1, #7
 2909 05f8 0320A0E1 		mov	r2, r3
 2910 05fc FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 2911 0600 08000BE5 		str	r0, [fp, #-8]
1772:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2912              		.loc 1 1772 0
 2913 0604 08301BE5 		ldr	r3, [fp, #-8]
 2914 0608 000053E3 		cmp	r3, #0
 2915 060c 0300000A 		beq	.L159
1773:../CX3RDKOV5640.c ****     {
1774:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:DmaMultiChannelCreate Err = 0x%x", status);
 2916              		.loc 1 1774 0
 2917 0610 0400A0E3 		mov	r0, #4
 2918 0614 3C129FE5 		ldr	r1, .L166+176
 2919 0618 08201BE5 		ldr	r2, [fp, #-8]
 2920 061c FEFFFFEB 		bl	CyU3PDebugPrint
 2921              	.L159:
1775:../CX3RDKOV5640.c ****     }
1776:../CX3RDKOV5640.c ****     CyU3PThreadSleep(100);
 2922              		.loc 1 1776 0
 2923 0620 6400A0E3 		mov	r0, #100
 2924 0624 FEFFFFEB 		bl	_tx_thread_sleep
1777:../CX3RDKOV5640.c **** 
1778:../CX3RDKOV5640.c ****     /* Reset the channel: Set to DSCR chain starting point in PORD/CONS SCKT; set
1779:../CX3RDKOV5640.c ****        DSCR_SIZE field in DSCR memory */
1780:../CX3RDKOV5640.c ****     status = CyU3PDmaMultiChannelReset(&glChHandleUVCStream);  //-TODO the glChHandleUVCStream
 2925              		.loc 1 1780 0
 2926 0628 24029FE5 		ldr	r0, .L166+172
 2927 062c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 2928 0630 08000BE5 		str	r0, [fp, #-8]
1781:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2929              		.loc 1 1781 0
 2930 0634 08301BE5 		ldr	r3, [fp, #-8]
 2931 0638 000053E3 		cmp	r3, #0
 2932 063c 0300000A 		beq	.L160
1782:../CX3RDKOV5640.c ****     {
1783:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4,"\n\rAppInit:MultiChannelReset Err = 0x%x", status);
 2933              		.loc 1 1783 0
 2934 0640 0400A0E3 		mov	r0, #4
 2935 0644 10129FE5 		ldr	r1, .L166+180
 2936 0648 08201BE5 		ldr	r2, [fp, #-8]
 2937 064c FEFFFFEB 		bl	CyU3PDebugPrint
 2938              	.L160:
1784:../CX3RDKOV5640.c ****     }
1785:../CX3RDKOV5640.c **** #ifdef VISDebug
1786:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:MultiChannelReset");
1787:../CX3RDKOV5640.c **** #endif
1788:../CX3RDKOV5640.c ****     /* Configure the Fixed Function GPIF on the CX3 to use a 16 bit bus, and
1789:../CX3RDKOV5640.c ****      * a DMA Buffer of size CX3_UVC_DATA_BUF_SIZE
1790:../CX3RDKOV5640.c ****      */
1791:../CX3RDKOV5640.c ****     status = CyU3PMipicsiGpifLoad(CY_U3P_MIPICSI_BUS_16, ES_UVC_DATA_BUF_SIZE);
 2939              		.loc 1 1791 0
 2940 0650 E0319FE5 		ldr	r3, .L166+144
 2941 0654 B030D3E1 		ldrh	r3, [r3]
 2942 0658 0100A0E3 		mov	r0, #1
 2943 065c 0310A0E1 		mov	r1, r3
 2944 0660 FEFFFFEB 		bl	CyU3PMipicsiGpifLoad
 2945 0664 08000BE5 		str	r0, [fp, #-8]
1792:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2946              		.loc 1 1792 0
 2947 0668 08301BE5 		ldr	r3, [fp, #-8]
 2948 066c 000053E3 		cmp	r3, #0
 2949 0670 0500000A 		beq	.L161
1793:../CX3RDKOV5640.c ****     {
1794:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:MipicsiGpifLoad Err = 0x%x", status);
 2950              		.loc 1 1794 0
 2951 0674 0400A0E3 		mov	r0, #4
 2952 0678 E0119FE5 		ldr	r1, .L166+184
 2953 067c 08201BE5 		ldr	r2, [fp, #-8]
 2954 0680 FEFFFFEB 		bl	CyU3PDebugPrint
1795:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2955              		.loc 1 1795 0
 2956 0684 08001BE5 		ldr	r0, [fp, #-8]
 2957 0688 FEFFFFEB 		bl	esUVCAppErrorHandler
 2958              	.L161:
1796:../CX3RDKOV5640.c ****     }
1797:../CX3RDKOV5640.c ****     CyU3PThreadSleep(50);
 2959              		.loc 1 1797 0
 2960 068c 3200A0E3 		mov	r0, #50
 2961 0690 FEFFFFEB 		bl	_tx_thread_sleep
1798:../CX3RDKOV5640.c **** #ifdef VISDebug
1799:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:MipicsiGpifLoad");
1800:../CX3RDKOV5640.c **** #endif
1801:../CX3RDKOV5640.c ****     CyU3PGpifRegisterCallback(esUVCGpifCB);
 2962              		.loc 1 1801 0
 2963 0694 C8019FE5 		ldr	r0, .L166+188
 2964 0698 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
1802:../CX3RDKOV5640.c ****     CyU3PThreadSleep(50);
 2965              		.loc 1 1802 0
 2966 069c 3200A0E3 		mov	r0, #50
 2967 06a0 FEFFFFEB 		bl	_tx_thread_sleep
1803:../CX3RDKOV5640.c **** 
1804:../CX3RDKOV5640.c ****     /* Start the state machine. */
1805:../CX3RDKOV5640.c ****     status = CyU3PGpifSMStart (CX3_START_SCK0, ALPHA_CX3_START_SCK0);
 2968              		.loc 1 1805 0
 2969 06a4 0000A0E3 		mov	r0, #0
 2970 06a8 0010A0E3 		mov	r1, #0
 2971 06ac FEFFFFEB 		bl	CyU3PGpifSMStart
 2972 06b0 08000BE5 		str	r0, [fp, #-8]
1806:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2973              		.loc 1 1806 0
 2974 06b4 08301BE5 		ldr	r3, [fp, #-8]
 2975 06b8 000053E3 		cmp	r3, #0
 2976 06bc 0500000A 		beq	.L162
1807:../CX3RDKOV5640.c ****     {
1808:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:GpifSMStart Err = 0x%x", status);
 2977              		.loc 1 1808 0
 2978 06c0 0400A0E3 		mov	r0, #4
 2979 06c4 9C119FE5 		ldr	r1, .L166+192
 2980 06c8 08201BE5 		ldr	r2, [fp, #-8]
 2981 06cc FEFFFFEB 		bl	CyU3PDebugPrint
1809:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2982              		.loc 1 1809 0
 2983 06d0 08001BE5 		ldr	r0, [fp, #-8]
 2984 06d4 FEFFFFEB 		bl	esUVCAppErrorHandler
 2985              	.L162:
1810:../CX3RDKOV5640.c ****     }
1811:../CX3RDKOV5640.c ****     CyU3PThreadSleep(50);
 2986              		.loc 1 1811 0
 2987 06d8 3200A0E3 		mov	r0, #50
 2988 06dc FEFFFFEB 		bl	_tx_thread_sleep
1812:../CX3RDKOV5640.c **** #ifdef VISDebug
1813:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:GpifSMStart");
1814:../CX3RDKOV5640.c **** #endif
1815:../CX3RDKOV5640.c ****     /* Pause the GPIF*/
1816:../CX3RDKOV5640.c ****     CyU3PGpifSMControl(CyTrue);
 2989              		.loc 1 1816 0
 2990 06e0 0100A0E3 		mov	r0, #1
 2991 06e4 FEFFFFEB 		bl	CyU3PGpifSMControl
1817:../CX3RDKOV5640.c **** 
1818:../CX3RDKOV5640.c ****     /* Initialize the MIPI block */
1819:../CX3RDKOV5640.c ****     status =  CyU3PMipicsiInit();
 2992              		.loc 1 1819 0
 2993 06e8 FEFFFFEB 		bl	CyU3PMipicsiInit
 2994 06ec 08000BE5 		str	r0, [fp, #-8]
1820:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2995              		.loc 1 1820 0
 2996 06f0 08301BE5 		ldr	r3, [fp, #-8]
 2997 06f4 000053E3 		cmp	r3, #0
 2998 06f8 0500000A 		beq	.L163
1821:../CX3RDKOV5640.c ****     {
1822:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:MipicsiInit Err = 0x%x", status);
 2999              		.loc 1 1822 0
 3000 06fc 0400A0E3 		mov	r0, #4
 3001 0700 64119FE5 		ldr	r1, .L166+196
 3002 0704 08201BE5 		ldr	r2, [fp, #-8]
 3003 0708 FEFFFFEB 		bl	CyU3PDebugPrint
1823:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 3004              		.loc 1 1823 0
 3005 070c 08001BE5 		ldr	r0, [fp, #-8]
 3006 0710 FEFFFFEB 		bl	esUVCAppErrorHandler
 3007              	.L163:
1824:../CX3RDKOV5640.c ****     }
1825:../CX3RDKOV5640.c **** #ifdef VISDebug
1826:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:MipicsiInit");
1827:../CX3RDKOV5640.c **** #endif
1828:../CX3RDKOV5640.c ****     status = CyU3PMipicsiSetIntfParams(&cfgUvcVgaNoMclk, CyTrue/*CyFalse*/);
 3008              		.loc 1 1828 0
 3009 0714 54019FE5 		ldr	r0, .L166+200
 3010 0718 0110A0E3 		mov	r1, #1
 3011 071c FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 3012 0720 08000BE5 		str	r0, [fp, #-8]
1829:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3013              		.loc 1 1829 0
 3014 0724 08301BE5 		ldr	r3, [fp, #-8]
 3015 0728 000053E3 		cmp	r3, #0
 3016 072c 0500000A 		beq	.L164
1830:../CX3RDKOV5640.c ****     {
1831:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:MipicsiSetIntfParams Err = 0x%x",status);
 3017              		.loc 1 1831 0
 3018 0730 0400A0E3 		mov	r0, #4
 3019 0734 38119FE5 		ldr	r1, .L166+204
 3020 0738 08201BE5 		ldr	r2, [fp, #-8]
 3021 073c FEFFFFEB 		bl	CyU3PDebugPrint
1832:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 3022              		.loc 1 1832 0
 3023 0740 08001BE5 		ldr	r0, [fp, #-8]
 3024 0744 FEFFFFEB 		bl	esUVCAppErrorHandler
 3025              	.L164:
1833:../CX3RDKOV5640.c ****     }
1834:../CX3RDKOV5640.c **** #ifdef VISDebug
1835:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:MipicsiSetIntfParams");
1836:../CX3RDKOV5640.c **** #endif
1837:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
1838:../CX3RDKOV5640.c ****     CyU3PTimerCreate (&UvcTimer, UvcAppProgressTimer, 0x00, TIMER_PERIOD, 0, CYU3P_NO_ACTIVATE);
 3026              		.loc 1 1838 0
 3027 0748 7D3FA0E3 		mov	r3, #500
 3028 074c 00308DE5 		str	r3, [sp]
 3029 0750 0030A0E3 		mov	r3, #0
 3030 0754 04308DE5 		str	r3, [sp, #4]
 3031 0758 0030A0E3 		mov	r3, #0
 3032 075c 08308DE5 		str	r3, [sp, #8]
 3033 0760 2C30A0E3 		mov	r3, #44
 3034 0764 0C308DE5 		str	r3, [sp, #12]
 3035 0768 08019FE5 		ldr	r0, .L166+208
 3036 076c 0010A0E3 		mov	r1, #0
 3037 0770 04219FE5 		ldr	r2, .L166+212
 3038 0774 0030A0E3 		mov	r3, #0
 3039 0778 FEFFFFEB 		bl	_txe_timer_create
1839:../CX3RDKOV5640.c **** #endif
1840:../CX3RDKOV5640.c **** 
1841:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rFirmware Version: %d.%d.%d.%d",MajorVersion,MinorVersion,SubVersion,Su
 3040              		.loc 1 1841 0
 3041 077c 8530A0E3 		mov	r3, #133
 3042 0780 00308DE5 		str	r3, [sp]
 3043 0784 F4309FE5 		ldr	r3, .L166+216
 3044 0788 04308DE5 		str	r3, [sp, #4]
 3045 078c 0400A0E3 		mov	r0, #4
 3046 0790 EC109FE5 		ldr	r1, .L166+220
 3047 0794 0120A0E3 		mov	r2, #1
 3048 0798 0330A0E3 		mov	r3, #3
 3049 079c FEFFFFEB 		bl	CyU3PDebugPrint
1842:../CX3RDKOV5640.c **** }
 3050              		.loc 1 1842 0
 3051 07a0 04D04BE2 		sub	sp, fp, #4
 3052              		@ sp needed
 3053 07a4 0088BDE8 		ldmfd	sp!, {fp, pc}
 3054              	.L167:
 3055              		.align	2
 3056              	.L166:
 3057 07a8 E4020000 		.word	.LC18
 3058 07ac 04030000 		.word	.LC19
 3059 07b0 24030000 		.word	.LC20
 3060 07b4 44030000 		.word	.LC21
 3061 07b8 00000000 		.word	esUVCUvcApplnUSBSetupCB
 3062 07bc 00000000 		.word	esUVCUvcApplnUSBEventCB
 3063 07c0 00000000 		.word	esUVCApplnLPMRqtCB
 3064 07c4 00000000 		.word	esUVCUSB30DeviceDscr
 3065 07c8 64030000 		.word	.LC22
 3066 07cc 00000000 		.word	esUVCUSB20DeviceDscr
 3067 07d0 8C030000 		.word	.LC23
 3068 07d4 00000000 		.word	esUVCUSBBOSDscr
 3069 07d8 B4030000 		.word	.LC24
 3070 07dc 00000000 		.word	esUVCUSBDeviceQualDscr
 3071 07e0 D8030000 		.word	.LC25
 3072 07e4 00000000 		.word	esUVCUSBSSConfigDscr
 3073 07e8 00040000 		.word	.LC26
 3074 07ec 00000000 		.word	esUVCUSBHSConfigDscr
 3075 07f0 28040000 		.word	.LC27
 3076 07f4 00000000 		.word	esUVCUSBFSConfigDscr
 3077 07f8 50040000 		.word	.LC28
 3078 07fc 00000000 		.word	esUVCUSBStringLangIDDscr
 3079 0800 78040000 		.word	.LC29
 3080 0804 00000000 		.word	esUVCUSBManufactureDscr
 3081 0808 A0040000 		.word	.LC30
 3082 080c 00000000 		.word	esUVCUSBProductDscr
 3083 0810 C8040000 		.word	.LC31
 3084 0814 00000000 		.word	esUVCUSBConfigSSDscr
 3085 0818 F0040000 		.word	.LC32
 3086 081c 00000000 		.word	esUVCUSBConfigHSDscr
 3087 0820 18050000 		.word	.LC33
 3088 0824 00000000 		.word	esUVCUSBConfigFSDscr
 3089 0828 40050000 		.word	.LC34
 3090 082c 68050000 		.word	.LC35
 3091 0830 8C050000 		.word	.LC36
 3092 0834 00000000 		.word	ES_UVC_STREAM_BUF_SIZE
 3093 0838 00000000 		.word	ES_UVC_DATA_BUF_SIZE
 3094 083c 00000000 		.word	ES_UVC_STREAM_BUF_COUNT
 3095 0840 F05F0000 		.word	24560
 3096 0844 BC050000 		.word	.LC37
 3097 0848 01010000 		.word	257
 3098 084c 03030000 		.word	771
 3099 0850 00000000 		.word	esUVCUvcAppDmaCallback
 3100 0854 00000000 		.word	glChHandleUVCStream
 3101 0858 EC050000 		.word	.LC38
 3102 085c 18060000 		.word	.LC39
 3103 0860 40060000 		.word	.LC40
 3104 0864 00000000 		.word	esUVCGpifCB
 3105 0868 68060000 		.word	.LC41
 3106 086c 8C060000 		.word	.LC42
 3107 0870 00000000 		.word	cfgUvcVgaNoMclk
 3108 0874 B0060000 		.word	.LC43
 3109 0878 00000000 		.word	UvcTimer
 3110 087c 00000000 		.word	UvcAppProgressTimer
 3111 0880 35010000 		.word	309
 3112 0884 DC060000 		.word	.LC44
 3113              		.cfi_endproc
 3114              	.LFE11:
 3116              		.section	.rodata
 3117              		.align	2
 3118              	.LC45:
 3119 06fc 0A0D6573 		.ascii	"\012\015esUVCUvcApplnDebugInit:CyU3PUartInit failed"
 3119      55564355 
 3119      76634170 
 3119      706C6E44 
 3119      65627567 
 3120 0729 20457272 		.ascii	" Error = 0x%x\000"
 3120      6F72203D 
 3120      20307825 
 3120      7800
 3121 0737 00       		.align	2
 3122              	.LC46:
 3123 0738 0A0D6573 		.ascii	"\012\015esUVCUvcApplnDebugInit:CyU3PUartSetConfig f"
 3123      55564355 
 3123      76634170 
 3123      706C6E44 
 3123      65627567 
 3124 0765 61696C65 		.ascii	"ailed Error = 0x%x\000"
 3124      64204572 
 3124      726F7220 
 3124      3D203078 
 3124      257800
 3125              		.align	2
 3126              	.LC47:
 3127 0778 0A0D6573 		.ascii	"\012\015esUVCUvcApplnDebugInit:CyU3PUartTxSetBlockX"
 3127      55564355 
 3127      76634170 
 3127      706C6E44 
 3127      65627567 
 3128 07a5 66657220 		.ascii	"fer failed Error = 0x%x\000"
 3128      6661696C 
 3128      65642045 
 3128      72726F72 
 3128      203D2030 
 3129 07bd 000000   		.align	2
 3130              	.LC48:
 3131 07c0 0A0D6573 		.ascii	"\012\015esUVCUvcApplnDebugInit:CyU3PDebugInit faile"
 3131      55564355 
 3131      76634170 
 3131      706C6E44 
 3131      65627567 
 3132 07ed 64204572 		.ascii	"d Error = 0x%x\000"
 3132      726F7220 
 3132      3D203078 
 3132      257800
 3133              		.section	.text.esUVCUvcApplnDebugInit,"ax",%progbits
 3134              		.align	2
 3135              		.global	esUVCUvcApplnDebugInit
 3137              	esUVCUvcApplnDebugInit:
 3138              	.LFB12:
1843:../CX3RDKOV5640.c **** 
1844:../CX3RDKOV5640.c **** /* This function initializes the debug module for the UVC application */
1845:../CX3RDKOV5640.c ****     void
1846:../CX3RDKOV5640.c **** esUVCUvcApplnDebugInit (void)
1847:../CX3RDKOV5640.c **** {
 3139              		.loc 1 1847 0
 3140              		.cfi_startproc
 3141              		@ args = 0, pretend = 0, frame = 32
 3142              		@ frame_needed = 1, uses_anonymous_args = 0
 3143 0000 00482DE9 		stmfd	sp!, {fp, lr}
 3144              	.LCFI24:
 3145              		.cfi_def_cfa_offset 8
 3146              		.cfi_offset 11, -8
 3147              		.cfi_offset 14, -4
 3148 0004 04B08DE2 		add	fp, sp, #4
 3149              	.LCFI25:
 3150              		.cfi_def_cfa 11, 4
 3151 0008 20D04DE2 		sub	sp, sp, #32
1848:../CX3RDKOV5640.c ****     CyU3PUartConfig_t uartConfig;
1849:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 3152              		.loc 1 1849 0
 3153 000c 0030A0E3 		mov	r3, #0
 3154 0010 08300BE5 		str	r3, [fp, #-8]
1850:../CX3RDKOV5640.c **** 
1851:../CX3RDKOV5640.c ****     /* Initialize the UART for printing debug messages */
1852:../CX3RDKOV5640.c ****     status = CyU3PUartInit();
 3155              		.loc 1 1852 0
 3156 0014 FEFFFFEB 		bl	CyU3PUartInit
 3157 0018 08000BE5 		str	r0, [fp, #-8]
1853:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3158              		.loc 1 1853 0
 3159 001c 08301BE5 		ldr	r3, [fp, #-8]
 3160 0020 000053E3 		cmp	r3, #0
 3161 0024 0300000A 		beq	.L169
1854:../CX3RDKOV5640.c ****     {
1855:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\resUVCUvcApplnDebugInit:CyU3PUartInit failed Error = 0x%x",status);
 3162              		.loc 1 1855 0
 3163 0028 0400A0E3 		mov	r0, #4
 3164 002c D0109FE5 		ldr	r1, .L173
 3165 0030 08201BE5 		ldr	r2, [fp, #-8]
 3166 0034 FEFFFFEB 		bl	CyU3PDebugPrint
 3167              	.L169:
1856:../CX3RDKOV5640.c ****     }
1857:../CX3RDKOV5640.c **** 
1858:../CX3RDKOV5640.c ****     /* Set UART Configuration */
1859:../CX3RDKOV5640.c ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 3168              		.loc 1 1859 0
 3169 0038 C8309FE5 		ldr	r3, .L173+4
 3170 003c 10300BE5 		str	r3, [fp, #-16]
1860:../CX3RDKOV5640.c ****     uartConfig.stopBit = CY_U3P_UART_ONE_STOP_BIT;
 3171              		.loc 1 1860 0
 3172 0040 0130A0E3 		mov	r3, #1
 3173 0044 0C304BE5 		strb	r3, [fp, #-12]
1861:../CX3RDKOV5640.c ****     uartConfig.parity = CY_U3P_UART_NO_PARITY;
 3174              		.loc 1 1861 0
 3175 0048 0030A0E3 		mov	r3, #0
 3176 004c 0B304BE5 		strb	r3, [fp, #-11]
1862:../CX3RDKOV5640.c ****     uartConfig.txEnable = CyTrue;
 3177              		.loc 1 1862 0
 3178 0050 0130A0E3 		mov	r3, #1
 3179 0054 20300BE5 		str	r3, [fp, #-32]
1863:../CX3RDKOV5640.c ****     uartConfig.rxEnable = CyFalse;
 3180              		.loc 1 1863 0
 3181 0058 0030A0E3 		mov	r3, #0
 3182 005c 1C300BE5 		str	r3, [fp, #-28]
1864:../CX3RDKOV5640.c ****     uartConfig.flowCtrl = CyFalse;
 3183              		.loc 1 1864 0
 3184 0060 0030A0E3 		mov	r3, #0
 3185 0064 18300BE5 		str	r3, [fp, #-24]
1865:../CX3RDKOV5640.c ****     uartConfig.isDma = CyTrue;
 3186              		.loc 1 1865 0
 3187 0068 0130A0E3 		mov	r3, #1
 3188 006c 14300BE5 		str	r3, [fp, #-20]
1866:../CX3RDKOV5640.c **** 
1867:../CX3RDKOV5640.c ****     /* Set the UART configuration */
1868:../CX3RDKOV5640.c ****     status = CyU3PUartSetConfig (&uartConfig, NULL);
 3189              		.loc 1 1868 0
 3190 0070 20304BE2 		sub	r3, fp, #32
 3191 0074 0300A0E1 		mov	r0, r3
 3192 0078 0010A0E3 		mov	r1, #0
 3193 007c FEFFFFEB 		bl	CyU3PUartSetConfig
 3194 0080 08000BE5 		str	r0, [fp, #-8]
1869:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3195              		.loc 1 1869 0
 3196 0084 08301BE5 		ldr	r3, [fp, #-8]
 3197 0088 000053E3 		cmp	r3, #0
 3198 008c 0300000A 		beq	.L170
1870:../CX3RDKOV5640.c ****     {
1871:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\resUVCUvcApplnDebugInit:CyU3PUartSetConfig failed Error = 0x%x",sta
 3199              		.loc 1 1871 0
 3200 0090 0400A0E3 		mov	r0, #4
 3201 0094 70109FE5 		ldr	r1, .L173+8
 3202 0098 08201BE5 		ldr	r2, [fp, #-8]
 3203 009c FEFFFFEB 		bl	CyU3PDebugPrint
 3204              	.L170:
1872:../CX3RDKOV5640.c ****     }
1873:../CX3RDKOV5640.c **** 
1874:../CX3RDKOV5640.c ****     /* Set the UART transfer */
1875:../CX3RDKOV5640.c ****     status = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 3205              		.loc 1 1875 0
 3206 00a0 0000E0E3 		mvn	r0, #0
 3207 00a4 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 3208 00a8 08000BE5 		str	r0, [fp, #-8]
1876:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3209              		.loc 1 1876 0
 3210 00ac 08301BE5 		ldr	r3, [fp, #-8]
 3211 00b0 000053E3 		cmp	r3, #0
 3212 00b4 0300000A 		beq	.L171
1877:../CX3RDKOV5640.c ****     {
1878:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\resUVCUvcApplnDebugInit:CyU3PUartTxSetBlockXfer failed Error = 0x%x
 3213              		.loc 1 1878 0
 3214 00b8 0400A0E3 		mov	r0, #4
 3215 00bc 4C109FE5 		ldr	r1, .L173+12
 3216 00c0 08201BE5 		ldr	r2, [fp, #-8]
 3217 00c4 FEFFFFEB 		bl	CyU3PDebugPrint
 3218              	.L171:
1879:../CX3RDKOV5640.c ****     }
1880:../CX3RDKOV5640.c **** 
1881:../CX3RDKOV5640.c ****     /* Initialize the debug application */
1882:../CX3RDKOV5640.c ****     status = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 8);
 3219              		.loc 1 1882 0
 3220 00c8 0300A0E3 		mov	r0, #3
 3221 00cc 0810A0E3 		mov	r1, #8
 3222 00d0 FEFFFFEB 		bl	CyU3PDebugInit
 3223 00d4 08000BE5 		str	r0, [fp, #-8]
1883:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3224              		.loc 1 1883 0
 3225 00d8 08301BE5 		ldr	r3, [fp, #-8]
 3226 00dc 000053E3 		cmp	r3, #0
 3227 00e0 0300000A 		beq	.L172
1884:../CX3RDKOV5640.c ****     {
1885:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\resUVCUvcApplnDebugInit:CyU3PDebugInit failed Error = 0x%x",status)
 3228              		.loc 1 1885 0
 3229 00e4 0400A0E3 		mov	r0, #4
 3230 00e8 24109FE5 		ldr	r1, .L173+16
 3231 00ec 08201BE5 		ldr	r2, [fp, #-8]
 3232 00f0 FEFFFFEB 		bl	CyU3PDebugPrint
 3233              	.L172:
1886:../CX3RDKOV5640.c ****     }
1887:../CX3RDKOV5640.c ****     CyU3PDebugPreamble (CyFalse);
 3234              		.loc 1 1887 0
 3235 00f4 0000A0E3 		mov	r0, #0
 3236 00f8 FEFFFFEB 		bl	CyU3PDebugPreamble
1888:../CX3RDKOV5640.c **** 
1889:../CX3RDKOV5640.c **** }
 3237              		.loc 1 1889 0
 3238 00fc 04D04BE2 		sub	sp, fp, #4
 3239              		@ sp needed
 3240 0100 0088BDE8 		ldmfd	sp!, {fp, pc}
 3241              	.L174:
 3242              		.align	2
 3243              	.L173:
 3244 0104 FC060000 		.word	.LC45
 3245 0108 00C20100 		.word	115200
 3246 010c 38070000 		.word	.LC46
 3247 0110 78070000 		.word	.LC47
 3248 0114 C0070000 		.word	.LC48
 3249              		.cfi_endproc
 3250              	.LFE12:
 3252              		.section	.text.esUVCUvcAppThread_Entry,"ax",%progbits
 3253              		.align	2
 3254              		.global	esUVCUvcAppThread_Entry
 3256              	esUVCUvcAppThread_Entry:
 3257              	.LFB13:
1890:../CX3RDKOV5640.c **** 
1891:../CX3RDKOV5640.c **** /* Entry function for the UVC application thread. */
1892:../CX3RDKOV5640.c ****     void
1893:../CX3RDKOV5640.c **** esUVCUvcAppThread_Entry (
1894:../CX3RDKOV5640.c ****         uint32_t input)
1895:../CX3RDKOV5640.c **** {
 3258              		.loc 1 1895 0
 3259              		.cfi_startproc
 3260              		@ args = 0, pretend = 0, frame = 16
 3261              		@ frame_needed = 1, uses_anonymous_args = 0
 3262 0000 00482DE9 		stmfd	sp!, {fp, lr}
 3263              	.LCFI26:
 3264              		.cfi_def_cfa_offset 8
 3265              		.cfi_offset 11, -8
 3266              		.cfi_offset 14, -4
 3267 0004 04B08DE2 		add	fp, sp, #4
 3268              	.LCFI27:
 3269              		.cfi_def_cfa 11, 4
 3270 0008 18D04DE2 		sub	sp, sp, #24
 3271 000c 10000BE5 		str	r0, [fp, #-16]
1896:../CX3RDKOV5640.c ****     uint16_t wakeReason;
1897:../CX3RDKOV5640.c ****     uint32_t eventFlag;
1898:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status;
1899:../CX3RDKOV5640.c **** 
1900:../CX3RDKOV5640.c ****     /* Initialize the Debug Module */
1901:../CX3RDKOV5640.c ****     esUVCUvcApplnDebugInit();
 3272              		.loc 1 1901 0
 3273 0010 FEFFFFEB 		bl	esUVCUvcApplnDebugInit
1902:../CX3RDKOV5640.c **** 
1903:../CX3RDKOV5640.c ****     /* Initialize the UVC Application */
1904:../CX3RDKOV5640.c ****     esUVCUvcApplnInit();
 3274              		.loc 1 1904 0
 3275 0014 FEFFFFEB 		bl	esUVCUvcApplnInit
 3276              	.L181:
1905:../CX3RDKOV5640.c **** 
1906:../CX3RDKOV5640.c ****     for (;;)
1907:../CX3RDKOV5640.c ****     {
1908:../CX3RDKOV5640.c ****         CyU3PEventGet (&glTimerEvent,ES_USB_SUSP_EVENT_FLAG|ES_TIMER_RESET_EVENT, CYU3P_EVENT_OR_CL
 3277              		.loc 1 1908 0
 3278 0018 08304BE2 		sub	r3, fp, #8
 3279 001c 0020E0E3 		mvn	r2, #0
 3280 0020 00208DE5 		str	r2, [sp]
 3281 0024 A8009FE5 		ldr	r0, .L183
 3282 0028 3010A0E3 		mov	r1, #48
 3283 002c 0120A0E3 		mov	r2, #1
 3284 0030 FEFFFFEB 		bl	_txe_event_flags_get
1909:../CX3RDKOV5640.c **** 
1910:../CX3RDKOV5640.c ****         /* Handle TimerReset Event*/
1911:../CX3RDKOV5640.c ****         if( eventFlag & ES_TIMER_RESET_EVENT)
 3285              		.loc 1 1911 0
 3286 0034 08301BE5 		ldr	r3, [fp, #-8]
 3287 0038 103003E2 		and	r3, r3, #16
 3288 003c 000053E3 		cmp	r3, #0
 3289 0040 1700000A 		beq	.L176
1912:../CX3RDKOV5640.c ****         {
1913:../CX3RDKOV5640.c ****             if (glIsApplnActive)
 3290              		.loc 1 1913 0
 3291 0044 8C309FE5 		ldr	r3, .L183+4
 3292 0048 003093E5 		ldr	r3, [r3]
 3293 004c 000053E3 		cmp	r3, #0
 3294 0050 0300000A 		beq	.L177
1914:../CX3RDKOV5640.c ****             {
1915:../CX3RDKOV5640.c ****             	glIsClearFeature = CyFalse;
 3295              		.loc 1 1915 0
 3296 0054 80309FE5 		ldr	r3, .L183+8
 3297 0058 0020A0E3 		mov	r2, #0
 3298 005c 002083E5 		str	r2, [r3]
1916:../CX3RDKOV5640.c ****                 esUVCUvcApplnStop();
 3299              		.loc 1 1916 0
 3300 0060 FEFFFFEB 		bl	esUVCUvcApplnStop
 3301              	.L177:
1917:../CX3RDKOV5640.c **** #ifdef VISDebug
1918:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rES_TIMER_RESET_EVENT: esUVCUvcApplnStop");
1919:../CX3RDKOV5640.c **** #endif
1920:../CX3RDKOV5640.c ****             }
1921:../CX3RDKOV5640.c ****             if(glPreviewStarted == CyTrue)
 3302              		.loc 1 1921 0
 3303 0064 74309FE5 		ldr	r3, .L183+12
 3304 0068 003093E5 		ldr	r3, [r3]
 3305 006c 010053E3 		cmp	r3, #1
 3306 0070 0700001A 		bne	.L178
1922:../CX3RDKOV5640.c ****             {
1923:../CX3RDKOV5640.c ****             	//TODO Change this function with "Sensor Specific" function to write the sensor settin
1924:../CX3RDKOV5640.c ****             	esSetCameraResolution(glFrameIndexToSet);
 3307              		.loc 1 1924 0
 3308 0074 68309FE5 		ldr	r3, .L183+16
 3309 0078 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 3310 007c 0300A0E1 		mov	r0, r3
 3311 0080 FEFFFFEB 		bl	esSetCameraResolution
1925:../CX3RDKOV5640.c ****             	esUVCUvcApplnStart();
 3312              		.loc 1 1925 0
 3313 0084 FEFFFFEB 		bl	esUVCUvcApplnStart
1926:../CX3RDKOV5640.c ****             	SensorGetControl(0x02, 0x30); //using this statement to start the video by microcode.
 3314              		.loc 1 1926 0
 3315 0088 0200A0E3 		mov	r0, #2
 3316 008c 3010A0E3 		mov	r1, #48
 3317 0090 FEFFFFEB 		bl	SensorGetControl
 3318              	.L178:
1927:../CX3RDKOV5640.c **** #ifdef VISDebug
1928:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rES_TIMER_RESET_EVENT: esUVCUvcApplnStart");
1929:../CX3RDKOV5640.c **** #endif
1930:../CX3RDKOV5640.c ****             }
1931:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
1932:../CX3RDKOV5640.c ****             CyU3PTimerModify (&UvcTimer, TIMER_PERIOD, 0);
 3319              		.loc 1 1932 0
 3320 0094 4C009FE5 		ldr	r0, .L183+20
 3321 0098 7D1FA0E3 		mov	r1, #500
 3322 009c 0020A0E3 		mov	r2, #0
 3323 00a0 FEFFFFEB 		bl	_txe_timer_change
 3324              	.L176:
1933:../CX3RDKOV5640.c **** #endif
1934:../CX3RDKOV5640.c ****         }
1935:../CX3RDKOV5640.c ****         /* Handle Suspend Event*/
1936:../CX3RDKOV5640.c ****         if(eventFlag & ES_USB_SUSP_EVENT_FLAG)
 3325              		.loc 1 1936 0
 3326 00a4 08301BE5 		ldr	r3, [fp, #-8]
 3327 00a8 203003E2 		and	r3, r3, #32
 3328 00ac 000053E3 		cmp	r3, #0
 3329 00b0 0600000A 		beq	.L179
1937:../CX3RDKOV5640.c ****         {
1938:../CX3RDKOV5640.c ****             /* Place CX3 in Low Power Suspend mode, with USB bus activity as the wakeup source. */
1939:../CX3RDKOV5640.c ****             //CyU3PMipicsiSleep();
1940:../CX3RDKOV5640.c ****             //TODO Change this function with "Sensor Specific" PowerDown function to PowerDown the 
1941:../CX3RDKOV5640.c ****             //esCamera_Power_Down();
1942:../CX3RDKOV5640.c **** 
1943:../CX3RDKOV5640.c ****             //status = CyU3PSysEnterSuspendMode (CY_U3P_SYS_USB_BUS_ACTVTY_WAKEUP_SRC, 0, &wakeReas
1944:../CX3RDKOV5640.c **** #ifdef VISDebug
1945:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rES_USB_SUSP_EVENT_FLAG %x", status);
1946:../CX3RDKOV5640.c **** #endif
1947:../CX3RDKOV5640.c ****     		if(glMipiActive)
 3330              		.loc 1 1947 0
 3331 00b4 30309FE5 		ldr	r3, .L183+24
 3332 00b8 003093E5 		ldr	r3, [r3]
 3333 00bc 000053E3 		cmp	r3, #0
 3334 00c0 0100000A 		beq	.L180
1948:../CX3RDKOV5640.c ****             {
1949:../CX3RDKOV5640.c ****                 CyU3PMipicsiWakeup();
 3335              		.loc 1 1949 0
 3336 00c4 FEFFFFEB 		bl	CyU3PMipicsiWakeup
1950:../CX3RDKOV5640.c ****                 //TODO Change this function with "Sensor Specific" PowerUp function to PowerUp the 
1951:../CX3RDKOV5640.c ****                 //esCamera_Power_Up();  // remove the camera operations function for VIS mipi camer
1952:../CX3RDKOV5640.c **** #ifdef VISDebug
1953:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rES_USB_SUSP_EVENT_FLAG: esCamera_Power_Up");
1954:../CX3RDKOV5640.c **** #endif
1955:../CX3RDKOV5640.c ****             }
1956:../CX3RDKOV5640.c ****             continue;
 3337              		.loc 1 1956 0
 3338 00c8 FFFFFFEA 		b	.L182
 3339              	.L180:
 3340              	.L182:
 3341 00cc 0000A0E1 		mov	r0, r0	@ nop
 3342              	.L179:
1957:../CX3RDKOV5640.c ****         }
1958:../CX3RDKOV5640.c **** #ifdef VISDebug
1959:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rApp Thread Loop");
1960:../CX3RDKOV5640.c **** #endif
1961:../CX3RDKOV5640.c ****     } /* End of for(;;) */
 3343              		.loc 1 1961 0
 3344 00d0 D0FFFFEA 		b	.L181
 3345              	.L184:
 3346              		.align	2
 3347              	.L183:
 3348 00d4 00000000 		.word	glTimerEvent
 3349 00d8 00000000 		.word	glIsApplnActive
 3350 00dc 00000000 		.word	glIsClearFeature
 3351 00e0 00000000 		.word	glPreviewStarted
 3352 00e4 00000000 		.word	glFrameIndexToSet
 3353 00e8 00000000 		.word	UvcTimer
 3354 00ec 00000000 		.word	glMipiActive
 3355              		.cfi_endproc
 3356              	.LFE13:
 3358              		.section	.rodata
 3359              		.align	2
 3360              	.LC49:
 3361 07fc 53656E43 		.ascii	"SenCmdQue\000"
 3361      6D645175 
 3361      6500
 3362 0806 0000     		.align	2
 3363              	.LC50:
 3364 0808 53656E53 		.ascii	"SenStatQue\000"
 3364      74617451 
 3364      756500
 3365 0813 00       		.align	2
 3366              	.LC51:
 3367 0814 33303A55 		.ascii	"30:UVC_app_thread\000"
 3367      56435F61 
 3367      70705F74 
 3367      68726561 
 3367      6400
 3368 0826 0000     		.align	2
 3369              	.LC52:
 3370 0828 33313A53 		.ascii	"31:Sen_ctrl_thread\000"
 3370      656E5F63 
 3370      74726C5F 
 3370      74687265 
 3370      616400
 3371 083b 00       		.section	.text.CyFxApplicationDefine,"ax",%progbits
 3372              		.align	2
 3373              		.global	CyFxApplicationDefine
 3375              	CyFxApplicationDefine:
 3376              	.LFB14:
1962:../CX3RDKOV5640.c **** }
1963:../CX3RDKOV5640.c **** 
1964:../CX3RDKOV5640.c **** 
1965:../CX3RDKOV5640.c **** /* Application define function which creates the threads. */
1966:../CX3RDKOV5640.c ****     void
1967:../CX3RDKOV5640.c **** CyFxApplicationDefine (
1968:../CX3RDKOV5640.c ****         void)
1969:../CX3RDKOV5640.c **** {
 3377              		.loc 1 1969 0
 3378              		.cfi_startproc
 3379              		@ args = 0, pretend = 0, frame = 64
 3380              		@ frame_needed = 1, uses_anonymous_args = 0
 3381 0000 10482DE9 		stmfd	sp!, {r4, fp, lr}
 3382              	.LCFI28:
 3383              		.cfi_def_cfa_offset 12
 3384              		.cfi_offset 4, -12
 3385              		.cfi_offset 11, -8
 3386              		.cfi_offset 14, -4
 3387 0004 08B08DE2 		add	fp, sp, #8
 3388              	.LCFI29:
 3389              		.cfi_def_cfa 11, 4
 3390 0008 64D04DE2 		sub	sp, sp, #100
1970:../CX3RDKOV5640.c ****     void *ptrUvc = NULL, *ptrSen = NULL;
 3391              		.loc 1 1970 0
 3392 000c 0030A0E3 		mov	r3, #0
 3393 0010 10300BE5 		str	r3, [fp, #-16]
 3394 0014 0030A0E3 		mov	r3, #0
 3395 0018 14300BE5 		str	r3, [fp, #-20]
1971:../CX3RDKOV5640.c ****     uint32_t retThrdCreate = CY_U3P_SUCCESS;
 3396              		.loc 1 1971 0
 3397 001c 0030A0E3 		mov	r3, #0
 3398 0020 18300BE5 		str	r3, [fp, #-24]
1972:../CX3RDKOV5640.c ****     VdRingBuf *cmdQuptr = &cmdQu, *statQuptr = &statQu;
 3399              		.loc 1 1972 0
 3400 0024 60319FE5 		ldr	r3, .L192
 3401 0028 1C300BE5 		str	r3, [fp, #-28]
 3402 002c 5C319FE5 		ldr	r3, .L192+4
 3403 0030 20300BE5 		str	r3, [fp, #-32]
1973:../CX3RDKOV5640.c ****     /* Create/initialize Ring buffers for Sensor control */
1974:../CX3RDKOV5640.c ****     char *cmdName = "SenCmdQue", *StatName = "SenStatQue";
 3404              		.loc 1 1974 0
 3405 0034 58319FE5 		ldr	r3, .L192+8
 3406 0038 24300BE5 		str	r3, [fp, #-36]
 3407 003c 54319FE5 		ldr	r3, .L192+12
 3408 0040 28300BE5 		str	r3, [fp, #-40]
1975:../CX3RDKOV5640.c ****     cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 3409              		.loc 1 1975 0
 3410 0044 40419FE5 		ldr	r4, .L192
 3411 0048 4C304BE2 		sub	r3, fp, #76
 3412 004c 48219FE5 		ldr	r2, .L192+16
 3413 0050 00208DE5 		str	r2, [sp]
 3414 0054 0300A0E1 		mov	r0, r3
 3415 0058 4010A0E3 		mov	r1, #64
 3416 005c 24201BE5 		ldr	r2, [fp, #-36]
 3417 0060 0030A0E3 		mov	r3, #0
 3418 0064 FEFFFFEB 		bl	cmdbufCreate
 3419 0068 04C0A0E1 		mov	ip, r4
 3420 006c 4CE04BE2 		sub	lr, fp, #76
 3421 0070 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 3422 0074 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 3423 0078 0F009EE8 		ldmia	lr, {r0, r1, r2, r3}
 3424 007c 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
1976:../CX3RDKOV5640.c **** 	cmdquInit(cmdQuptr);
 3425              		.loc 1 1976 0
 3426 0080 1C001BE5 		ldr	r0, [fp, #-28]
 3427 0084 FEFFFFEB 		bl	cmdquInit
1977:../CX3RDKOV5640.c **** 
1978:../CX3RDKOV5640.c ****     /* Allocate the memory for the thread and create the thread */
1979:../CX3RDKOV5640.c ****     ptrUvc = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 3428              		.loc 1 1979 0
 3429 0088 010AA0E3 		mov	r0, #4096
 3430 008c FEFFFFEB 		bl	CyU3PMemAlloc
 3431 0090 10000BE5 		str	r0, [fp, #-16]
1980:../CX3RDKOV5640.c ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 3432              		.loc 1 1980 0
 3433 0094 10301BE5 		ldr	r3, [fp, #-16]
 3434 0098 00308DE5 		str	r3, [sp]
 3435 009c 013AA0E3 		mov	r3, #4096
 3436 00a0 04308DE5 		str	r3, [sp, #4]
 3437 00a4 0830A0E3 		mov	r3, #8
 3438 00a8 08308DE5 		str	r3, [sp, #8]
 3439 00ac 0830A0E3 		mov	r3, #8
 3440 00b0 0C308DE5 		str	r3, [sp, #12]
 3441 00b4 0030A0E3 		mov	r3, #0
 3442 00b8 10308DE5 		str	r3, [sp, #16]
 3443 00bc 0130A0E3 		mov	r3, #1
 3444 00c0 14308DE5 		str	r3, [sp, #20]
 3445 00c4 A830A0E3 		mov	r3, #168
 3446 00c8 18308DE5 		str	r3, [sp, #24]
 3447 00cc CC009FE5 		ldr	r0, .L192+20
 3448 00d0 CC109FE5 		ldr	r1, .L192+24
 3449 00d4 CC209FE5 		ldr	r2, .L192+28
 3450 00d8 0030A0E3 		mov	r3, #0
 3451 00dc FEFFFFEB 		bl	_txe_thread_create
 3452 00e0 18000BE5 		str	r0, [fp, #-24]
1981:../CX3RDKOV5640.c ****             "30:UVC_app_thread",         /* Thread Id and name */
1982:../CX3RDKOV5640.c ****             esUVCUvcAppThread_Entry,          /* UVC Application Thread Entry function */
1983:../CX3RDKOV5640.c ****             0,                           /* No input parameter to thread */
1984:../CX3RDKOV5640.c ****             ptrUvc,                         /* Pointer to the allocated thread stack */
1985:../CX3RDKOV5640.c ****             UVC_APP_THREAD_STACK,        /* UVC Application Thread stack size */
1986:../CX3RDKOV5640.c ****             UVC_APP_THREAD_PRIORITY,     /* UVC Application Thread priority */
1987:../CX3RDKOV5640.c ****             UVC_APP_THREAD_PRIORITY,     /* Pre-emption threshold */
1988:../CX3RDKOV5640.c ****             CYU3P_NO_TIME_SLICE,         /* No time slice for the application thread */
1989:../CX3RDKOV5640.c ****             CYU3P_AUTO_START             /* Start the Thread immediately */
1990:../CX3RDKOV5640.c ****             );
1991:../CX3RDKOV5640.c **** 
1992:../CX3RDKOV5640.c ****     /* Check the return code */
1993:../CX3RDKOV5640.c ****     if (retThrdCreate != 0)
 3453              		.loc 1 1993 0
 3454 00e4 18301BE5 		ldr	r3, [fp, #-24]
 3455 00e8 000053E3 		cmp	r3, #0
 3456 00ec 0000000A 		beq	.L186
 3457              	.L187:
1994:../CX3RDKOV5640.c ****     {
1995:../CX3RDKOV5640.c ****         /* Thread Creation failed with the error code retThrdCreate */
1996:../CX3RDKOV5640.c **** 
1997:../CX3RDKOV5640.c ****         /* Add custom recovery or debug actions here */
1998:../CX3RDKOV5640.c **** 
1999:../CX3RDKOV5640.c ****         /* Application cannot continue */
2000:../CX3RDKOV5640.c ****         /* Loop indefinitely */
2001:../CX3RDKOV5640.c ****         while(1);
 3458              		.loc 1 2001 0 discriminator 1
 3459 00f0 FEFFFFEA 		b	.L187
 3460              	.L186:
2002:../CX3RDKOV5640.c ****     }
2003:../CX3RDKOV5640.c **** 
2004:../CX3RDKOV5640.c ****     ptrSen = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 3461              		.loc 1 2004 0
 3462 00f4 010AA0E3 		mov	r0, #4096
 3463 00f8 FEFFFFEB 		bl	CyU3PMemAlloc
 3464 00fc 14000BE5 		str	r0, [fp, #-20]
2005:../CX3RDKOV5640.c ****     retThrdCreate = CyU3PThreadCreate (&SenAppThread,   /* UVC Thread structure */
 3465              		.loc 1 2005 0
 3466 0100 14301BE5 		ldr	r3, [fp, #-20]
 3467 0104 00308DE5 		str	r3, [sp]
 3468 0108 013AA0E3 		mov	r3, #4096
 3469 010c 04308DE5 		str	r3, [sp, #4]
 3470 0110 0830A0E3 		mov	r3, #8
 3471 0114 08308DE5 		str	r3, [sp, #8]
 3472 0118 0830A0E3 		mov	r3, #8
 3473 011c 0C308DE5 		str	r3, [sp, #12]
 3474 0120 0030A0E3 		mov	r3, #0
 3475 0124 10308DE5 		str	r3, [sp, #16]
 3476 0128 0130A0E3 		mov	r3, #1
 3477 012c 14308DE5 		str	r3, [sp, #20]
 3478 0130 A830A0E3 		mov	r3, #168
 3479 0134 18308DE5 		str	r3, [sp, #24]
 3480 0138 6C009FE5 		ldr	r0, .L192+32
 3481 013c 6C109FE5 		ldr	r1, .L192+36
 3482 0140 6C209FE5 		ldr	r2, .L192+40
 3483 0144 0030A0E3 		mov	r3, #0
 3484 0148 FEFFFFEB 		bl	_txe_thread_create
 3485 014c 18000BE5 		str	r0, [fp, #-24]
2006:../CX3RDKOV5640.c ****             "31:Sen_ctrl_thread",         /* Thread Id and name */
2007:../CX3RDKOV5640.c ****             SenAppThread_Entry,          /* UVC Application Thread Entry function */
2008:../CX3RDKOV5640.c ****             0,                           /* No input parameter to thread */
2009:../CX3RDKOV5640.c ****             ptrSen,                         /* Pointer to the allocated thread stack */
2010:../CX3RDKOV5640.c ****             UVC_APP_THREAD_STACK,        /* UVC Application Thread stack size */
2011:../CX3RDKOV5640.c ****             UVC_APP_THREAD_PRIORITY,     /* UVC Application Thread priority */
2012:../CX3RDKOV5640.c ****             UVC_APP_THREAD_PRIORITY,     /* Pre-emption threshold */
2013:../CX3RDKOV5640.c ****             CYU3P_NO_TIME_SLICE,         /* No time slice for the application thread */
2014:../CX3RDKOV5640.c ****             CYU3P_AUTO_START             /* Start the Thread immediately */
2015:../CX3RDKOV5640.c ****             );
2016:../CX3RDKOV5640.c **** 
2017:../CX3RDKOV5640.c ****     /* Check the return code */
2018:../CX3RDKOV5640.c ****     if (retThrdCreate != 0)
 3486              		.loc 1 2018 0
 3487 0150 18301BE5 		ldr	r3, [fp, #-24]
 3488 0154 000053E3 		cmp	r3, #0
 3489 0158 0000000A 		beq	.L188
 3490              	.L189:
2019:../CX3RDKOV5640.c ****     {
2020:../CX3RDKOV5640.c ****         /* Thread Creation failed with the error code retThrdCreate */
2021:../CX3RDKOV5640.c **** 
2022:../CX3RDKOV5640.c ****         /* Add custom recovery or debug actions here */
2023:../CX3RDKOV5640.c **** 
2024:../CX3RDKOV5640.c ****         /* Application cannot continue */
2025:../CX3RDKOV5640.c ****         /* Loop indefinitely */
2026:../CX3RDKOV5640.c ****         while(1);
 3491              		.loc 1 2026 0 discriminator 1
 3492 015c FEFFFFEA 		b	.L189
 3493              	.L188:
2027:../CX3RDKOV5640.c ****     }
2028:../CX3RDKOV5640.c ****     /* Create GPIO application event group */
2029:../CX3RDKOV5640.c ****     retThrdCreate = CyU3PEventCreate(&glTimerEvent);
 3494              		.loc 1 2029 0
 3495 0160 50009FE5 		ldr	r0, .L192+44
 3496 0164 0010A0E3 		mov	r1, #0
 3497 0168 2820A0E3 		mov	r2, #40
 3498 016c FEFFFFEB 		bl	_txe_event_flags_create
 3499 0170 18000BE5 		str	r0, [fp, #-24]
2030:../CX3RDKOV5640.c ****     if (retThrdCreate != 0)
 3500              		.loc 1 2030 0
 3501 0174 18301BE5 		ldr	r3, [fp, #-24]
 3502 0178 000053E3 		cmp	r3, #0
 3503 017c 0000000A 		beq	.L185
 3504              	.L191:
2031:../CX3RDKOV5640.c ****     {
2032:../CX3RDKOV5640.c ****         /* Event group creation failed with the error code retThrdCreate */
2033:../CX3RDKOV5640.c **** 
2034:../CX3RDKOV5640.c ****         /* Add custom recovery or debug actions here */
2035:../CX3RDKOV5640.c **** 
2036:../CX3RDKOV5640.c ****         /* Application cannot continue */
2037:../CX3RDKOV5640.c ****         /* Loop indefinitely */
2038:../CX3RDKOV5640.c ****         while(1);
 3505              		.loc 1 2038 0 discriminator 1
 3506 0180 FEFFFFEA 		b	.L191
 3507              	.L185:
2039:../CX3RDKOV5640.c ****     }
2040:../CX3RDKOV5640.c **** }
 3508              		.loc 1 2040 0
 3509 0184 08D04BE2 		sub	sp, fp, #8
 3510              		@ sp needed
 3511 0188 1088BDE8 		ldmfd	sp!, {r4, fp, pc}
 3512              	.L193:
 3513              		.align	2
 3514              	.L192:
 3515 018c 00000000 		.word	cmdQu
 3516 0190 00000000 		.word	statQu
 3517 0194 FC070000 		.word	.LC49
 3518 0198 08080000 		.word	.LC50
 3519 019c 00000000 		.word	cmdQuMux
 3520 01a0 00000000 		.word	uvcAppThread
 3521 01a4 14080000 		.word	.LC51
 3522 01a8 00000000 		.word	esUVCUvcAppThread_Entry
 3523 01ac 00000000 		.word	SenAppThread
 3524 01b0 28080000 		.word	.LC52
 3525 01b4 00000000 		.word	SenAppThread_Entry
 3526 01b8 00000000 		.word	glTimerEvent
 3527              		.cfi_endproc
 3528              	.LFE14:
 3530              		.section	.text.main,"ax",%progbits
 3531              		.align	2
 3532              		.global	main
 3534              	main:
 3535              	.LFB15:
2041:../CX3RDKOV5640.c **** 
2042:../CX3RDKOV5640.c **** /*
2043:../CX3RDKOV5640.c ****  * Main function
2044:../CX3RDKOV5640.c ****  */
2045:../CX3RDKOV5640.c **** 
2046:../CX3RDKOV5640.c ****     int
2047:../CX3RDKOV5640.c **** main (void)
2048:../CX3RDKOV5640.c **** {
 3536              		.loc 1 2048 0
 3537              		.cfi_startproc
 3538              		@ args = 0, pretend = 0, frame = 48
 3539              		@ frame_needed = 1, uses_anonymous_args = 0
 3540 0000 00482DE9 		stmfd	sp!, {fp, lr}
 3541              	.LCFI30:
 3542              		.cfi_def_cfa_offset 8
 3543              		.cfi_offset 11, -8
 3544              		.cfi_offset 14, -4
 3545 0004 04B08DE2 		add	fp, sp, #4
 3546              	.LCFI31:
 3547              		.cfi_def_cfa 11, 4
 3548 0008 30D04DE2 		sub	sp, sp, #48
2049:../CX3RDKOV5640.c ****     CyU3PIoMatrixConfig_t io_cfg;
2050:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 3549              		.loc 1 2050 0
 3550 000c 0030A0E3 		mov	r3, #0
 3551 0010 08300BE5 		str	r3, [fp, #-8]
2051:../CX3RDKOV5640.c **** 
2052:../CX3RDKOV5640.c ****     /* Initialize the device */
2053:../CX3RDKOV5640.c ****     status = CyU3PDeviceInit (NULL);
 3552              		.loc 1 2053 0
 3553 0014 0000A0E3 		mov	r0, #0
 3554 0018 FEFFFFEB 		bl	CyU3PDeviceInit
 3555 001c 08000BE5 		str	r0, [fp, #-8]
2054:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3556              		.loc 1 2054 0
 3557 0020 08301BE5 		ldr	r3, [fp, #-8]
 3558 0024 000053E3 		cmp	r3, #0
 3559 0028 0000000A 		beq	.L195
2055:../CX3RDKOV5640.c ****     {
2056:../CX3RDKOV5640.c ****         goto handle_fatal_error;
 3560              		.loc 1 2056 0
 3561 002c 270000EA 		b	.L196
 3562              	.L195:
2057:../CX3RDKOV5640.c ****     }
2058:../CX3RDKOV5640.c **** 
2059:../CX3RDKOV5640.c ****     /* Initialize the caches. Enable instruction cache and keep data cache disabled.
2060:../CX3RDKOV5640.c ****      * The data cache is useful only when there is a large amount of CPU based memory
2061:../CX3RDKOV5640.c ****      * accesses. When used in simple cases, it can decrease performance due to large
2062:../CX3RDKOV5640.c ****      * number of cache flushes and cleans and also it adds to the complexity of the
2063:../CX3RDKOV5640.c ****      * code. */
2064:../CX3RDKOV5640.c ****     status = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 3563              		.loc 1 2064 0
 3564 0030 0100A0E3 		mov	r0, #1
 3565 0034 0010A0E3 		mov	r1, #0
 3566 0038 0020A0E3 		mov	r2, #0
 3567 003c FEFFFFEB 		bl	CyU3PDeviceCacheControl
 3568 0040 08000BE5 		str	r0, [fp, #-8]
2065:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3569              		.loc 1 2065 0
 3570 0044 08301BE5 		ldr	r3, [fp, #-8]
 3571 0048 000053E3 		cmp	r3, #0
 3572 004c 0000000A 		beq	.L197
2066:../CX3RDKOV5640.c ****     {
2067:../CX3RDKOV5640.c ****         goto handle_fatal_error;
 3573              		.loc 1 2067 0
 3574 0050 1E0000EA 		b	.L196
 3575              	.L197:
2068:../CX3RDKOV5640.c ****     }
2069:../CX3RDKOV5640.c **** 
2070:../CX3RDKOV5640.c ****     /* Configure the IO matrix for the device.*/
2071:../CX3RDKOV5640.c ****     io_cfg.isDQ32Bit = CyFalse;
 3576              		.loc 1 2071 0
 3577 0054 0030A0E3 		mov	r3, #0
 3578 0058 30300BE5 		str	r3, [fp, #-48]
2072:../CX3RDKOV5640.c **** 
2073:../CX3RDKOV5640.c ****     io_cfg.useUart   = CyTrue;
 3579              		.loc 1 2073 0
 3580 005c 0130A0E3 		mov	r3, #1
 3581 0060 2C300BE5 		str	r3, [fp, #-44]
2074:../CX3RDKOV5640.c ****     io_cfg.useI2C    = CyTrue;
 3582              		.loc 1 2074 0
 3583 0064 0130A0E3 		mov	r3, #1
 3584 0068 28300BE5 		str	r3, [fp, #-40]
2075:../CX3RDKOV5640.c ****     io_cfg.useI2S    = CyFalse;
 3585              		.loc 1 2075 0
 3586 006c 0030A0E3 		mov	r3, #0
 3587 0070 24300BE5 		str	r3, [fp, #-36]
2076:../CX3RDKOV5640.c ****     io_cfg.useSpi    = CyFalse;
 3588              		.loc 1 2076 0
 3589 0074 0030A0E3 		mov	r3, #0
 3590 0078 20300BE5 		str	r3, [fp, #-32]
2077:../CX3RDKOV5640.c ****     io_cfg.lppMode   = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 3591              		.loc 1 2077 0
 3592 007c 0030A0E3 		mov	r3, #0
 3593 0080 1A304BE5 		strb	r3, [fp, #-26]
2078:../CX3RDKOV5640.c ****     /* No GPIOs are enabled. */
2079:../CX3RDKOV5640.c ****     io_cfg.gpioSimpleEn[0]  = 0;
 3594              		.loc 1 2079 0
 3595 0084 0030A0E3 		mov	r3, #0
 3596 0088 18300BE5 		str	r3, [fp, #-24]
2080:../CX3RDKOV5640.c ****     io_cfg.gpioSimpleEn[1]  = 0;
 3597              		.loc 1 2080 0
 3598 008c 0030A0E3 		mov	r3, #0
 3599 0090 14300BE5 		str	r3, [fp, #-20]
2081:../CX3RDKOV5640.c ****     io_cfg.gpioComplexEn[0] = 0;
 3600              		.loc 1 2081 0
 3601 0094 0030A0E3 		mov	r3, #0
 3602 0098 10300BE5 		str	r3, [fp, #-16]
2082:../CX3RDKOV5640.c ****     io_cfg.gpioComplexEn[1] = 0;
 3603              		.loc 1 2082 0
 3604 009c 0030A0E3 		mov	r3, #0
 3605 00a0 0C300BE5 		str	r3, [fp, #-12]
2083:../CX3RDKOV5640.c ****     status = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 3606              		.loc 1 2083 0
 3607 00a4 30304BE2 		sub	r3, fp, #48
 3608 00a8 0300A0E1 		mov	r0, r3
 3609 00ac FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 3610 00b0 08000BE5 		str	r0, [fp, #-8]
2084:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3611              		.loc 1 2084 0
 3612 00b4 08301BE5 		ldr	r3, [fp, #-8]
 3613 00b8 000053E3 		cmp	r3, #0
 3614 00bc 0000000A 		beq	.L198
2085:../CX3RDKOV5640.c ****     {
2086:../CX3RDKOV5640.c ****         goto handle_fatal_error;
 3615              		.loc 1 2086 0
 3616 00c0 020000EA 		b	.L196
 3617              	.L198:
2087:../CX3RDKOV5640.c ****     }
2088:../CX3RDKOV5640.c **** 
2089:../CX3RDKOV5640.c ****     /* This is a non returnable call for initializing the RTOS kernel */
2090:../CX3RDKOV5640.c ****     CyU3PKernelEntry ();
 3618              		.loc 1 2090 0
 3619 00c4 FEFFFFEB 		bl	_tx_initialize_kernel_enter
2091:../CX3RDKOV5640.c **** 
2092:../CX3RDKOV5640.c ****     /* Dummy return to make the compiler happy */
2093:../CX3RDKOV5640.c ****     return 0;
 3620              		.loc 1 2093 0
 3621 00c8 0030A0E3 		mov	r3, #0
 3622 00cc 000000EA 		b	.L200
 3623              	.L196:
2094:../CX3RDKOV5640.c **** 
2095:../CX3RDKOV5640.c **** handle_fatal_error:
2096:../CX3RDKOV5640.c ****     /* Cannot recover from this error. */
2097:../CX3RDKOV5640.c ****     while (1);
 3624              		.loc 1 2097 0 discriminator 1
 3625 00d0 FEFFFFEA 		b	.L196
 3626              	.L200:
2098:../CX3RDKOV5640.c **** }
 3627              		.loc 1 2098 0
 3628 00d4 0300A0E1 		mov	r0, r3
 3629 00d8 04D04BE2 		sub	sp, fp, #4
 3630              		@ sp needed
 3631 00dc 0088BDE8 		ldmfd	sp!, {fp, pc}
 3632              		.cfi_endproc
 3633              	.LFE15:
 3635              		.text
 3636              	.Letext0:
 3637              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 3638              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/cyu3ty
 3639              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/cyfx3_
 3640              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/tx_por
 3641              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/tx_api
 3642              		.file 7 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/cyu3dm
 3643              		.file 8 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/cyu3er
 3644              		.file 9 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/cyu3us
 3645              		.file 10 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/cyu3u
 3646              		.file 11 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/cyu3u
 3647              		.file 12 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/cyu3g
 3648              		.file 13 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/cyu3m
 3649              		.file 14 "../cmdqu.h"
 3650              		.file 15 "../CX3RDKOV5640.h"
DEFINED SYMBOLS
                            *ABS*:00000000 CX3RDKOV5640.c
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:17     .bss.glEp0Buffer:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:20     .bss.glEp0Buffer:00000000 glEp0Buffer
                            *COM*:000000a8 uvcAppThread
                            *COM*:000000a8 SenAppThread
                            *COM*:00000028 glTimerEvent
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 statQuMux
                            *COM*:00000038 timMux
                            *COM*:00000038 imgHdMux
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:32     .bss.UvcTimer:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:35     .bss.UvcTimer:00000000 UvcTimer
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:38     .text.UvcAppProgressTimer:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:40     .text.UvcAppProgressTimer:00000000 UvcAppProgressTimer
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:69     .text.UvcAppProgressTimer:00000028 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:78     .bss.glDMATxCount:00000000 glDMATxCount
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:75     .bss.glDMATxCount:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:85     .bss.glDmaDone:00000000 glDmaDone
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:82     .bss.glDmaDone:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:91     .bss.glActiveSocket:00000000 glActiveSocket
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:92     .bss.glActiveSocket:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:98     .data.doLpmDisable:00000000 doLpmDisable
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:95     .data.doLpmDisable:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:105    .bss.glHitFV:00000000 glHitFV
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:102    .bss.glHitFV:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:112    .bss.glMipiActive:00000000 glMipiActive
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:109    .bss.glMipiActive:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:119    .bss.glIsClearFeature:00000000 glIsClearFeature
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:116    .bss.glIsClearFeature:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:126    .bss.glPreviewStarted:00000000 glPreviewStarted
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:123    .bss.glPreviewStarted:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:133    .data.glUVCHeader:00000000 glUVCHeader
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:130    .data.glUVCHeader:00000000 $d
                            *COM*:00000020 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:151    .data.glCurrentFrameIndex:00000000 glCurrentFrameIndex
                            *COM*:00000020 glStillCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:158    .data.glCurrentStillFrameIndex:00000000 glCurrentStillFrameIndex
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:164    .bss.glStillTriggerCtrl:00000000 glStillTriggerCtrl
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:165    .bss.glStillTriggerCtrl:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:170    .bss.glFrameIndexToSet:00000000 glFrameIndexToSet
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:171    .bss.glFrameIndexToSet:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:177    .bss.glStillCaptureStart:00000000 glStillCaptureStart
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:174    .bss.glStillCaptureStart:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:184    .bss.glStillCaptured:00000000 glStillCaptured
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:181    .bss.glStillCaptured:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:190    .bss.glStillSkip:00000000 glStillSkip
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:191    .bss.glStillSkip:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:197    .bss.glIsApplnActive:00000000 glIsApplnActive
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:194    .bss.glIsApplnActive:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:204    .bss.glIsConfigured:00000000 glIsConfigured
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:201    .bss.glIsConfigured:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:211    .bss.glIsStreamingStarted:00000000 glIsStreamingStarted
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:208    .bss.glIsStreamingStarted:00000000 $d
                            *COM*:000000e8 glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:219    .bss.ES_UVC_STREAM_BUF_SIZE:00000000 ES_UVC_STREAM_BUF_SIZE
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:216    .bss.ES_UVC_STREAM_BUF_SIZE:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:226    .bss.ES_UVC_DATA_BUF_SIZE:00000000 ES_UVC_DATA_BUF_SIZE
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:223    .bss.ES_UVC_DATA_BUF_SIZE:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:232    .bss.ES_UVC_STREAM_BUF_COUNT:00000000 ES_UVC_STREAM_BUF_COUNT
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:233    .bss.ES_UVC_STREAM_BUF_COUNT:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:238    .data.g_IsAutoFocus:00000000 g_IsAutoFocus
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:244    .bss.glGet_Info:00000000 glGet_Info
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:245    .bss.glGet_Info:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:251    .bss.gl8GetControl:00000000 gl8GetControl
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:248    .bss.gl8GetControl:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:258    .bss.gl8SetControl:00000000 gl8SetControl
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:255    .bss.gl8SetControl:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:265    .bss.gl16GetControl:00000000 gl16GetControl
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:262    .bss.gl16GetControl:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:272    .bss.gl32GetControl:00000000 gl32GetControl
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:269    .bss.gl32GetControl:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:278    .bss.glcommitcount:00000000 glcommitcount
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:279    .bss.glcommitcount:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:284    .data.glcheckframe:00000000 glcheckframe
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:287    .text.esUVCAppErrorHandler:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:290    .text.esUVCAppErrorHandler:00000000 esUVCAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:316    .text.esUVCUvcAddHeader:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:318    .text.esUVCUvcAddHeader:00000000 esUVCUvcAddHeader
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:369    .text.esUVCUvcAddHeader:00000074 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:374    .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:381    .text.esUVCUvcApplnStart:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:384    .text.esUVCUvcApplnStart:00000000 esUVCUvcApplnStart
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:513    .text.esUVCUvcApplnStart:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:533    .text.esUVCUvcApplnStop:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:536    .text.esUVCUvcApplnStop:00000000 esUVCUvcApplnStop
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:637    .text.esUVCUvcApplnStop:000000f4 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:656    .text.esUVCGpifCB:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:659    .text.esUVCGpifCB:00000000 esUVCGpifCB
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:731    .text.esUVCGpifCB:000000ac $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:738    .text.esUVCUvcAppDmaCallback:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:741    .text.esUVCUvcAppDmaCallback:00000000 esUVCUvcAppDmaCallback
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:1048   .text.esUVCUvcAppDmaCallback:00000380 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:1068   .text.esUVCUvcApplnUSBEventCB:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:1070   .text.esUVCUvcApplnUSBEventCB:00000000 esUVCUvcApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:1100   .text.esUVCUvcApplnUSBEventCB:0000003c $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:1110   .text.esUVCUvcApplnUSBEventCB:0000005c $a
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:1232   .text.esUVCUvcApplnUSBEventCB:00000198 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:1243   .text.esUVCApplnLPMRqtCB:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:1245   .text.esUVCApplnLPMRqtCB:00000000 esUVCApplnLPMRqtCB
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:1290   .text.esSetCameraResolution:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:1293   .text.esSetCameraResolution:00000000 esSetCameraResolution
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:1450   .text.esSetCameraResolution:000001ac $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:1490   .text.esUVCUvcApplnUSBSetupCB:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:1492   .text.esUVCUvcApplnUSBSetupCB:00000000 esUVCUvcApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:2244   .text.esUVCUvcApplnUSBSetupCB:00000828 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:2360   .text.esUVCUvcApplnInit:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:2363   .text.esUVCUvcApplnInit:00000000 esUVCUvcApplnInit
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:3057   .text.esUVCUvcApplnInit:000007a8 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:3134   .text.esUVCUvcApplnDebugInit:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:3137   .text.esUVCUvcApplnDebugInit:00000000 esUVCUvcApplnDebugInit
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:3244   .text.esUVCUvcApplnDebugInit:00000104 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:3253   .text.esUVCUvcAppThread_Entry:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:3256   .text.esUVCUvcAppThread_Entry:00000000 esUVCUvcAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:3348   .text.esUVCUvcAppThread_Entry:000000d4 $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:3372   .text.CyFxApplicationDefine:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:3375   .text.CyFxApplicationDefine:00000000 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:3515   .text.CyFxApplicationDefine:0000018c $d
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:3531   .text.main:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc5HAtmg.s:3534   .text.main:00000000 main
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.29463082a45126943f020ea30bda05c8
                           .group:00000000 wm4.newlib.h.8.384a112feabb3bef7b573ae48cde2e3b
                           .group:00000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:00000000 wm4.config.h.219.8eb38badc3f446ace4f0fbbdc7b4e018
                           .group:00000000 wm4._ansi.h.23.5644b60c990a4800b02a6e654e88f93a
                           .group:00000000 wm4.stdint.h.20.54ad762faa59e3c05491630641c8d8bf
                           .group:00000000 wm4.cyu3types.h.80.f5310e165127de2daf78c334a454267e
                           .group:00000000 wm4.stdlib.h.18.8bab2fb43ac4e90235390733c30a4530
                           .group:00000000 wm4.stddef.h.184.aa65fb7281d578229bbad41b91862635
                           .group:00000000 wm4._default_types.h.6.5e12cd604db8ce00b62bb2f02708eaf3
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.59.db8450f33c1f6150c0372fa1091a887a
                           .group:00000000 wm4.stddef.h.348.9a99de77b6ba3b4278b57e9cc6d6e349
                           .group:00000000 wm4.reent.h.16.ec713094ff7b80200da61a1b94cca956
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.55.7091a050e07f1c4abd225630fe3d62f1
                           .group:00000000 wm4.stddef.h.39.d0197034aa5fd947cae140b9289e6734
                           .group:00000000 wm4.cdefs.h.56.efab90f4d89fbc41d6b3a5c5fb0d3d0f
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.string.h.126.6ff3aa59129e7f66b2c273baf353e066
                           .group:00000000 wm4.tx_port.h.95.54ef54ef950923016df123872c81f77f
                           .group:00000000 wm4.tx_api.h.90.d18ffa804751aa80b6d59c3d596c2234
                           .group:00000000 wm4.cyu3tx.h.61.421a5eac9b37f3e2677fcfe17ba1c9c3
                           .group:00000000 wm4.cyu3dma.h.569.521da17a880bb7dc9c063e240d18d9bc
                           .group:00000000 wm4.cyu3system.h.43.0fbd82548e591beefe95401c72410881
                           .group:00000000 wm4.cyu3usbconst.h.37.502980e110c2142a7316d50a53794397
                           .group:00000000 wm4.cyu3usb.h.302.ade7bb9b5b6e92c233eea1baf2851afa
                           .group:00000000 wm4.cyu3lpp.h.138.66435309bc2407b6684483dfed574450
                           .group:00000000 wm4.assert.h.11.060c3dc511517628fd4f958fa9448dce
                           .group:00000000 wm4.cyu3utils.h.45.ea1b88089ccad3d50489f6f768ad8e9f
                           .group:00000000 wm4.cyu3pib.h.192.a1483c513c81c352d6719814a4b66283
                           .group:00000000 wm4.cyu3descriptor.h.104.486178ff96f7d84792762d8905519d09
                           .group:00000000 wm4.cyu3socket.h.153.0d077cd39632ba9c913ec648cfa0f9e9
                           .group:00000000 wm4.sock_regs.h.24.15d70ab2b2a99b01b4189217fc091bd3
                           .group:00000000 wm4.cyu3sib.h.59.b1cff9a75023363cc612aef2b2314b23
                           .group:00000000 wm4.cyu3gpif.h.52.b01ef1bece12652336136a0aaabab45b
                           .group:00000000 wm4.cyu3mipicsi.h.46.b99df5b141b2543db3c56d6e408e0c5e
                           .group:00000000 wm4.cmdqu.h.19.d1373502bd3a7a56ccbd1736008f9f37
                           .group:00000000 wm4.CX3RDKOV5640.h.35.f7fe529c288b3942b3918d28808c5cde
                           .group:00000000 wm4.sensor.h.26.d38741ffaf0557280b1e48334d87d815
                           .group:00000000 wm4.uvc.h.35.a04ef8733ce74876578c7ba6b3d79b48

UNDEFINED SYMBOLS
_txe_event_flags_set
_tx_thread_sleep
CyU3PMemCopy
_txe_timer_deactivate
CyU3PUsbSetEpNak
CyFx3BusyWait
CyU3PUsbFlushEp
CyU3PDmaMultiChannelReset
CyU3PDebugPrint
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMControl
CyU3PGpifSMSwitch
CyU3PMipicsiWakeup
CyU3PMipicsiSleep
CyU3PUsbStall
CyU3PUsbLPMEnable
CyU3PDmaMultiChannelSetWrapUp
CyU3PUsbGetSpeed
CyU3PUsbLPMDisable
CyU3PUsbSetLinkPowerState
_txe_timer_activate
CyU3PDmaMultiChannelGetBuffer
CyU3PDmaMultiChannelCommitBuffer
_txe_timer_change
CyU3PMipicsiSetIntfParams
cfgUvc1080p30NoMclk
cfgUvcVga30NoMclk
cfgUvc720p60NoMclk
cfgUvc5Mp15NoMclk
CyU3PUsbAckSetup
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
SensorGetControl
UVCHandleProcessingUnitRqts
UVCHandleExtensionUnitRqts
glProbeCtrl
gl5MpProbeCtrl
gl720pProbeCtrl
glVga60ProbeCtrl
gl1080pProbeCtrl
glVga30ProbeCtrl
glStillProbeCtrl
CyU3PMipicsiInitializeI2c
CyU3PMipicsiInitializeGPIO
CyU3PMipicsiInitializePIB
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbRegisterLPMRequestCallback
CyU3PUsbSetDesc
CyU3PUsbVBattEnable
CyU3PUsbControlVBusDetect
CyU3PConnectState
CyU3PSetEpConfig
CyU3PUsbEPSetBurstMode
CyU3PDmaMultiChannelCreate
CyU3PMipicsiGpifLoad
CyU3PGpifRegisterCallback
CyU3PGpifSMStart
CyU3PMipicsiInit
_txe_timer_create
esUVCUSB30DeviceDscr
esUVCUSB20DeviceDscr
esUVCUSBBOSDscr
esUVCUSBDeviceQualDscr
esUVCUSBSSConfigDscr
esUVCUSBHSConfigDscr
esUVCUSBFSConfigDscr
esUVCUSBStringLangIDDscr
esUVCUSBManufactureDscr
esUVCUSBProductDscr
esUVCUSBConfigSSDscr
esUVCUSBConfigHSDscr
esUVCUSBConfigFSDscr
cfgUvcVgaNoMclk
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
_txe_event_flags_get
cmdbufCreate
cmdquInit
CyU3PMemAlloc
_txe_thread_create
_txe_event_flags_create
SenAppThread_Entry
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
