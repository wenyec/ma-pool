   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"CX3RDKOV5640.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.comm	gl32SetControl,4,4
  17              		.comm	gl16SetControl,2,2
  18              		.section	.bss.glEp0Buffer,"aw",%nobits
  19              		.align	2
  22              	glEp0Buffer:
  23 0000 00000000 		.space	32
  23      00000000 
  23      00000000 
  23      00000000 
  23      00000000 
  24              		.comm	uvcAppThread,168,4
  25              		.comm	SenAppThread,168,4
  26              		.comm	glTimerEvent,40,4
  27              		.comm	cmdQu,32,4
  28              		.comm	statQu,32,4
  29              		.comm	cmdQuMux,56,4
  30              		.comm	statQuMux,56,4
  31              		.comm	timMux,56,4
  32              		.comm	imgHdMux,56,4
  33              		.section	.bss.UvcTimer,"aw",%nobits
  34              		.align	2
  37              	UvcTimer:
  38 0000 00000000 		.space	44
  38      00000000 
  38      00000000 
  38      00000000 
  38      00000000 
  39              		.section	.text.UvcAppProgressTimer,"ax",%progbits
  40              		.align	2
  42              	UvcAppProgressTimer:
  43              	.LFB0:
  44              		.file 1 "../CX3RDKOV5640.c"
   1:../CX3RDKOV5640.c **** /*
   2:../CX3RDKOV5640.c ****  ## e-con Systems USB UVC Stack – See3CAMCX3RDK Platform
   3:../CX3RDKOV5640.c **** 
   4:../CX3RDKOV5640.c ****  ## source file : CX3RDKOV5640.c
   5:../CX3RDKOV5640.c ****  ## ===========================
   6:../CX3RDKOV5640.c ****  ##
   7:../CX3RDKOV5640.c ****  ##  Copyright E-Con Systems, 2013-2014,
   8:../CX3RDKOV5640.c ****  ##  All Rights Reserved
   9:../CX3RDKOV5640.c ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
  10:../CX3RDKOV5640.c ****  ##
  11:../CX3RDKOV5640.c ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  12:../CX3RDKOV5640.c ****  ##  PROPERTY OF ECON SYSTEMS
  13:../CX3RDKOV5640.c **** 
  14:../CX3RDKOV5640.c ****  ## www.e-consystems.com
  15:../CX3RDKOV5640.c ****  ##
  16:../CX3RDKOV5640.c ****  ##
  17:../CX3RDKOV5640.c ****  ## ===========================
  18:../CX3RDKOV5640.c **** */
  19:../CX3RDKOV5640.c **** 
  20:../CX3RDKOV5640.c **** #include "cyu3system.h"
  21:../CX3RDKOV5640.c **** #include "cyu3os.h"
  22:../CX3RDKOV5640.c **** #include "cyu3dma.h"
  23:../CX3RDKOV5640.c **** #include "cyu3error.h"
  24:../CX3RDKOV5640.c **** #include "cyu3usb.h"
  25:../CX3RDKOV5640.c **** #include "cyu3i2c.h"
  26:../CX3RDKOV5640.c **** #include "cyu3uart.h"
  27:../CX3RDKOV5640.c **** #include "cyu3gpio.h"
  28:../CX3RDKOV5640.c **** #include "cyu3utils.h"
  29:../CX3RDKOV5640.c **** #include "cyu3pib.h"
  30:../CX3RDKOV5640.c **** #include "cyu3socket.h"
  31:../CX3RDKOV5640.c **** #include "sock_regs.h"
  32:../CX3RDKOV5640.c **** #include "cyu3mipicsi.h"
  33:../CX3RDKOV5640.c **** 
  34:../CX3RDKOV5640.c **** #include "CX3OV5640Lib.h"
  35:../CX3RDKOV5640.c **** #include "CX3RDKOV5640.h"
  36:../CX3RDKOV5640.c **** #include "sensor.h"
  37:../CX3RDKOV5640.c **** #include "cmdqu.h"
  38:../CX3RDKOV5640.c **** #include "uvc.h"
  39:../CX3RDKOV5640.c **** 
  40:../CX3RDKOV5640.c **** /* Event generated on Timer overflow*/
  41:../CX3RDKOV5640.c **** #define ES_TIMER_RESET_EVENT		(1<<4)
  42:../CX3RDKOV5640.c **** 
  43:../CX3RDKOV5640.c **** /* Event generated on a USB Suspend Request*/
  44:../CX3RDKOV5640.c **** #define ES_USB_SUSP_EVENT_FLAG		(1<<5)
  45:../CX3RDKOV5640.c **** 
  46:../CX3RDKOV5640.c **** /* Firmware version*/
  47:../CX3RDKOV5640.c **** #define MajorVersion 				1
  48:../CX3RDKOV5640.c **** #define MinorVersion 				3
  49:../CX3RDKOV5640.c **** #define SubVersion					133
  50:../CX3RDKOV5640.c **** #define SubVersion1					309
  51:../CX3RDKOV5640.c **** #define RESET_TIMER_ENABLE 1
  52:../CX3RDKOV5640.c **** 
  53:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
  54:../CX3RDKOV5640.c **** #define TIMER_PERIOD	(500)
  55:../CX3RDKOV5640.c **** 
  56:../CX3RDKOV5640.c **** /****** for VIS debugging ******/
  57:../CX3RDKOV5640.c **** //#define VISDebug
  58:../CX3RDKOV5640.c **** 
  59:../CX3RDKOV5640.c **** /*************End***************/
  60:../CX3RDKOV5640.c **** 
  61:../CX3RDKOV5640.c **** /******* The Global Variables from FX3 code *******/
  62:../CX3RDKOV5640.c **** //VdRingBuf     cmdQu, statQu;
  63:../CX3RDKOV5640.c **** CyU3PMutex    cmdQuMux, statQuMux, timMux, imgHdMux;
  64:../CX3RDKOV5640.c **** 
  65:../CX3RDKOV5640.c **** /******************* End **************************/
  66:../CX3RDKOV5640.c **** 
  67:../CX3RDKOV5640.c **** static CyU3PTimer        UvcTimer;
  68:../CX3RDKOV5640.c **** 
  69:../CX3RDKOV5640.c **** static void UvcAppProgressTimer (uint32_t arg)
  70:../CX3RDKOV5640.c **** {
  45              		.loc 1 70 0
  46              		.cfi_startproc
  47              		@ args = 0, pretend = 0, frame = 8
  48              		@ frame_needed = 1, uses_anonymous_args = 0
  49 0000 00482DE9 		stmfd	sp!, {fp, lr}
  50              	.LCFI0:
  51              		.cfi_def_cfa_offset 8
  52              		.cfi_offset 11, -8
  53              		.cfi_offset 14, -4
  54 0004 04B08DE2 		add	fp, sp, #4
  55              	.LCFI1:
  56              		.cfi_def_cfa 11, 4
  57 0008 08D04DE2 		sub	sp, sp, #8
  58 000c 08000BE5 		str	r0, [fp, #-8]
  71:../CX3RDKOV5640.c ****     /* This frame has taken too long to complete.
  72:../CX3RDKOV5640.c ****      * Abort it, so that the next frame can be started. */
  73:../CX3RDKOV5640.c ****     CyU3PEventSet(&glTimerEvent, ES_TIMER_RESET_EVENT,CYU3P_EVENT_OR);
  59              		.loc 1 73 0
  60 0010 10009FE5 		ldr	r0, .L2
  61 0014 1010A0E3 		mov	r1, #16
  62 0018 0020A0E3 		mov	r2, #0
  63 001c FEFFFFEB 		bl	_txe_event_flags_set
  74:../CX3RDKOV5640.c **** }
  64              		.loc 1 74 0
  65 0020 04D04BE2 		sub	sp, fp, #4
  66              		@ sp needed
  67 0024 0088BDE8 		ldmfd	sp!, {fp, pc}
  68              	.L3:
  69              		.align	2
  70              	.L2:
  71 0028 00000000 		.word	glTimerEvent
  72              		.cfi_endproc
  73              	.LFE0:
  75              		.global	glDMATxCount
  76              		.section	.bss.glDMATxCount,"aw",%nobits
  77              		.align	2
  80              	glDMATxCount:
  81 0000 00000000 		.space	4
  82              		.global	glDmaDone
  83              		.section	.bss.glDmaDone,"aw",%nobits
  84              		.align	2
  87              	glDmaDone:
  88 0000 00000000 		.space	4
  89              		.global	glActiveSocket
  90              		.section	.bss.glActiveSocket,"aw",%nobits
  93              	glActiveSocket:
  94 0000 00       		.space	1
  95              		.global	doLpmDisable
  96              		.section	.data.doLpmDisable,"aw",%progbits
  97              		.align	2
 100              	doLpmDisable:
 101 0000 01000000 		.word	1
 102              		.global	glHitFV
 103              		.section	.bss.glHitFV,"aw",%nobits
 104              		.align	2
 107              	glHitFV:
 108 0000 00000000 		.space	4
 109              		.global	glMipiActive
 110              		.section	.bss.glMipiActive,"aw",%nobits
 111              		.align	2
 114              	glMipiActive:
 115 0000 00000000 		.space	4
 116              		.global	glIsClearFeature
 117              		.section	.bss.glIsClearFeature,"aw",%nobits
 118              		.align	2
 121              	glIsClearFeature:
 122 0000 00000000 		.space	4
 123              		.global	glPreviewStarted
 124              		.section	.bss.glPreviewStarted,"aw",%nobits
 125              		.align	2
 128              	glPreviewStarted:
 129 0000 00000000 		.space	4
 130              		.global	glUVCHeader
 131              		.section	.data.glUVCHeader,"aw",%progbits
 132              		.align	2
 135              	glUVCHeader:
 136 0000 0C       		.byte	12
 137 0001 8C       		.byte	-116
 138 0002 00       		.byte	0
 139 0003 00       		.byte	0
 140 0004 00       		.byte	0
 141 0005 00       		.byte	0
 142 0006 00       		.byte	0
 143 0007 00       		.byte	0
 144 0008 00       		.byte	0
 145 0009 00       		.byte	0
 146 000a 00       		.byte	0
 147 000b 00       		.byte	0
 148              		.comm	glCommitCtrl,32,4
 149              		.global	glCurrentFrameIndex
 150              		.section	.data.glCurrentFrameIndex,"aw",%progbits
 153              	glCurrentFrameIndex:
 154 0000 01       		.byte	1
 155              		.comm	glStillCommitCtrl,32,4
 156              		.global	glCurrentStillFrameIndex
 157              		.section	.data.glCurrentStillFrameIndex,"aw",%progbits
 160              	glCurrentStillFrameIndex:
 161 0000 01       		.byte	1
 162              		.global	glStillTriggerCtrl
 163              		.section	.bss.glStillTriggerCtrl,"aw",%nobits
 166              	glStillTriggerCtrl:
 167 0000 00       		.space	1
 168              		.global	glFrameIndexToSet
 169              		.section	.bss.glFrameIndexToSet,"aw",%nobits
 172              	glFrameIndexToSet:
 173 0000 00       		.space	1
 174              		.global	glStillCaptureStart
 175              		.section	.bss.glStillCaptureStart,"aw",%nobits
 176              		.align	2
 179              	glStillCaptureStart:
 180 0000 00000000 		.space	4
 181              		.global	glStillCaptured
 182              		.section	.bss.glStillCaptured,"aw",%nobits
 183              		.align	2
 186              	glStillCaptured:
 187 0000 00000000 		.space	4
 188              		.global	glStillSkip
 189              		.section	.bss.glStillSkip,"aw",%nobits
 192              	glStillSkip:
 193 0000 00       		.space	1
 194              		.global	glIsApplnActive
 195              		.section	.bss.glIsApplnActive,"aw",%nobits
 196              		.align	2
 199              	glIsApplnActive:
 200 0000 00000000 		.space	4
 201              		.global	glIsConfigured
 202              		.section	.bss.glIsConfigured,"aw",%nobits
 203              		.align	2
 206              	glIsConfigured:
 207 0000 00000000 		.space	4
 208              		.global	glIsStreamingStarted
 209              		.section	.bss.glIsStreamingStarted,"aw",%nobits
 210              		.align	2
 213              	glIsStreamingStarted:
 214 0000 00000000 		.space	4
 215              		.comm	glChHandleUVCStream,232,4
 216              		.global	ES_UVC_STREAM_BUF_SIZE
 217              		.section	.bss.ES_UVC_STREAM_BUF_SIZE,"aw",%nobits
 218              		.align	1
 221              	ES_UVC_STREAM_BUF_SIZE:
 222 0000 0000     		.space	2
 223              		.global	ES_UVC_DATA_BUF_SIZE
 224              		.section	.bss.ES_UVC_DATA_BUF_SIZE,"aw",%nobits
 225              		.align	1
 228              	ES_UVC_DATA_BUF_SIZE:
 229 0000 0000     		.space	2
 230              		.global	ES_UVC_STREAM_BUF_COUNT
 231              		.section	.bss.ES_UVC_STREAM_BUF_COUNT,"aw",%nobits
 234              	ES_UVC_STREAM_BUF_COUNT:
 235 0000 00       		.space	1
 236              		.global	g_IsAutoFocus
 237              		.section	.data.g_IsAutoFocus,"aw",%progbits
 240              	g_IsAutoFocus:
 241 0000 01       		.byte	1
 242              		.global	glGet_Info
 243              		.section	.bss.glGet_Info,"aw",%nobits
 246              	glGet_Info:
 247 0000 00       		.space	1
 248              		.global	gl8GetControl
 249              		.section	.bss.gl8GetControl,"aw",%nobits
 250              		.align	1
 253              	gl8GetControl:
 254 0000 0000     		.space	2
 255              		.global	gl8SetControl
 256              		.section	.bss.gl8SetControl,"aw",%nobits
 257              		.align	1
 260              	gl8SetControl:
 261 0000 0000     		.space	2
 262              		.global	gl16GetControl
 263              		.section	.bss.gl16GetControl,"aw",%nobits
 264              		.align	1
 267              	gl16GetControl:
 268 0000 0000     		.space	2
 269              		.global	gl32GetControl
 270              		.section	.bss.gl32GetControl,"aw",%nobits
 271              		.align	2
 274              	gl32GetControl:
 275 0000 00000000 		.space	4
 276              		.global	glcommitcount
 277              		.section	.bss.glcommitcount,"aw",%nobits
 280              	glcommitcount:
 281 0000 00       		.space	1
 282              		.global	glcheckframe
 283              		.section	.data.glcheckframe,"aw",%progbits
 286              	glcheckframe:
 287 0000 01       		.byte	1
 288              		.section	.text.esUVCAppErrorHandler,"ax",%progbits
 289              		.align	2
 290              		.global	esUVCAppErrorHandler
 292              	esUVCAppErrorHandler:
 293              	.LFB1:
  75:../CX3RDKOV5640.c **** #endif
  76:../CX3RDKOV5640.c **** 
  77:../CX3RDKOV5640.c **** volatile int32_t glDMATxCount = 0;          /* Counter used to count the Dma Transfers */
  78:../CX3RDKOV5640.c **** volatile int32_t glDmaDone = 0;
  79:../CX3RDKOV5640.c **** volatile uint8_t glActiveSocket = 0;
  80:../CX3RDKOV5640.c **** volatile CyBool_t doLpmDisable = CyTrue;	/* Flag used to Enable/Disable low USB 3.0 LPM */
  81:../CX3RDKOV5640.c **** CyBool_t glHitFV = CyFalse;             	/* Flag used for state of FV signal. */
  82:../CX3RDKOV5640.c **** CyBool_t glMipiActive = CyFalse;        	/* Flag set to true when Mipi interface is active. Used fo
  83:../CX3RDKOV5640.c **** CyBool_t glIsClearFeature = CyFalse;    	/* Flag to signal when AppStop is called from the ClearFea
  84:../CX3RDKOV5640.c **** CyBool_t glPreviewStarted = CyFalse;		/* Flag to support Mac os */
  85:../CX3RDKOV5640.c **** 
  86:../CX3RDKOV5640.c **** /* UVC Header */
  87:../CX3RDKOV5640.c **** uint8_t glUVCHeader[ES_UVC_HEADER_LENGTH] =
  88:../CX3RDKOV5640.c **** {
  89:../CX3RDKOV5640.c ****     0x0C,                           /* Header Length */
  90:../CX3RDKOV5640.c ****     0x8C,                           /* Bit field header field */
  91:../CX3RDKOV5640.c ****     0x00,0x00,0x00,0x00,            /* Presentation time stamp field */
  92:../CX3RDKOV5640.c ****     0x00,0x00,0x00,0x00,0x00,0x00   /* Source clock reference field */
  93:../CX3RDKOV5640.c **** };
  94:../CX3RDKOV5640.c **** 
  95:../CX3RDKOV5640.c **** /* Video Probe Commit Control */
  96:../CX3RDKOV5640.c **** uint8_t glCommitCtrl[ES_UVC_MAX_PROBE_SETTING_ALIGNED];
  97:../CX3RDKOV5640.c **** uint8_t glCurrentFrameIndex = 1;
  98:../CX3RDKOV5640.c **** uint8_t glStillCommitCtrl[ES_UVC_MAX_STILL_PROBE_SETTING_ALIGNED];
  99:../CX3RDKOV5640.c **** uint8_t glCurrentStillFrameIndex = 1;
 100:../CX3RDKOV5640.c **** uint8_t glStillTriggerCtrl = 0;
 101:../CX3RDKOV5640.c **** uint8_t glFrameIndexToSet = 0;
 102:../CX3RDKOV5640.c **** CyBool_t glStillCaptureStart = CyFalse;
 103:../CX3RDKOV5640.c **** CyBool_t glStillCaptured = CyFalse;
 104:../CX3RDKOV5640.c **** uint8_t glStillSkip = 0;
 105:../CX3RDKOV5640.c **** 
 106:../CX3RDKOV5640.c **** CyBool_t glIsApplnActive = CyFalse;             /* Whether the Mipi->USB application is active or n
 107:../CX3RDKOV5640.c **** CyBool_t glIsConfigured = CyFalse;              /* Whether Application is in configured state or no
 108:../CX3RDKOV5640.c **** CyBool_t glIsStreamingStarted = CyFalse;        /* Whether streaming has started - Used for MAC OS 
 109:../CX3RDKOV5640.c **** 
 110:../CX3RDKOV5640.c **** /* DMA Channel */
 111:../CX3RDKOV5640.c **** CyU3PDmaMultiChannel glChHandleUVCStream;       /* DMA Channel Handle for UVC Stream  */
 112:../CX3RDKOV5640.c **** uint16_t ES_UVC_STREAM_BUF_SIZE=0;
 113:../CX3RDKOV5640.c **** uint16_t ES_UVC_DATA_BUF_SIZE=0;
 114:../CX3RDKOV5640.c **** uint8_t ES_UVC_STREAM_BUF_COUNT=0;
 115:../CX3RDKOV5640.c **** 
 116:../CX3RDKOV5640.c **** uint8_t g_IsAutoFocus=1;						/* Check the AutoFocus is Enabled or not*/
 117:../CX3RDKOV5640.c **** 
 118:../CX3RDKOV5640.c **** /* USB control request processing variables*/
 119:../CX3RDKOV5640.c **** #if 1
 120:../CX3RDKOV5640.c **** 
 121:../CX3RDKOV5640.c **** uint8_t glGet_Info = 0;
 122:../CX3RDKOV5640.c **** int16_t gl8GetControl = 0;
 123:../CX3RDKOV5640.c **** int16_t gl8SetControl = 0;
 124:../CX3RDKOV5640.c **** int16_t gl16GetControl = 0;
 125:../CX3RDKOV5640.c **** 
 126:../CX3RDKOV5640.c **** int32_t gl32GetControl = 0;
 127:../CX3RDKOV5640.c **** 
 128:../CX3RDKOV5640.c **** #endif
 129:../CX3RDKOV5640.c **** 
 130:../CX3RDKOV5640.c **** uint8_t glcommitcount=0,glcheckframe=1;
 131:../CX3RDKOV5640.c **** 
 132:../CX3RDKOV5640.c **** /* Application critical error handler */
 133:../CX3RDKOV5640.c ****     void
 134:../CX3RDKOV5640.c **** esUVCAppErrorHandler (
 135:../CX3RDKOV5640.c ****         CyU3PReturnStatus_t status        /* API return status */
 136:../CX3RDKOV5640.c ****         )
 137:../CX3RDKOV5640.c **** {
 294              		.loc 1 137 0
 295              		.cfi_startproc
 296              		@ args = 0, pretend = 0, frame = 8
 297              		@ frame_needed = 1, uses_anonymous_args = 0
 298 0000 00482DE9 		stmfd	sp!, {fp, lr}
 299              	.LCFI2:
 300              		.cfi_def_cfa_offset 8
 301              		.cfi_offset 11, -8
 302              		.cfi_offset 14, -4
 303 0004 04B08DE2 		add	fp, sp, #4
 304              	.LCFI3:
 305              		.cfi_def_cfa 11, 4
 306 0008 08D04DE2 		sub	sp, sp, #8
 307 000c 08000BE5 		str	r0, [fp, #-8]
 308              	.L5:
 138:../CX3RDKOV5640.c ****     /* Application failed with the error code status */
 139:../CX3RDKOV5640.c **** 
 140:../CX3RDKOV5640.c ****     /* Add custom debug or recovery actions here */
 141:../CX3RDKOV5640.c **** 
 142:../CX3RDKOV5640.c ****     /* Loop indefinitely */
 143:../CX3RDKOV5640.c ****     for (;;)
 144:../CX3RDKOV5640.c ****     {
 145:../CX3RDKOV5640.c ****         /* Thread sleep : 100 ms */
 146:../CX3RDKOV5640.c ****         CyU3PThreadSleep (100);
 309              		.loc 1 146 0 discriminator 1
 310 0010 6400A0E3 		mov	r0, #100
 311 0014 FEFFFFEB 		bl	_tx_thread_sleep
 147:../CX3RDKOV5640.c ****     }
 312              		.loc 1 147 0 discriminator 1
 313 0018 FCFFFFEA 		b	.L5
 314              		.cfi_endproc
 315              	.LFE1:
 317              		.section	.text.esUVCUvcAddHeader,"ax",%progbits
 318              		.align	2
 320              	esUVCUvcAddHeader:
 321              	.LFB2:
 148:../CX3RDKOV5640.c **** }
 149:../CX3RDKOV5640.c **** 
 150:../CX3RDKOV5640.c **** 
 151:../CX3RDKOV5640.c **** /* UVC header addition function */
 152:../CX3RDKOV5640.c ****     static void
 153:../CX3RDKOV5640.c **** esUVCUvcAddHeader (
 154:../CX3RDKOV5640.c ****         uint8_t *buffer_p,      /* Buffer pointer */
 155:../CX3RDKOV5640.c ****         uint8_t frameInd        /* EOF or normal frame indication */
 156:../CX3RDKOV5640.c ****         )
 157:../CX3RDKOV5640.c **** {
 322              		.loc 1 157 0
 323              		.cfi_startproc
 324              		@ args = 0, pretend = 0, frame = 8
 325              		@ frame_needed = 1, uses_anonymous_args = 0
 326 0000 00482DE9 		stmfd	sp!, {fp, lr}
 327              	.LCFI4:
 328              		.cfi_def_cfa_offset 8
 329              		.cfi_offset 11, -8
 330              		.cfi_offset 14, -4
 331 0004 04B08DE2 		add	fp, sp, #4
 332              	.LCFI5:
 333              		.cfi_def_cfa 11, 4
 334 0008 08D04DE2 		sub	sp, sp, #8
 335 000c 08000BE5 		str	r0, [fp, #-8]
 336 0010 0130A0E1 		mov	r3, r1
 337 0014 09304BE5 		strb	r3, [fp, #-9]
 158:../CX3RDKOV5640.c ****     /* Copy header to buffer */
 159:../CX3RDKOV5640.c ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, ES_UVC_HEADER_LENGTH);
 338              		.loc 1 159 0
 339 0018 08001BE5 		ldr	r0, [fp, #-8]
 340 001c 50109FE5 		ldr	r1, .L8
 341 0020 0C20A0E3 		mov	r2, #12
 342 0024 FEFFFFEB 		bl	CyU3PMemCopy
 160:../CX3RDKOV5640.c **** 
 161:../CX3RDKOV5640.c ****     /* Check if last packet of the frame. */
 162:../CX3RDKOV5640.c ****     if (frameInd == ES_UVC_HEADER_EOF)
 343              		.loc 1 162 0
 344 0028 09305BE5 		ldrb	r3, [fp, #-9]	@ zero_extendqisi2
 345 002c 020053E3 		cmp	r3, #2
 346 0030 0D00001A 		bne	.L6
 163:../CX3RDKOV5640.c ****     {
 164:../CX3RDKOV5640.c ****         /* Modify UVC header to toggle Frame ID */
 165:../CX3RDKOV5640.c ****         glUVCHeader[1] ^= ES_UVC_HEADER_FRAME_ID;
 347              		.loc 1 165 0
 348 0034 38309FE5 		ldr	r3, .L8
 349 0038 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 350 003c 013023E2 		eor	r3, r3, #1
 351 0040 FF2003E2 		and	r2, r3, #255
 352 0044 28309FE5 		ldr	r3, .L8
 353 0048 0120C3E5 		strb	r2, [r3, #1]
 166:../CX3RDKOV5640.c **** 
 167:../CX3RDKOV5640.c ****         /* Indicate End of Frame in the buffer */
 168:../CX3RDKOV5640.c ****         buffer_p[1] |=  ES_UVC_HEADER_EOF;
 354              		.loc 1 168 0
 355 004c 08301BE5 		ldr	r3, [fp, #-8]
 356 0050 013083E2 		add	r3, r3, #1
 357 0054 08201BE5 		ldr	r2, [fp, #-8]
 358 0058 012082E2 		add	r2, r2, #1
 359 005c 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 360 0060 022082E3 		orr	r2, r2, #2
 361 0064 FF2002E2 		and	r2, r2, #255
 362 0068 0020C3E5 		strb	r2, [r3]
 363              	.L6:
 169:../CX3RDKOV5640.c ****     }
 170:../CX3RDKOV5640.c **** }
 364              		.loc 1 170 0
 365 006c 04D04BE2 		sub	sp, fp, #4
 366              		@ sp needed
 367 0070 0088BDE8 		ldmfd	sp!, {fp, pc}
 368              	.L9:
 369              		.align	2
 370              	.L8:
 371 0074 00000000 		.word	glUVCHeader
 372              		.cfi_endproc
 373              	.LFE2:
 375              		.section	.rodata
 376              		.align	2
 377              	.LC0:
 378 0000 0A0D4170 		.ascii	"\012\015AplnStrt:ChannelReset Err = 0x%x\000"
 378      6C6E5374 
 378      72743A43 
 378      68616E6E 
 378      656C5265 
 379 0023 00       		.align	2
 380              	.LC1:
 381 0024 0A0D4170 		.ascii	"\012\015AplnStrt:SetXfer Err = 0x%x\000"
 381      6C6E5374 
 381      72743A53 
 381      65745866 
 381      65722045 
 382              		.section	.text.esUVCUvcApplnStart,"ax",%progbits
 383              		.align	2
 384              		.global	esUVCUvcApplnStart
 386              	esUVCUvcApplnStart:
 387              	.LFB3:
 171:../CX3RDKOV5640.c **** 
 172:../CX3RDKOV5640.c **** 
 173:../CX3RDKOV5640.c **** /* This function starts the video streaming application. It is called
 174:../CX3RDKOV5640.c ****  * when there is a SET_INTERFACE event for alternate interface 1
 175:../CX3RDKOV5640.c ****  * (in case of UVC over Isochronous Endpoint usage) or when a
 176:../CX3RDKOV5640.c ****  * COMMIT_CONTROL(SET_CUR) request is received (when using BULK only UVC).
 177:../CX3RDKOV5640.c ****  */
 178:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t
 179:../CX3RDKOV5640.c **** esUVCUvcApplnStart (void)
 180:../CX3RDKOV5640.c **** {
 388              		.loc 1 180 0
 389              		.cfi_startproc
 390              		@ args = 0, pretend = 0, frame = 8
 391              		@ frame_needed = 1, uses_anonymous_args = 0
 392 0000 00482DE9 		stmfd	sp!, {fp, lr}
 393              	.LCFI6:
 394              		.cfi_def_cfa_offset 8
 395              		.cfi_offset 11, -8
 396              		.cfi_offset 14, -4
 397 0004 04B08DE2 		add	fp, sp, #4
 398              	.LCFI7:
 399              		.cfi_def_cfa 11, 4
 400 0008 10D04DE2 		sub	sp, sp, #16
 181:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 401              		.loc 1 181 0
 402 000c 0030A0E3 		mov	r3, #0
 403 0010 08300BE5 		str	r3, [fp, #-8]
 182:../CX3RDKOV5640.c **** 
 183:../CX3RDKOV5640.c ****     glIsApplnActive = CyTrue;
 404              		.loc 1 183 0
 405 0014 2C319FE5 		ldr	r3, .L14
 406 0018 0120A0E3 		mov	r2, #1
 407 001c 002083E5 		str	r2, [r3]
 184:../CX3RDKOV5640.c ****     glDmaDone = 0;
 408              		.loc 1 184 0
 409 0020 24319FE5 		ldr	r3, .L14+4
 410 0024 0020A0E3 		mov	r2, #0
 411 0028 002083E5 		str	r2, [r3]
 185:../CX3RDKOV5640.c ****     glDMATxCount = 0;
 412              		.loc 1 185 0
 413 002c 1C319FE5 		ldr	r3, .L14+8
 414 0030 0020A0E3 		mov	r2, #0
 415 0034 002083E5 		str	r2, [r3]
 186:../CX3RDKOV5640.c ****     glHitFV = CyFalse;
 416              		.loc 1 186 0
 417 0038 14319FE5 		ldr	r3, .L14+12
 418 003c 0020A0E3 		mov	r2, #0
 419 0040 002083E5 		str	r2, [r3]
 187:../CX3RDKOV5640.c ****     doLpmDisable = CyTrue;
 420              		.loc 1 187 0
 421 0044 0C319FE5 		ldr	r3, .L14+16
 422 0048 0120A0E3 		mov	r2, #1
 423 004c 002083E5 		str	r2, [r3]
 188:../CX3RDKOV5640.c **** 
 189:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
 190:../CX3RDKOV5640.c ****     CyU3PTimerStop (&UvcTimer);
 424              		.loc 1 190 0
 425 0050 04019FE5 		ldr	r0, .L14+20
 426 0054 FEFFFFEB 		bl	_txe_timer_deactivate
 191:../CX3RDKOV5640.c **** #endif
 192:../CX3RDKOV5640.c **** 
 193:../CX3RDKOV5640.c **** 
 194:../CX3RDKOV5640.c ****     /* Place the EP in NAK mode before cleaning up the pipe. */
 195:../CX3RDKOV5640.c ****     CyU3PUsbSetEpNak (ES_UVC_EP_BULK_VIDEO, CyTrue);
 427              		.loc 1 195 0
 428 0058 8300A0E3 		mov	r0, #131
 429 005c 0110A0E3 		mov	r1, #1
 430 0060 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 196:../CX3RDKOV5640.c ****     CyU3PBusyWait (100);
 431              		.loc 1 196 0
 432 0064 6400A0E3 		mov	r0, #100
 433 0068 FEFFFFEB 		bl	CyFx3BusyWait
 197:../CX3RDKOV5640.c **** 
 198:../CX3RDKOV5640.c ****     /* Reset USB EP and DMA */
 199:../CX3RDKOV5640.c ****     CyU3PUsbFlushEp(ES_UVC_EP_BULK_VIDEO);
 434              		.loc 1 199 0
 435 006c 8300A0E3 		mov	r0, #131
 436 0070 FEFFFFEB 		bl	CyU3PUsbFlushEp
 200:../CX3RDKOV5640.c ****     status = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 437              		.loc 1 200 0
 438 0074 E4009FE5 		ldr	r0, .L14+24
 439 0078 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 440 007c 08000BE5 		str	r0, [fp, #-8]
 201:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 441              		.loc 1 201 0
 442 0080 08301BE5 		ldr	r3, [fp, #-8]
 443 0084 000053E3 		cmp	r3, #0
 444 0088 0500000A 		beq	.L11
 202:../CX3RDKOV5640.c ****     {
 203:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4,"\n\rAplnStrt:ChannelReset Err = 0x%x", status);
 445              		.loc 1 203 0
 446 008c 0400A0E3 		mov	r0, #4
 447 0090 CC109FE5 		ldr	r1, .L14+28
 448 0094 08201BE5 		ldr	r2, [fp, #-8]
 449 0098 FEFFFFEB 		bl	CyU3PDebugPrint
 204:../CX3RDKOV5640.c ****         return status;
 450              		.loc 1 204 0
 451 009c 08301BE5 		ldr	r3, [fp, #-8]
 452 00a0 250000EA 		b	.L12
 453              	.L11:
 205:../CX3RDKOV5640.c ****     }
 206:../CX3RDKOV5640.c **** 
 207:../CX3RDKOV5640.c ****     status = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 454              		.loc 1 207 0
 455 00a4 B4009FE5 		ldr	r0, .L14+24
 456 00a8 0010A0E3 		mov	r1, #0
 457 00ac 0020A0E3 		mov	r2, #0
 458 00b0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 459 00b4 08000BE5 		str	r0, [fp, #-8]
 208:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 460              		.loc 1 208 0
 461 00b8 08301BE5 		ldr	r3, [fp, #-8]
 462 00bc 000053E3 		cmp	r3, #0
 463 00c0 0500000A 		beq	.L13
 209:../CX3RDKOV5640.c ****     {
 210:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAplnStrt:SetXfer Err = 0x%x", status);
 464              		.loc 1 210 0
 465 00c4 0400A0E3 		mov	r0, #4
 466 00c8 98109FE5 		ldr	r1, .L14+32
 467 00cc 08201BE5 		ldr	r2, [fp, #-8]
 468 00d0 FEFFFFEB 		bl	CyU3PDebugPrint
 211:../CX3RDKOV5640.c ****         return status;
 469              		.loc 1 211 0
 470 00d4 08301BE5 		ldr	r3, [fp, #-8]
 471 00d8 170000EA 		b	.L12
 472              	.L13:
 212:../CX3RDKOV5640.c ****     }
 213:../CX3RDKOV5640.c **** 
 214:../CX3RDKOV5640.c ****     CyU3PUsbSetEpNak (ES_UVC_EP_BULK_VIDEO, CyFalse);
 473              		.loc 1 214 0
 474 00dc 8300A0E3 		mov	r0, #131
 475 00e0 0010A0E3 		mov	r1, #0
 476 00e4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 215:../CX3RDKOV5640.c ****     CyU3PBusyWait (200);
 477              		.loc 1 215 0
 478 00e8 C800A0E3 		mov	r0, #200
 479 00ec FEFFFFEB 		bl	CyFx3BusyWait
 216:../CX3RDKOV5640.c **** //
 217:../CX3RDKOV5640.c **** //    /* Place the EP in NAK mode before cleaning up the pipe. */
 218:../CX3RDKOV5640.c **** //    CyU3PUsbSetEpNak (ES_UVC_EP_BULK_VIDEO, CyTrue);
 219:../CX3RDKOV5640.c **** //    CyU3PBusyWait (100);
 220:../CX3RDKOV5640.c **** //
 221:../CX3RDKOV5640.c **** //    /* Reset USB EP and DMA */
 222:../CX3RDKOV5640.c **** //    CyU3PUsbFlushEp(ES_UVC_EP_BULK_VIDEO);
 223:../CX3RDKOV5640.c **** //    status = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 224:../CX3RDKOV5640.c **** //    if (status != CY_U3P_SUCCESS)
 225:../CX3RDKOV5640.c **** //    {
 226:../CX3RDKOV5640.c **** //        CyU3PDebugPrint (4,"\n\rAplnStrt:ChannelReset Err = 0x%x", status);
 227:../CX3RDKOV5640.c **** //        return status;
 228:../CX3RDKOV5640.c **** //    }
 229:../CX3RDKOV5640.c **** //    status = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 230:../CX3RDKOV5640.c **** //    if (status != CY_U3P_SUCCESS)
 231:../CX3RDKOV5640.c **** //    {
 232:../CX3RDKOV5640.c **** //        CyU3PDebugPrint (4, "\n\rAplnStrt:SetXfer Err = 0x%x", status);
 233:../CX3RDKOV5640.c **** //        return status;
 234:../CX3RDKOV5640.c **** //    }
 235:../CX3RDKOV5640.c **** //    CyU3PUsbSetEpNak (ES_UVC_EP_BULK_VIDEO, CyFalse);
 236:../CX3RDKOV5640.c **** //    CyU3PBusyWait (200);
 237:../CX3RDKOV5640.c **** 
 238:../CX3RDKOV5640.c **** 	 /* Night Mode function
 239:../CX3RDKOV5640.c **** 	 *  --------------------
 240:../CX3RDKOV5640.c **** 	 *  esOV5640_Nightmode API is used to enable the Nightmode
 241:../CX3RDKOV5640.c **** 	 *  of OV5640 sensor.
 242:../CX3RDKOV5640.c **** 	 *  Set Enable -- Cytrue to enable Nightmode
 243:../CX3RDKOV5640.c **** 	 * 				  CyFalse to Disable Nightmode
 244:../CX3RDKOV5640.c **** 	 *
 245:../CX3RDKOV5640.c **** 	 *  Set NightMode_option -- 1 to 6 to set different night modes
 246:../CX3RDKOV5640.c **** 	 *
 247:../CX3RDKOV5640.c **** 	 * To test different night modes, uncomment the below statement and build the firmware
 248:../CX3RDKOV5640.c **** 	 */
 249:../CX3RDKOV5640.c ****     //TODO Change this Function to "Sensor Specific" Nightmode Function to enable the nightmode(If 
 250:../CX3RDKOV5640.c **** 	/*esOV5640_Nightmode(CyTrue,3);*/
 251:../CX3RDKOV5640.c **** 
 252:../CX3RDKOV5640.c **** 
 253:../CX3RDKOV5640.c ****     /* Resume the Fixed Function GPIF State machine */
 254:../CX3RDKOV5640.c ****     CyU3PGpifSMControl(CyFalse);
 480              		.loc 1 254 0
 481 00f0 0000A0E3 		mov	r0, #0
 482 00f4 FEFFFFEB 		bl	CyU3PGpifSMControl
 255:../CX3RDKOV5640.c **** 
 256:../CX3RDKOV5640.c ****     glActiveSocket = 0;
 483              		.loc 1 256 0
 484 00f8 6C309FE5 		ldr	r3, .L14+36
 485 00fc 0020A0E3 		mov	r2, #0
 486 0100 0020C3E5 		strb	r2, [r3]
 257:../CX3RDKOV5640.c ****     CyU3PGpifSMSwitch(ES_UVC_INVALID_GPIF_STATE, CX3_START_SCK0,
 487              		.loc 1 257 0
 488 0104 0230A0E3 		mov	r3, #2
 489 0108 00308DE5 		str	r3, [sp]
 490 010c 5C009FE5 		ldr	r0, .L14+40
 491 0110 0010A0E3 		mov	r1, #0
 492 0114 54209FE5 		ldr	r2, .L14+40
 493 0118 0030A0E3 		mov	r3, #0
 494 011c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 258:../CX3RDKOV5640.c ****     		ES_UVC_INVALID_GPIF_STATE, ALPHA_CX3_START_SCK0, ES_UVC_GPIF_SWITCH_TIMEOUT);
 259:../CX3RDKOV5640.c **** 
 260:../CX3RDKOV5640.c ****     CyU3PThreadSleep(10);
 495              		.loc 1 260 0
 496 0120 0A00A0E3 		mov	r0, #10
 497 0124 FEFFFFEB 		bl	_tx_thread_sleep
 261:../CX3RDKOV5640.c **** 
 262:../CX3RDKOV5640.c ****     /* Wake Mipi interface and Image Sensor */
 263:../CX3RDKOV5640.c ****     CyU3PMipicsiWakeup();
 498              		.loc 1 263 0
 499 0128 FEFFFFEB 		bl	CyU3PMipicsiWakeup
 264:../CX3RDKOV5640.c **** 
 265:../CX3RDKOV5640.c ****     //TODO Change this function with "Sensor Specific" PowerUp function to PowerUp the sensor
 266:../CX3RDKOV5640.c ****     //esCamera_Power_Up();  // remove the camera operations function for VIS mipi camera test -wche
 267:../CX3RDKOV5640.c **** 
 268:../CX3RDKOV5640.c ****     glMipiActive = CyTrue;
 500              		.loc 1 268 0
 501 012c 40309FE5 		ldr	r3, .L14+44
 502 0130 0120A0E3 		mov	r2, #1
 503 0134 002083E5 		str	r2, [r3]
 269:../CX3RDKOV5640.c **** 
 270:../CX3RDKOV5640.c ****     //TODO Change this Function with "Sensor Specific" AutoFocus Function to Set the AutoFocus of t
 271:../CX3RDKOV5640.c **** 	if(glStillCaptureStart!= CyTrue)
 272:../CX3RDKOV5640.c **** 	{
 273:../CX3RDKOV5640.c **** 		if(0&&g_IsAutoFocus)// disable the auto focus for VIS camera. -wcheng
 274:../CX3RDKOV5640.c **** 			esOV5640_SetAutofocus(g_IsAutoFocus);
 275:../CX3RDKOV5640.c **** 	}
 276:../CX3RDKOV5640.c ****     return CY_U3P_SUCCESS;
 504              		.loc 1 276 0
 505 0138 0030A0E3 		mov	r3, #0
 506              	.L12:
 277:../CX3RDKOV5640.c **** }
 507              		.loc 1 277 0
 508 013c 0300A0E1 		mov	r0, r3
 509 0140 04D04BE2 		sub	sp, fp, #4
 510              		@ sp needed
 511 0144 0088BDE8 		ldmfd	sp!, {fp, pc}
 512              	.L15:
 513              		.align	2
 514              	.L14:
 515 0148 00000000 		.word	glIsApplnActive
 516 014c 00000000 		.word	glDmaDone
 517 0150 00000000 		.word	glDMATxCount
 518 0154 00000000 		.word	glHitFV
 519 0158 00000000 		.word	doLpmDisable
 520 015c 00000000 		.word	UvcTimer
 521 0160 00000000 		.word	glChHandleUVCStream
 522 0164 00000000 		.word	.LC0
 523 0168 24000000 		.word	.LC1
 524 016c 00000000 		.word	glActiveSocket
 525 0170 01010000 		.word	257
 526 0174 00000000 		.word	glMipiActive
 527              		.cfi_endproc
 528              	.LFE3:
 530              		.section	.rodata
 531 0042 0000     		.align	2
 532              	.LC2:
 533 0044 0A0D4170 		.ascii	"\012\015AplnStop:ChannelReset Err = 0x%x\000"
 533      6C6E5374 
 533      6F703A43 
 533      68616E6E 
 533      656C5265 
 534              		.section	.text.esUVCUvcApplnStop,"ax",%progbits
 535              		.align	2
 536              		.global	esUVCUvcApplnStop
 538              	esUVCUvcApplnStop:
 539              	.LFB4:
 278:../CX3RDKOV5640.c **** 
 279:../CX3RDKOV5640.c **** /* This function stops the video streaming. It is called from the USB event
 280:../CX3RDKOV5640.c ****  * handler, when there is a reset / disconnect or SET_INTERFACE for alternate
 281:../CX3RDKOV5640.c ****  * interface 0 in case of ischronous implementation or when a Clear Feature (Halt)
 282:../CX3RDKOV5640.c ****  * request is received (in case of bulk only implementation).
 283:../CX3RDKOV5640.c ****  */
 284:../CX3RDKOV5640.c ****     void
 285:../CX3RDKOV5640.c **** esUVCUvcApplnStop(void)
 286:../CX3RDKOV5640.c **** {
 540              		.loc 1 286 0
 541              		.cfi_startproc
 542              		@ args = 0, pretend = 0, frame = 8
 543              		@ frame_needed = 1, uses_anonymous_args = 0
 544 0000 00482DE9 		stmfd	sp!, {fp, lr}
 545              	.LCFI8:
 546              		.cfi_def_cfa_offset 8
 547              		.cfi_offset 11, -8
 548              		.cfi_offset 14, -4
 549 0004 04B08DE2 		add	fp, sp, #4
 550              	.LCFI9:
 551              		.cfi_def_cfa 11, 4
 552 0008 08D04DE2 		sub	sp, sp, #8
 287:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 553              		.loc 1 287 0
 554 000c 0030A0E3 		mov	r3, #0
 555 0010 08300BE5 		str	r3, [fp, #-8]
 288:../CX3RDKOV5640.c **** 
 289:../CX3RDKOV5640.c ****     /* Update the flag so that the application thread is notified of this. */
 290:../CX3RDKOV5640.c ****     glIsApplnActive = CyFalse;
 556              		.loc 1 290 0
 557 0014 D8309FE5 		ldr	r3, .L19
 558 0018 0020A0E3 		mov	r2, #0
 559 001c 002083E5 		str	r2, [r3]
 291:../CX3RDKOV5640.c **** 
 292:../CX3RDKOV5640.c ****     /* Stop the image sensor and CX3 mipi interface */
 293:../CX3RDKOV5640.c ****     status = CyU3PMipicsiSleep();
 560              		.loc 1 293 0
 561 0020 FEFFFFEB 		bl	CyU3PMipicsiSleep
 562 0024 08000BE5 		str	r0, [fp, #-8]
 294:../CX3RDKOV5640.c **** 
 295:../CX3RDKOV5640.c ****     //TODO Change this function with "Sensor Specific" PowerDown function to PowerDown the sensor
 296:../CX3RDKOV5640.c ****     //esCamera_Power_Down();  // remove the camera operations function for VIS mipi camera test -wc
 297:../CX3RDKOV5640.c **** 
 298:../CX3RDKOV5640.c ****     glMipiActive = CyFalse;
 563              		.loc 1 298 0
 564 0028 C8309FE5 		ldr	r3, .L19+4
 565 002c 0020A0E3 		mov	r2, #0
 566 0030 002083E5 		str	r2, [r3]
 299:../CX3RDKOV5640.c **** 
 300:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
 301:../CX3RDKOV5640.c ****     CyU3PTimerStop (&UvcTimer);
 567              		.loc 1 301 0
 568 0034 C0009FE5 		ldr	r0, .L19+8
 569 0038 FEFFFFEB 		bl	_txe_timer_deactivate
 302:../CX3RDKOV5640.c **** #endif
 303:../CX3RDKOV5640.c **** 
 304:../CX3RDKOV5640.c ****     /* Pause the GPIF interface*/
 305:../CX3RDKOV5640.c ****     CyU3PGpifSMControl(CyTrue);
 570              		.loc 1 305 0
 571 003c 0100A0E3 		mov	r0, #1
 572 0040 FEFFFFEB 		bl	CyU3PGpifSMControl
 306:../CX3RDKOV5640.c **** 
 307:../CX3RDKOV5640.c ****     CyU3PUsbSetEpNak (ES_UVC_EP_BULK_VIDEO, CyTrue);
 573              		.loc 1 307 0
 574 0044 8300A0E3 		mov	r0, #131
 575 0048 0110A0E3 		mov	r1, #1
 576 004c FEFFFFEB 		bl	CyU3PUsbSetEpNak
 308:../CX3RDKOV5640.c ****     CyU3PBusyWait (100);
 577              		.loc 1 308 0
 578 0050 6400A0E3 		mov	r0, #100
 579 0054 FEFFFFEB 		bl	CyFx3BusyWait
 309:../CX3RDKOV5640.c **** 
 310:../CX3RDKOV5640.c ****     /* Abort and destroy the video streaming channel */
 311:../CX3RDKOV5640.c ****     /* Reset the channel: Set to DSCR chain starting point in PORD/CONS SCKT; set DSCR_SIZE field i
 312:../CX3RDKOV5640.c ****     status = CyU3PDmaMultiChannelReset(&glChHandleUVCStream);
 580              		.loc 1 312 0
 581 0058 A0009FE5 		ldr	r0, .L19+12
 582 005c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 583 0060 08000BE5 		str	r0, [fp, #-8]
 313:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 584              		.loc 1 313 0
 585 0064 08301BE5 		ldr	r3, [fp, #-8]
 586 0068 000053E3 		cmp	r3, #0
 587 006c 0300000A 		beq	.L17
 314:../CX3RDKOV5640.c ****     {
 315:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4,"\n\rAplnStop:ChannelReset Err = 0x%x",status);
 588              		.loc 1 315 0
 589 0070 0400A0E3 		mov	r0, #4
 590 0074 88109FE5 		ldr	r1, .L19+16
 591 0078 08201BE5 		ldr	r2, [fp, #-8]
 592 007c FEFFFFEB 		bl	CyU3PDebugPrint
 593              	.L17:
 316:../CX3RDKOV5640.c ****     }
 317:../CX3RDKOV5640.c ****     CyU3PThreadSleep(25);
 594              		.loc 1 317 0
 595 0080 1900A0E3 		mov	r0, #25
 596 0084 FEFFFFEB 		bl	_tx_thread_sleep
 318:../CX3RDKOV5640.c **** 
 319:../CX3RDKOV5640.c ****     /* Flush the endpoint memory */
 320:../CX3RDKOV5640.c ****     CyU3PUsbFlushEp(ES_UVC_EP_BULK_VIDEO);
 597              		.loc 1 320 0
 598 0088 8300A0E3 		mov	r0, #131
 599 008c FEFFFFEB 		bl	CyU3PUsbFlushEp
 321:../CX3RDKOV5640.c ****     /* Clear the stall condition and sequence numbers if ClearFeature. */
 322:../CX3RDKOV5640.c ****     if (glIsClearFeature)
 600              		.loc 1 322 0
 601 0090 70309FE5 		ldr	r3, .L19+20
 602 0094 003093E5 		ldr	r3, [r3]
 603 0098 000053E3 		cmp	r3, #0
 604 009c 0600000A 		beq	.L18
 323:../CX3RDKOV5640.c ****     {
 324:../CX3RDKOV5640.c ****         CyU3PUsbStall (ES_UVC_EP_BULK_VIDEO, CyFalse, CyTrue);
 605              		.loc 1 324 0
 606 00a0 8300A0E3 		mov	r0, #131
 607 00a4 0010A0E3 		mov	r1, #0
 608 00a8 0120A0E3 		mov	r2, #1
 609 00ac FEFFFFEB 		bl	CyU3PUsbStall
 325:../CX3RDKOV5640.c ****         glIsClearFeature = CyFalse;
 610              		.loc 1 325 0
 611 00b0 50309FE5 		ldr	r3, .L19+20
 612 00b4 0020A0E3 		mov	r2, #0
 613 00b8 002083E5 		str	r2, [r3]
 614              	.L18:
 326:../CX3RDKOV5640.c ****     }
 327:../CX3RDKOV5640.c ****     CyU3PUsbSetEpNak (ES_UVC_EP_BULK_VIDEO, CyFalse);
 615              		.loc 1 327 0
 616 00bc 8300A0E3 		mov	r0, #131
 617 00c0 0010A0E3 		mov	r1, #0
 618 00c4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 328:../CX3RDKOV5640.c **** 	CyU3PBusyWait (200);
 619              		.loc 1 328 0
 620 00c8 C800A0E3 		mov	r0, #200
 621 00cc FEFFFFEB 		bl	CyFx3BusyWait
 329:../CX3RDKOV5640.c **** 
 330:../CX3RDKOV5640.c ****     glDMATxCount = 0;
 622              		.loc 1 330 0
 623 00d0 34309FE5 		ldr	r3, .L19+24
 624 00d4 0020A0E3 		mov	r2, #0
 625 00d8 002083E5 		str	r2, [r3]
 331:../CX3RDKOV5640.c ****     glDmaDone = 0;
 626              		.loc 1 331 0
 627 00dc 2C309FE5 		ldr	r3, .L19+28
 628 00e0 0020A0E3 		mov	r2, #0
 629 00e4 002083E5 		str	r2, [r3]
 332:../CX3RDKOV5640.c **** 
 333:../CX3RDKOV5640.c ****     /* Enable USB 3.0 LPM */
 334:../CX3RDKOV5640.c ****     CyU3PUsbLPMEnable ();
 630              		.loc 1 334 0
 631 00e8 FEFFFFEB 		bl	CyU3PUsbLPMEnable
 335:../CX3RDKOV5640.c **** }
 632              		.loc 1 335 0
 633 00ec 04D04BE2 		sub	sp, fp, #4
 634              		@ sp needed
 635 00f0 0088BDE8 		ldmfd	sp!, {fp, pc}
 636              	.L20:
 637              		.align	2
 638              	.L19:
 639 00f4 00000000 		.word	glIsApplnActive
 640 00f8 00000000 		.word	glMipiActive
 641 00fc 00000000 		.word	UvcTimer
 642 0100 00000000 		.word	glChHandleUVCStream
 643 0104 44000000 		.word	.LC2
 644 0108 00000000 		.word	glIsClearFeature
 645 010c 00000000 		.word	glDMATxCount
 646 0110 00000000 		.word	glDmaDone
 647              		.cfi_endproc
 648              	.LFE4:
 650              		.section	.rodata
 651 0067 00       		.align	2
 652              	.LC3:
 653 0068 0A0D4770 		.ascii	"\012\015GpifCB:WrapUp SCK0 Err = 0x%x\000"
 653      69664342 
 653      3A577261 
 653      70557020 
 653      53434B30 
 654              		.align	2
 655              	.LC4:
 656 0088 0A0D4770 		.ascii	"\012\015GpifCB:WrapUp SCK1 Err = 0x%x\000"
 656      69664342 
 656      3A577261 
 656      70557020 
 656      53434B31 
 657              		.section	.text.esUVCGpifCB,"ax",%progbits
 658              		.align	2
 659              		.global	esUVCGpifCB
 661              	esUVCGpifCB:
 662              	.LFB5:
 336:../CX3RDKOV5640.c **** 
 337:../CX3RDKOV5640.c **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
 338:../CX3RDKOV5640.c ****     void
 339:../CX3RDKOV5640.c **** esUVCGpifCB (
 340:../CX3RDKOV5640.c ****         CyU3PGpifEventType event,
 341:../CX3RDKOV5640.c ****         uint8_t currentState
 342:../CX3RDKOV5640.c ****         )
 343:../CX3RDKOV5640.c **** {
 663              		.loc 1 343 0
 664              		.cfi_startproc
 665              		@ args = 0, pretend = 0, frame = 16
 666              		@ frame_needed = 1, uses_anonymous_args = 0
 667 0000 00482DE9 		stmfd	sp!, {fp, lr}
 668              	.LCFI10:
 669              		.cfi_def_cfa_offset 8
 670              		.cfi_offset 11, -8
 671              		.cfi_offset 14, -4
 672 0004 04B08DE2 		add	fp, sp, #4
 673              	.LCFI11:
 674              		.cfi_def_cfa 11, 4
 675 0008 10D04DE2 		sub	sp, sp, #16
 676 000c 0020A0E1 		mov	r2, r0
 677 0010 0130A0E1 		mov	r3, r1
 678 0014 0D204BE5 		strb	r2, [fp, #-13]
 679 0018 0E304BE5 		strb	r3, [fp, #-14]
 344:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 680              		.loc 1 344 0
 681 001c 0030A0E3 		mov	r3, #0
 682 0020 08300BE5 		str	r3, [fp, #-8]
 345:../CX3RDKOV5640.c ****     /* Handle interrupt from the State Machine */
 346:../CX3RDKOV5640.c ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 683              		.loc 1 346 0
 684 0024 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 685 0028 010053E3 		cmp	r3, #1
 686 002c 1C00001A 		bne	.L21
 347:../CX3RDKOV5640.c ****     {
 348:../CX3RDKOV5640.c ****         /* Wrapup Socket 0*/
 349:../CX3RDKOV5640.c ****         if(currentState == CX3_PARTIAL_BUFFER_IN_SCK0)
 687              		.loc 1 349 0
 688 0030 0E305BE5 		ldrb	r3, [fp, #-14]	@ zero_extendqisi2
 689 0034 090053E3 		cmp	r3, #9
 690 0038 0B00001A 		bne	.L23
 350:../CX3RDKOV5640.c ****         {
 351:../CX3RDKOV5640.c ****             status = CyU3PDmaMultiChannelSetWrapUp(&glChHandleUVCStream,0);
 691              		.loc 1 351 0
 692 003c 68009FE5 		ldr	r0, .L25
 693 0040 0010A0E3 		mov	r1, #0
 694 0044 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 695 0048 08000BE5 		str	r0, [fp, #-8]
 352:../CX3RDKOV5640.c ****             if (status != CY_U3P_SUCCESS)
 696              		.loc 1 352 0
 697 004c 08301BE5 		ldr	r3, [fp, #-8]
 698 0050 000053E3 		cmp	r3, #0
 699 0054 1200000A 		beq	.L21
 353:../CX3RDKOV5640.c ****             {
 354:../CX3RDKOV5640.c ****                 CyU3PDebugPrint (4, "\n\rGpifCB:WrapUp SCK0 Err = 0x%x",status);
 700              		.loc 1 354 0
 701 0058 0400A0E3 		mov	r0, #4
 702 005c 4C109FE5 		ldr	r1, .L25+4
 703 0060 08201BE5 		ldr	r2, [fp, #-8]
 704 0064 FEFFFFEB 		bl	CyU3PDebugPrint
 705 0068 0D0000EA 		b	.L21
 706              	.L23:
 355:../CX3RDKOV5640.c ****             }
 356:../CX3RDKOV5640.c ****         }
 357:../CX3RDKOV5640.c ****         /* Wrapup Socket 1 */
 358:../CX3RDKOV5640.c ****         else if(currentState == CX3_PARTIAL_BUFFER_IN_SCK1)
 707              		.loc 1 358 0
 708 006c 0E305BE5 		ldrb	r3, [fp, #-14]	@ zero_extendqisi2
 709 0070 0A0053E3 		cmp	r3, #10
 710 0074 0A00001A 		bne	.L21
 359:../CX3RDKOV5640.c ****         {
 360:../CX3RDKOV5640.c ****             status = CyU3PDmaMultiChannelSetWrapUp(&glChHandleUVCStream,1);
 711              		.loc 1 360 0
 712 0078 2C009FE5 		ldr	r0, .L25
 713 007c 0110A0E3 		mov	r1, #1
 714 0080 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 715 0084 08000BE5 		str	r0, [fp, #-8]
 361:../CX3RDKOV5640.c ****             if (status != CY_U3P_SUCCESS)
 716              		.loc 1 361 0
 717 0088 08301BE5 		ldr	r3, [fp, #-8]
 718 008c 000053E3 		cmp	r3, #0
 719 0090 0300000A 		beq	.L21
 362:../CX3RDKOV5640.c ****             {
 363:../CX3RDKOV5640.c ****                 CyU3PDebugPrint (4, "\n\rGpifCB:WrapUp SCK1 Err = 0x%x",status);
 720              		.loc 1 363 0
 721 0094 0400A0E3 		mov	r0, #4
 722 0098 14109FE5 		ldr	r1, .L25+8
 723 009c 08201BE5 		ldr	r2, [fp, #-8]
 724 00a0 FEFFFFEB 		bl	CyU3PDebugPrint
 725              	.L21:
 364:../CX3RDKOV5640.c ****             }
 365:../CX3RDKOV5640.c ****         }
 366:../CX3RDKOV5640.c ****     }
 367:../CX3RDKOV5640.c **** #ifdef VISDebug
 368:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rJump into GPIFCB: event %d currentState %d", event, currentState);
 369:../CX3RDKOV5640.c **** #endif
 370:../CX3RDKOV5640.c **** }
 726              		.loc 1 370 0
 727 00a4 04D04BE2 		sub	sp, fp, #4
 728              		@ sp needed
 729 00a8 0088BDE8 		ldmfd	sp!, {fp, pc}
 730              	.L26:
 731              		.align	2
 732              	.L25:
 733 00ac 00000000 		.word	glChHandleUVCStream
 734 00b0 68000000 		.word	.LC3
 735 00b4 88000000 		.word	.LC4
 736              		.cfi_endproc
 737              	.LFE5:
 739              		.section	.text.esUVCUvcAppDmaCallback,"ax",%progbits
 740              		.align	2
 741              		.global	esUVCUvcAppDmaCallback
 743              	esUVCUvcAppDmaCallback:
 744              	.LFB6:
 371:../CX3RDKOV5640.c **** 
 372:../CX3RDKOV5640.c **** 
 373:../CX3RDKOV5640.c **** /* DMA callback function to handle the produce and consume events. */
 374:../CX3RDKOV5640.c ****     void
 375:../CX3RDKOV5640.c **** esUVCUvcAppDmaCallback (
 376:../CX3RDKOV5640.c ****         CyU3PDmaMultiChannel   *chHandle,
 377:../CX3RDKOV5640.c ****         CyU3PDmaCbType_t  type,
 378:../CX3RDKOV5640.c ****         CyU3PDmaCBInput_t *input
 379:../CX3RDKOV5640.c ****         )
 380:../CX3RDKOV5640.c **** {
 745              		.loc 1 380 0
 746              		.cfi_startproc
 747              		@ args = 0, pretend = 0, frame = 32
 748              		@ frame_needed = 1, uses_anonymous_args = 0
 749 0000 00482DE9 		stmfd	sp!, {fp, lr}
 750              	.LCFI12:
 751              		.cfi_def_cfa_offset 8
 752              		.cfi_offset 11, -8
 753              		.cfi_offset 14, -4
 754 0004 04B08DE2 		add	fp, sp, #4
 755              	.LCFI13:
 756              		.cfi_def_cfa 11, 4
 757 0008 28D04DE2 		sub	sp, sp, #40
 758 000c 18000BE5 		str	r0, [fp, #-24]
 759 0010 0130A0E1 		mov	r3, r1
 760 0014 20200BE5 		str	r2, [fp, #-32]
 761 0018 BA314BE1 		strh	r3, [fp, #-26]	@ movhi
 381:../CX3RDKOV5640.c ****     CyU3PDmaBuffer_t DmaBuffer;
 382:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 762              		.loc 1 382 0
 763 001c 0030A0E3 		mov	r3, #0
 764 0020 08300BE5 		str	r3, [fp, #-8]
 383:../CX3RDKOV5640.c **** 
 384:../CX3RDKOV5640.c ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 765              		.loc 1 384 0
 766 0024 BA315BE1 		ldrh	r3, [fp, #-26]
 767 0028 080053E3 		cmp	r3, #8
 768 002c 5800001A 		bne	.L28
 385:../CX3RDKOV5640.c ****     {
 386:../CX3RDKOV5640.c ****         /* This is a produce event notification to the CPU. This notification is
 387:../CX3RDKOV5640.c ****          * received upon reception of every buffer. The buffer will not be sent
 388:../CX3RDKOV5640.c ****          * out unless it is explicitly committed. The call shall fail if there
 389:../CX3RDKOV5640.c ****          * is a bus reset / usb disconnect or if there is any application error. */
 390:../CX3RDKOV5640.c **** 
 391:../CX3RDKOV5640.c ****         /* Disable USB 3.0 LPM while Buffer is being transmitted out*/
 392:../CX3RDKOV5640.c ****         if ((CyU3PUsbGetSpeed () == CY_U3P_SUPER_SPEED) && (doLpmDisable))
 769              		.loc 1 392 0
 770 0030 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 771 0034 0030A0E1 		mov	r3, r0
 772 0038 030053E3 		cmp	r3, #3
 773 003c 0B00001A 		bne	.L29
 774              		.loc 1 392 0 is_stmt 0 discriminator 1
 775 0040 38339FE5 		ldr	r3, .L42
 776 0044 003093E5 		ldr	r3, [r3]
 777 0048 000053E3 		cmp	r3, #0
 778 004c 0700000A 		beq	.L29
 393:../CX3RDKOV5640.c ****         {
 394:../CX3RDKOV5640.c ****             CyU3PUsbLPMDisable ();
 779              		.loc 1 394 0 is_stmt 1
 780 0050 FEFFFFEB 		bl	CyU3PUsbLPMDisable
 395:../CX3RDKOV5640.c ****             CyU3PUsbSetLinkPowerState (CyU3PUsbLPM_U0);
 781              		.loc 1 395 0
 782 0054 0000A0E3 		mov	r0, #0
 783 0058 FEFFFFEB 		bl	CyU3PUsbSetLinkPowerState
 396:../CX3RDKOV5640.c ****             CyU3PBusyWait (200);
 784              		.loc 1 396 0
 785 005c C800A0E3 		mov	r0, #200
 786 0060 FEFFFFEB 		bl	CyFx3BusyWait
 397:../CX3RDKOV5640.c **** 
 398:../CX3RDKOV5640.c ****             doLpmDisable = CyFalse;
 787              		.loc 1 398 0
 788 0064 14339FE5 		ldr	r3, .L42
 789 0068 0020A0E3 		mov	r2, #0
 790 006c 002083E5 		str	r2, [r3]
 791              	.L29:
 399:../CX3RDKOV5640.c ****         }
 400:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
 401:../CX3RDKOV5640.c ****             CyU3PTimerStart (&UvcTimer);
 792              		.loc 1 401 0
 793 0070 0C039FE5 		ldr	r0, .L42+4
 794 0074 FEFFFFEB 		bl	_txe_timer_activate
 402:../CX3RDKOV5640.c **** #endif
 403:../CX3RDKOV5640.c **** 
 404:../CX3RDKOV5640.c ****         status = CyU3PDmaMultiChannelGetBuffer(chHandle, &DmaBuffer, CYU3P_NO_WAIT);
 795              		.loc 1 404 0
 796 0078 14304BE2 		sub	r3, fp, #20
 797 007c 18001BE5 		ldr	r0, [fp, #-24]
 798 0080 0310A0E1 		mov	r1, r3
 799 0084 0020A0E3 		mov	r2, #0
 800 0088 FEFFFFEB 		bl	CyU3PDmaMultiChannelGetBuffer
 801 008c 08000BE5 		str	r0, [fp, #-8]
 405:../CX3RDKOV5640.c **** #ifdef VISDebug
 406:../CX3RDKOV5640.c **** //    CyU3PDebugPrint (4, "\n\rAppDmaCallback:CY_U3P_DMA_CB_PROD_EVENT CyU3PDmaMultiChannelGetBuffe
 407:../CX3RDKOV5640.c **** #endif
 408:../CX3RDKOV5640.c ****         while (status == CY_U3P_SUCCESS)
 802              		.loc 1 408 0
 803 0090 3B0000EA 		b	.L30
 804              	.L35:
 409:../CX3RDKOV5640.c ****         {
 410:../CX3RDKOV5640.c ****             /* Add Headers*/
 411:../CX3RDKOV5640.c ****             if(DmaBuffer.count < ES_UVC_DATA_BUF_SIZE)
 805              		.loc 1 411 0
 806 0094 B0215BE1 		ldrh	r2, [fp, #-16]
 807 0098 E8329FE5 		ldr	r3, .L42+8
 808 009c B030D3E1 		ldrh	r3, [r3]
 809 00a0 030052E1 		cmp	r2, r3
 810 00a4 0800002A 		bcs	.L31
 412:../CX3RDKOV5640.c ****             {
 413:../CX3RDKOV5640.c ****                 esUVCUvcAddHeader ((DmaBuffer.buffer - ES_UVC_PROD_HEADER), ES_UVC_HEADER_EOF);
 811              		.loc 1 413 0
 812 00a8 14301BE5 		ldr	r3, [fp, #-20]
 813 00ac 0C3043E2 		sub	r3, r3, #12
 814 00b0 0300A0E1 		mov	r0, r3
 815 00b4 0210A0E3 		mov	r1, #2
 816 00b8 FEFFFFEB 		bl	esUVCUvcAddHeader
 414:../CX3RDKOV5640.c ****                 glHitFV = CyTrue;
 817              		.loc 1 414 0
 818 00bc C8329FE5 		ldr	r3, .L42+12
 819 00c0 0120A0E3 		mov	r2, #1
 820 00c4 002083E5 		str	r2, [r3]
 821 00c8 040000EA 		b	.L32
 822              	.L31:
 415:../CX3RDKOV5640.c **** #ifdef VISDebug
 416:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppDmaCallback:CY_U3P_DMA_CB_PROD_EVENT count %x glDMATxCount++ %x", D
 417:../CX3RDKOV5640.c **** #endif
 418:../CX3RDKOV5640.c **** 
 419:../CX3RDKOV5640.c ****             }
 420:../CX3RDKOV5640.c ****             else
 421:../CX3RDKOV5640.c ****             {
 422:../CX3RDKOV5640.c ****                 esUVCUvcAddHeader ((DmaBuffer.buffer - ES_UVC_PROD_HEADER), ES_UVC_HEADER_FRAME);
 823              		.loc 1 422 0
 824 00cc 14301BE5 		ldr	r3, [fp, #-20]
 825 00d0 0C3043E2 		sub	r3, r3, #12
 826 00d4 0300A0E1 		mov	r0, r3
 827 00d8 0010A0E3 		mov	r1, #0
 828 00dc FEFFFFEB 		bl	esUVCUvcAddHeader
 829              	.L32:
 423:../CX3RDKOV5640.c ****             }
 424:../CX3RDKOV5640.c **** 
 425:../CX3RDKOV5640.c ****             /* Commit Buffer to USB*/
 426:../CX3RDKOV5640.c ****             status = CyU3PDmaMultiChannelCommitBuffer (chHandle, (DmaBuffer.count + 12), 0);
 830              		.loc 1 426 0
 831 00e0 B0315BE1 		ldrh	r3, [fp, #-16]
 832 00e4 0C3083E2 		add	r3, r3, #12
 833 00e8 0338A0E1 		mov	r3, r3, asl #16
 834 00ec 2338A0E1 		mov	r3, r3, lsr #16
 835 00f0 18001BE5 		ldr	r0, [fp, #-24]
 836 00f4 0310A0E1 		mov	r1, r3
 837 00f8 0020A0E3 		mov	r2, #0
 838 00fc FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 839 0100 08000BE5 		str	r0, [fp, #-8]
 427:../CX3RDKOV5640.c ****             if (status != CY_U3P_SUCCESS)
 840              		.loc 1 427 0
 841 0104 08301BE5 		ldr	r3, [fp, #-8]
 842 0108 000053E3 		cmp	r3, #0
 843 010c 0500000A 		beq	.L33
 428:../CX3RDKOV5640.c ****             {
 429:../CX3RDKOV5640.c ****                    CyU3PEventSet(&glTimerEvent, ES_TIMER_RESET_EVENT,CYU3P_EVENT_OR);
 844              		.loc 1 429 0
 845 0110 78029FE5 		ldr	r0, .L42+16
 846 0114 1010A0E3 		mov	r1, #16
 847 0118 0020A0E3 		mov	r2, #0
 848 011c FEFFFFEB 		bl	_txe_event_flags_set
 430:../CX3RDKOV5640.c ****                    break;
 849              		.loc 1 430 0
 850 0120 0000A0E1 		mov	r0, r0	@ nop
 851 0124 930000EA 		b	.L27
 852              	.L33:
 431:../CX3RDKOV5640.c ****             }
 432:../CX3RDKOV5640.c ****             else
 433:../CX3RDKOV5640.c ****             {
 434:../CX3RDKOV5640.c ****                 glDMATxCount++;
 853              		.loc 1 434 0
 854 0128 64329FE5 		ldr	r3, .L42+20
 855 012c 003093E5 		ldr	r3, [r3]
 856 0130 012083E2 		add	r2, r3, #1
 857 0134 58329FE5 		ldr	r3, .L42+20
 858 0138 002083E5 		str	r2, [r3]
 435:../CX3RDKOV5640.c ****                 glDmaDone++;
 859              		.loc 1 435 0
 860 013c 54329FE5 		ldr	r3, .L42+24
 861 0140 003093E5 		ldr	r3, [r3]
 862 0144 012083E2 		add	r2, r3, #1
 863 0148 48329FE5 		ldr	r3, .L42+24
 864 014c 002083E5 		str	r2, [r3]
 436:../CX3RDKOV5640.c ****             }
 437:../CX3RDKOV5640.c **** 
 438:../CX3RDKOV5640.c ****             glActiveSocket ^= 1; /* Toggle the Active Socket */
 865              		.loc 1 438 0
 866 0150 44329FE5 		ldr	r3, .L42+28
 867 0154 0030D3E5 		ldrb	r3, [r3]
 868 0158 FF3003E2 		and	r3, r3, #255
 869 015c 013023E2 		eor	r3, r3, #1
 870 0160 FF2003E2 		and	r2, r3, #255
 871 0164 30329FE5 		ldr	r3, .L42+28
 872 0168 0020C3E5 		strb	r2, [r3]
 439:../CX3RDKOV5640.c ****             status = CyU3PDmaMultiChannelGetBuffer(chHandle, &DmaBuffer, CYU3P_NO_WAIT);
 873              		.loc 1 439 0
 874 016c 14304BE2 		sub	r3, fp, #20
 875 0170 18001BE5 		ldr	r0, [fp, #-24]
 876 0174 0310A0E1 		mov	r1, r3
 877 0178 0020A0E3 		mov	r2, #0
 878 017c FEFFFFEB 		bl	CyU3PDmaMultiChannelGetBuffer
 879 0180 08000BE5 		str	r0, [fp, #-8]
 880              	.L30:
 408:../CX3RDKOV5640.c ****         {
 881              		.loc 1 408 0 discriminator 1
 882 0184 08301BE5 		ldr	r3, [fp, #-8]
 883 0188 000053E3 		cmp	r3, #0
 884 018c C0FFFF0A 		beq	.L35
 885 0190 780000EA 		b	.L27
 886              	.L28:
 440:../CX3RDKOV5640.c ****         }
 441:../CX3RDKOV5640.c ****     }
 442:../CX3RDKOV5640.c ****     else if(type == CY_U3P_DMA_CB_CONS_EVENT)
 887              		.loc 1 442 0
 888 0194 BA315BE1 		ldrh	r3, [fp, #-26]
 889 0198 100053E3 		cmp	r3, #16
 890 019c 7500001A 		bne	.L27
 443:../CX3RDKOV5640.c ****     {
 444:../CX3RDKOV5640.c ****         glDmaDone--;
 891              		.loc 1 444 0
 892 01a0 F0319FE5 		ldr	r3, .L42+24
 893 01a4 003093E5 		ldr	r3, [r3]
 894 01a8 012043E2 		sub	r2, r3, #1
 895 01ac E4319FE5 		ldr	r3, .L42+24
 896 01b0 002083E5 		str	r2, [r3]
 445:../CX3RDKOV5640.c **** 
 446:../CX3RDKOV5640.c ****         /* Check if Frame is completely transferred */
 447:../CX3RDKOV5640.c ****         glIsStreamingStarted = CyTrue;
 897              		.loc 1 447 0
 898 01b4 E4319FE5 		ldr	r3, .L42+32
 899 01b8 0120A0E3 		mov	r2, #1
 900 01bc 002083E5 		str	r2, [r3]
 448:../CX3RDKOV5640.c **** 
 449:../CX3RDKOV5640.c ****         if((glHitFV == CyTrue) && (glDmaDone == 0))
 901              		.loc 1 449 0
 902 01c0 C4319FE5 		ldr	r3, .L42+12
 903 01c4 003093E5 		ldr	r3, [r3]
 904 01c8 010053E3 		cmp	r3, #1
 905 01cc 6900001A 		bne	.L27
 906              		.loc 1 449 0 is_stmt 0 discriminator 1
 907 01d0 C0319FE5 		ldr	r3, .L42+24
 908 01d4 003093E5 		ldr	r3, [r3]
 909 01d8 000053E3 		cmp	r3, #0
 910 01dc 6500001A 		bne	.L27
 450:../CX3RDKOV5640.c ****         {
 451:../CX3RDKOV5640.c ****             glHitFV = CyFalse;
 911              		.loc 1 451 0 is_stmt 1
 912 01e0 A4319FE5 		ldr	r3, .L42+12
 913 01e4 0020A0E3 		mov	r2, #0
 914 01e8 002083E5 		str	r2, [r3]
 452:../CX3RDKOV5640.c ****             glDMATxCount=0;
 915              		.loc 1 452 0
 916 01ec A0319FE5 		ldr	r3, .L42+20
 917 01f0 0020A0E3 		mov	r2, #0
 918 01f4 002083E5 		str	r2, [r3]
 453:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
 454:../CX3RDKOV5640.c ****             CyU3PTimerStop (&UvcTimer);
 919              		.loc 1 454 0
 920 01f8 84019FE5 		ldr	r0, .L42+4
 921 01fc FEFFFFEB 		bl	_txe_timer_deactivate
 455:../CX3RDKOV5640.c **** #endif
 456:../CX3RDKOV5640.c **** 
 457:../CX3RDKOV5640.c ****             if (glActiveSocket)
 922              		.loc 1 457 0
 923 0200 94319FE5 		ldr	r3, .L42+28
 924 0204 0030D3E5 		ldrb	r3, [r3]
 925 0208 FF3003E2 		and	r3, r3, #255
 926 020c 000053E3 		cmp	r3, #0
 927 0210 0700000A 		beq	.L37
 458:../CX3RDKOV5640.c ****                 CyU3PGpifSMSwitch(ES_UVC_INVALID_GPIF_STATE, CX3_START_SCK1,
 928              		.loc 1 458 0
 929 0214 0230A0E3 		mov	r3, #2
 930 0218 00308DE5 		str	r3, [sp]
 931 021c 80019FE5 		ldr	r0, .L42+36
 932 0220 0D10A0E3 		mov	r1, #13
 933 0224 78219FE5 		ldr	r2, .L42+36
 934 0228 0030A0E3 		mov	r3, #0
 935 022c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 936 0230 060000EA 		b	.L38
 937              	.L37:
 459:../CX3RDKOV5640.c ****                 		ES_UVC_INVALID_GPIF_STATE, ALPHA_CX3_START_SCK1, ES_UVC_GPIF_SWITCH_TIMEOUT);
 460:../CX3RDKOV5640.c ****             else
 461:../CX3RDKOV5640.c ****                 CyU3PGpifSMSwitch(ES_UVC_INVALID_GPIF_STATE, CX3_START_SCK0,
 938              		.loc 1 461 0
 939 0234 0230A0E3 		mov	r3, #2
 940 0238 00308DE5 		str	r3, [sp]
 941 023c 60019FE5 		ldr	r0, .L42+36
 942 0240 0010A0E3 		mov	r1, #0
 943 0244 58219FE5 		ldr	r2, .L42+36
 944 0248 0030A0E3 		mov	r3, #0
 945 024c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 946              	.L38:
 462:../CX3RDKOV5640.c ****                 		ES_UVC_INVALID_GPIF_STATE, ALPHA_CX3_START_SCK0, ES_UVC_GPIF_SWITCH_TIMEOUT);
 463:../CX3RDKOV5640.c **** #ifdef VISDebug
 464:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppDmaCallback:CY_U3P_DMA_CB_CONS_EVENT glActiveSocket  %x", glActiveS
 465:../CX3RDKOV5640.c **** #endif
 466:../CX3RDKOV5640.c ****             CyU3PUsbLPMEnable ();
 947              		.loc 1 466 0
 948 0250 FEFFFFEB 		bl	CyU3PUsbLPMEnable
 467:../CX3RDKOV5640.c ****             doLpmDisable = CyTrue;
 949              		.loc 1 467 0
 950 0254 24319FE5 		ldr	r3, .L42
 951 0258 0120A0E3 		mov	r2, #1
 952 025c 002083E5 		str	r2, [r3]
 468:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
 469:../CX3RDKOV5640.c ****             CyU3PTimerModify (&UvcTimer, TIMER_PERIOD, 0);
 953              		.loc 1 469 0
 954 0260 1C019FE5 		ldr	r0, .L42+4
 955 0264 7D1FA0E3 		mov	r1, #500
 956 0268 0020A0E3 		mov	r2, #0
 957 026c FEFFFFEB 		bl	_txe_timer_change
 470:../CX3RDKOV5640.c **** #endif
 471:../CX3RDKOV5640.c **** 
 472:../CX3RDKOV5640.c ****             if(glStillCaptured == CyTrue)
 958              		.loc 1 472 0
 959 0270 30319FE5 		ldr	r3, .L42+40
 960 0274 003093E5 		ldr	r3, [r3]
 961 0278 010053E3 		cmp	r3, #1
 962 027c 1000001A 		bne	.L39
 473:../CX3RDKOV5640.c ****             {
 474:../CX3RDKOV5640.c ****             	glStillCaptured = CyFalse;
 963              		.loc 1 474 0
 964 0280 20319FE5 		ldr	r3, .L42+40
 965 0284 0020A0E3 		mov	r2, #0
 966 0288 002083E5 		str	r2, [r3]
 475:../CX3RDKOV5640.c ****             	glUVCHeader[1]^=ES_UVC_HEADER_STILL_IMAGE;
 967              		.loc 1 475 0
 968 028c 18319FE5 		ldr	r3, .L42+44
 969 0290 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 970 0294 203023E2 		eor	r3, r3, #32
 971 0298 FF2003E2 		and	r2, r3, #255
 972 029c 08319FE5 		ldr	r3, .L42+44
 973 02a0 0120C3E5 		strb	r2, [r3, #1]
 476:../CX3RDKOV5640.c ****             	glFrameIndexToSet = glCurrentFrameIndex;
 974              		.loc 1 476 0
 975 02a4 04319FE5 		ldr	r3, .L42+48
 976 02a8 0020D3E5 		ldrb	r2, [r3]	@ zero_extendqisi2
 977 02ac 00319FE5 		ldr	r3, .L42+52
 978 02b0 0020C3E5 		strb	r2, [r3]
 477:../CX3RDKOV5640.c ****             	CyU3PEventSet(&glTimerEvent, ES_TIMER_RESET_EVENT,CYU3P_EVENT_OR);
 979              		.loc 1 477 0
 980 02b4 D4009FE5 		ldr	r0, .L42+16
 981 02b8 1010A0E3 		mov	r1, #16
 982 02bc 0020A0E3 		mov	r2, #0
 983 02c0 FEFFFFEB 		bl	_txe_event_flags_set
 984              	.L39:
 478:../CX3RDKOV5640.c ****             }
 479:../CX3RDKOV5640.c ****             if(glStillCaptureStart == CyTrue)
 985              		.loc 1 479 0
 986 02c4 EC309FE5 		ldr	r3, .L42+56
 987 02c8 003093E5 		ldr	r3, [r3]
 988 02cc 010053E3 		cmp	r3, #1
 989 02d0 2800001A 		bne	.L27
 480:../CX3RDKOV5640.c ****             {
 481:../CX3RDKOV5640.c ****             	if(glStillSkip == 3)
 990              		.loc 1 481 0
 991 02d4 E0309FE5 		ldr	r3, .L42+60
 992 02d8 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 993 02dc 030053E3 		cmp	r3, #3
 994 02e0 0D00001A 		bne	.L40
 482:../CX3RDKOV5640.c **** 				{
 483:../CX3RDKOV5640.c ****             		glStillSkip--;
 995              		.loc 1 483 0
 996 02e4 D0309FE5 		ldr	r3, .L42+60
 997 02e8 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 998 02ec 013043E2 		sub	r3, r3, #1
 999 02f0 FF2003E2 		and	r2, r3, #255
 1000 02f4 C0309FE5 		ldr	r3, .L42+60
 1001 02f8 0020C3E5 		strb	r2, [r3]
 484:../CX3RDKOV5640.c ****             		glFrameIndexToSet = 4;
 1002              		.loc 1 484 0
 1003 02fc B0309FE5 		ldr	r3, .L42+52
 1004 0300 0420A0E3 		mov	r2, #4
 1005 0304 0020C3E5 		strb	r2, [r3]
 485:../CX3RDKOV5640.c **** 					CyU3PEventSet(&glTimerEvent, ES_TIMER_RESET_EVENT,CYU3P_EVENT_OR);
 1006              		.loc 1 485 0
 1007 0308 80009FE5 		ldr	r0, .L42+16
 1008 030c 1010A0E3 		mov	r1, #16
 1009 0310 0020A0E3 		mov	r2, #0
 1010 0314 FEFFFFEB 		bl	_txe_event_flags_set
 1011 0318 160000EA 		b	.L27
 1012              	.L40:
 486:../CX3RDKOV5640.c **** 				}
 487:../CX3RDKOV5640.c ****             	else if(glStillSkip == 0)
 1013              		.loc 1 487 0
 1014 031c 98309FE5 		ldr	r3, .L42+60
 1015 0320 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1016 0324 000053E3 		cmp	r3, #0
 1017 0328 0C00001A 		bne	.L41
 488:../CX3RDKOV5640.c ****             	{
 489:../CX3RDKOV5640.c ****             		glStillCaptureStart = CyFalse;
 1018              		.loc 1 489 0
 1019 032c 84309FE5 		ldr	r3, .L42+56
 1020 0330 0020A0E3 		mov	r2, #0
 1021 0334 002083E5 		str	r2, [r3]
 490:../CX3RDKOV5640.c **** 					glStillCaptured = CyTrue;
 1022              		.loc 1 490 0
 1023 0338 68309FE5 		ldr	r3, .L42+40
 1024 033c 0120A0E3 		mov	r2, #1
 1025 0340 002083E5 		str	r2, [r3]
 491:../CX3RDKOV5640.c **** 					glUVCHeader[1]^=ES_UVC_HEADER_STILL_IMAGE;
 1026              		.loc 1 491 0
 1027 0344 60309FE5 		ldr	r3, .L42+44
 1028 0348 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1029 034c 203023E2 		eor	r3, r3, #32
 1030 0350 FF2003E2 		and	r2, r3, #255
 1031 0354 50309FE5 		ldr	r3, .L42+44
 1032 0358 0120C3E5 		strb	r2, [r3, #1]
 1033 035c 050000EA 		b	.L27
 1034              	.L41:
 492:../CX3RDKOV5640.c ****             	}
 493:../CX3RDKOV5640.c ****             	else
 494:../CX3RDKOV5640.c ****             		glStillSkip--;
 1035              		.loc 1 494 0
 1036 0360 54309FE5 		ldr	r3, .L42+60
 1037 0364 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1038 0368 013043E2 		sub	r3, r3, #1
 1039 036c FF2003E2 		and	r2, r3, #255
 1040 0370 44309FE5 		ldr	r3, .L42+60
 1041 0374 0020C3E5 		strb	r2, [r3]
 1042              	.L27:
 495:../CX3RDKOV5640.c ****             }
 496:../CX3RDKOV5640.c ****         }
 497:../CX3RDKOV5640.c ****     }
 498:../CX3RDKOV5640.c **** }
 1043              		.loc 1 498 0
 1044 0378 04D04BE2 		sub	sp, fp, #4
 1045              		@ sp needed
 1046 037c 0088BDE8 		ldmfd	sp!, {fp, pc}
 1047              	.L43:
 1048              		.align	2
 1049              	.L42:
 1050 0380 00000000 		.word	doLpmDisable
 1051 0384 00000000 		.word	UvcTimer
 1052 0388 00000000 		.word	ES_UVC_DATA_BUF_SIZE
 1053 038c 00000000 		.word	glHitFV
 1054 0390 00000000 		.word	glTimerEvent
 1055 0394 00000000 		.word	glDMATxCount
 1056 0398 00000000 		.word	glDmaDone
 1057 039c 00000000 		.word	glActiveSocket
 1058 03a0 00000000 		.word	glIsStreamingStarted
 1059 03a4 01010000 		.word	257
 1060 03a8 00000000 		.word	glStillCaptured
 1061 03ac 00000000 		.word	glUVCHeader
 1062 03b0 00000000 		.word	glCurrentFrameIndex
 1063 03b4 00000000 		.word	glFrameIndexToSet
 1064 03b8 00000000 		.word	glStillCaptureStart
 1065 03bc 00000000 		.word	glStillSkip
 1066              		.cfi_endproc
 1067              	.LFE6:
 1069              		.section	.text.esUVCUvcApplnUSBEventCB,"ax",%progbits
 1070              		.align	2
 1072              	esUVCUvcApplnUSBEventCB:
 1073              	.LFB7:
 499:../CX3RDKOV5640.c **** 
 500:../CX3RDKOV5640.c **** /* This is the Callback function to handle the USB Events */
 501:../CX3RDKOV5640.c ****     static void
 502:../CX3RDKOV5640.c **** esUVCUvcApplnUSBEventCB (
 503:../CX3RDKOV5640.c ****         CyU3PUsbEventType_t evtype,     /* Event type */
 504:../CX3RDKOV5640.c ****         uint16_t            evdata      /* Event data */
 505:../CX3RDKOV5640.c ****         )
 506:../CX3RDKOV5640.c **** {
 1074              		.loc 1 506 0
 1075              		.cfi_startproc
 1076              		@ args = 0, pretend = 0, frame = 16
 1077              		@ frame_needed = 1, uses_anonymous_args = 0
 1078 0000 00482DE9 		stmfd	sp!, {fp, lr}
 1079              	.LCFI14:
 1080              		.cfi_def_cfa_offset 8
 1081              		.cfi_offset 11, -8
 1082              		.cfi_offset 14, -4
 1083 0004 04B08DE2 		add	fp, sp, #4
 1084              	.LCFI15:
 1085              		.cfi_def_cfa 11, 4
 1086 0008 10D04DE2 		sub	sp, sp, #16
 1087 000c 0020A0E1 		mov	r2, r0
 1088 0010 0130A0E1 		mov	r3, r1
 1089 0014 0D204BE5 		strb	r2, [fp, #-13]
 1090 0018 B0314BE1 		strh	r3, [fp, #-16]	@ movhi
 507:../CX3RDKOV5640.c ****     uint8_t interface = 0, altSetting = 0;
 1091              		.loc 1 507 0
 1092 001c 0030A0E3 		mov	r3, #0
 1093 0020 05304BE5 		strb	r3, [fp, #-5]
 1094 0024 0030A0E3 		mov	r3, #0
 1095 0028 06304BE5 		strb	r3, [fp, #-6]
 508:../CX3RDKOV5640.c **** 
 509:../CX3RDKOV5640.c ****     switch (evtype)
 1096              		.loc 1 509 0
 1097 002c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1098 0030 070053E3 		cmp	r3, #7
 1099 0034 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1100 0038 530000EA 		b	.L57
 1101              	.L47:
 1102 003c 2C010000 		.word	.L46
 1103 0040 2C010000 		.word	.L46
 1104 0044 5C000000 		.word	.L48
 1105 0048 8C010000 		.word	.L57
 1106 004c 2C010000 		.word	.L46
 1107 0050 2C010000 		.word	.L46
 1108 0054 8C010000 		.word	.L57
 1109 0058 7C000000 		.word	.L49
 1110              	.L48:
 510:../CX3RDKOV5640.c ****     {
 511:../CX3RDKOV5640.c ****         case CY_U3P_USB_EVENT_SUSPEND:
 512:../CX3RDKOV5640.c ****             /* Suspend the device with Wake On Bus Activity set */
 513:../CX3RDKOV5640.c ****             glIsStreamingStarted = CyFalse;
 1111              		.loc 1 513 0
 1112 005c 34319FE5 		ldr	r3, .L58
 1113 0060 0020A0E3 		mov	r2, #0
 1114 0064 002083E5 		str	r2, [r3]
 514:../CX3RDKOV5640.c ****             CyU3PEventSet (&glTimerEvent, ES_USB_SUSP_EVENT_FLAG, CYU3P_EVENT_OR);
 1115              		.loc 1 514 0
 1116 0068 2C019FE5 		ldr	r0, .L58+4
 1117 006c 2010A0E3 		mov	r1, #32
 1118 0070 0020A0E3 		mov	r2, #0
 1119 0074 FEFFFFEB 		bl	_txe_event_flags_set
 515:../CX3RDKOV5640.c ****             break;
 1120              		.loc 1 515 0
 1121 0078 440000EA 		b	.L44
 1122              	.L49:
 516:../CX3RDKOV5640.c ****         case CY_U3P_USB_EVENT_SETINTF:
 517:../CX3RDKOV5640.c ****             /* Start the video streamer application if the
 518:../CX3RDKOV5640.c ****              * interface requested was 1. If not, stop the
 519:../CX3RDKOV5640.c ****              * streamer. */
 520:../CX3RDKOV5640.c ****             interface = CY_U3P_GET_MSB(evdata);
 1123              		.loc 1 520 0
 1124 007c B0315BE1 		ldrh	r3, [fp, #-16]
 1125 0080 2334A0E1 		mov	r3, r3, lsr #8
 1126 0084 0338A0E1 		mov	r3, r3, asl #16
 1127 0088 2338A0E1 		mov	r3, r3, lsr #16
 1128 008c 05304BE5 		strb	r3, [fp, #-5]
 521:../CX3RDKOV5640.c ****             altSetting = CY_U3P_GET_LSB(evdata);
 1129              		.loc 1 521 0
 1130 0090 B0315BE1 		ldrh	r3, [fp, #-16]	@ movhi
 1131 0094 06304BE5 		strb	r3, [fp, #-6]
 522:../CX3RDKOV5640.c **** 
 523:../CX3RDKOV5640.c ****             glIsStreamingStarted = CyFalse;
 1132              		.loc 1 523 0
 1133 0098 F8309FE5 		ldr	r3, .L58
 1134 009c 0020A0E3 		mov	r2, #0
 1135 00a0 002083E5 		str	r2, [r3]
 524:../CX3RDKOV5640.c **** 
 525:../CX3RDKOV5640.c ****             if ((altSetting == ES_UVC_STREAM_INTERFACE) && (interface == 1))
 1136              		.loc 1 525 0
 1137 00a4 06305BE5 		ldrb	r3, [fp, #-6]	@ zero_extendqisi2
 1138 00a8 010053E3 		cmp	r3, #1
 1139 00ac 0C00001A 		bne	.L51
 1140              		.loc 1 525 0 is_stmt 0 discriminator 1
 1141 00b0 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1142 00b4 010053E3 		cmp	r3, #1
 1143 00b8 0900001A 		bne	.L51
 526:../CX3RDKOV5640.c ****             {
 527:../CX3RDKOV5640.c ****                 /* Stop the application before re-starting. */
 528:../CX3RDKOV5640.c ****                 if (glIsApplnActive)
 1144              		.loc 1 528 0 is_stmt 1
 1145 00bc DC309FE5 		ldr	r3, .L58+8
 1146 00c0 003093E5 		ldr	r3, [r3]
 1147 00c4 000053E3 		cmp	r3, #0
 1148 00c8 0300000A 		beq	.L52
 529:../CX3RDKOV5640.c ****                 {
 530:../CX3RDKOV5640.c ****                 	glIsClearFeature = CyTrue;
 1149              		.loc 1 530 0
 1150 00cc D0309FE5 		ldr	r3, .L58+12
 1151 00d0 0120A0E3 		mov	r2, #1
 1152 00d4 002083E5 		str	r2, [r3]
 531:../CX3RDKOV5640.c ****                     esUVCUvcApplnStop ();
 1153              		.loc 1 531 0
 1154 00d8 FEFFFFEB 		bl	esUVCUvcApplnStop
 1155              	.L52:
 532:../CX3RDKOV5640.c **** #ifdef VISDebug
 533:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rCY_U3P_USB_EVENT_SETINTF&ES_UVC_STREAM_INTERFACE: esUVCUvcApplnStop");
 534:../CX3RDKOV5640.c **** #endif
 535:../CX3RDKOV5640.c ****                 }
 536:../CX3RDKOV5640.c ****                 esUVCUvcApplnStart ();
 1156              		.loc 1 536 0
 1157 00dc FEFFFFEB 		bl	esUVCUvcApplnStart
 1158 00e0 100000EA 		b	.L53
 1159              	.L51:
 537:../CX3RDKOV5640.c **** #ifdef VISDebug
 538:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rCY_U3P_USB_EVENT_SETINTF&ES_UVC_STREAM_INTERFACE: esUVCUvcApplnStart")
 539:../CX3RDKOV5640.c **** #endif
 540:../CX3RDKOV5640.c **** 
 541:../CX3RDKOV5640.c ****             }
 542:../CX3RDKOV5640.c ****             else if ((altSetting == 0x00) && (interface == 1))
 1160              		.loc 1 542 0
 1161 00e4 06305BE5 		ldrb	r3, [fp, #-6]	@ zero_extendqisi2
 1162 00e8 000053E3 		cmp	r3, #0
 1163 00ec 0D00001A 		bne	.L53
 1164              		.loc 1 542 0 is_stmt 0 discriminator 1
 1165 00f0 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1166 00f4 010053E3 		cmp	r3, #1
 1167 00f8 0A00001A 		bne	.L53
 543:../CX3RDKOV5640.c ****             {
 544:../CX3RDKOV5640.c ****             	glPreviewStarted = CyFalse;
 1168              		.loc 1 544 0 is_stmt 1
 1169 00fc A4309FE5 		ldr	r3, .L58+16
 1170 0100 0020A0E3 		mov	r2, #0
 1171 0104 002083E5 		str	r2, [r3]
 545:../CX3RDKOV5640.c ****             	/* Stop the application before re-starting. */
 546:../CX3RDKOV5640.c ****             	glIsClearFeature = CyTrue;
 1172              		.loc 1 546 0
 1173 0108 94309FE5 		ldr	r3, .L58+12
 1174 010c 0120A0E3 		mov	r2, #1
 1175 0110 002083E5 		str	r2, [r3]
 547:../CX3RDKOV5640.c **** 				esUVCUvcApplnStop ();
 1176              		.loc 1 547 0
 1177 0114 FEFFFFEB 		bl	esUVCUvcApplnStop
 548:../CX3RDKOV5640.c **** 
 549:../CX3RDKOV5640.c **** 				glcommitcount = 0;
 1178              		.loc 1 549 0
 1179 0118 8C309FE5 		ldr	r3, .L58+20
 1180 011c 0020A0E3 		mov	r2, #0
 1181 0120 0020C3E5 		strb	r2, [r3]
 550:../CX3RDKOV5640.c **** #ifdef VISDebug
 551:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rCY_U3P_USB_EVENT_SETINTF: esUVCUvcApplnStop");
 552:../CX3RDKOV5640.c **** #endif
 553:../CX3RDKOV5640.c ****             }
 554:../CX3RDKOV5640.c ****             break;
 1182              		.loc 1 554 0
 1183 0124 190000EA 		b	.L44
 1184              	.L53:
 1185 0128 180000EA 		b	.L44
 1186              	.L46:
 555:../CX3RDKOV5640.c **** 
 556:../CX3RDKOV5640.c ****             /* Fall-through. */
 557:../CX3RDKOV5640.c **** 
 558:../CX3RDKOV5640.c ****         case CY_U3P_USB_EVENT_SETCONF:
 559:../CX3RDKOV5640.c ****         case CY_U3P_USB_EVENT_RESET:
 560:../CX3RDKOV5640.c ****         case CY_U3P_USB_EVENT_DISCONNECT:
 561:../CX3RDKOV5640.c ****         case CY_U3P_USB_EVENT_CONNECT:
 562:../CX3RDKOV5640.c ****             glIsStreamingStarted = CyFalse;
 1187              		.loc 1 562 0
 1188 012c 64309FE5 		ldr	r3, .L58
 1189 0130 0020A0E3 		mov	r2, #0
 1190 0134 002083E5 		str	r2, [r3]
 563:../CX3RDKOV5640.c ****             if (evtype == CY_U3P_USB_EVENT_SETCONF)
 1191              		.loc 1 563 0
 1192 0138 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1193 013c 050053E3 		cmp	r3, #5
 1194 0140 0300001A 		bne	.L54
 564:../CX3RDKOV5640.c ****                 glIsConfigured = CyTrue;
 1195              		.loc 1 564 0
 1196 0144 64309FE5 		ldr	r3, .L58+24
 1197 0148 0120A0E3 		mov	r2, #1
 1198 014c 002083E5 		str	r2, [r3]
 1199 0150 020000EA 		b	.L55
 1200              	.L54:
 565:../CX3RDKOV5640.c ****             else
 566:../CX3RDKOV5640.c ****                 glIsConfigured = CyFalse;
 1201              		.loc 1 566 0
 1202 0154 54309FE5 		ldr	r3, .L58+24
 1203 0158 0020A0E3 		mov	r2, #0
 1204 015c 002083E5 		str	r2, [r3]
 1205              	.L55:
 567:../CX3RDKOV5640.c **** 
 568:../CX3RDKOV5640.c ****             /* Stop the video streamer application and enable LPM. */
 569:../CX3RDKOV5640.c ****             CyU3PUsbLPMEnable ();
 1206              		.loc 1 569 0
 1207 0160 FEFFFFEB 		bl	CyU3PUsbLPMEnable
 570:../CX3RDKOV5640.c ****             if (glIsApplnActive)
 1208              		.loc 1 570 0
 1209 0164 34309FE5 		ldr	r3, .L58+8
 1210 0168 003093E5 		ldr	r3, [r3]
 1211 016c 000053E3 		cmp	r3, #0
 1212 0170 0400000A 		beq	.L56
 571:../CX3RDKOV5640.c ****             {
 572:../CX3RDKOV5640.c ****             	glIsClearFeature = CyTrue;
 1213              		.loc 1 572 0
 1214 0174 28309FE5 		ldr	r3, .L58+12
 1215 0178 0120A0E3 		mov	r2, #1
 1216 017c 002083E5 		str	r2, [r3]
 573:../CX3RDKOV5640.c ****                 esUVCUvcApplnStop ();
 1217              		.loc 1 573 0
 1218 0180 FEFFFFEB 		bl	esUVCUvcApplnStop
 574:../CX3RDKOV5640.c **** #ifdef VISDebug
 575:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rEvent %x: esUVCUvcApplnStop", evtype);
 576:../CX3RDKOV5640.c **** #endif
 577:../CX3RDKOV5640.c ****             }
 578:../CX3RDKOV5640.c ****             break;
 1219              		.loc 1 578 0
 1220 0184 010000EA 		b	.L44
 1221              	.L56:
 1222 0188 000000EA 		b	.L44
 1223              	.L57:
 579:../CX3RDKOV5640.c ****         default:
 580:../CX3RDKOV5640.c ****             break;
 1224              		.loc 1 580 0
 1225 018c 0000A0E1 		mov	r0, r0	@ nop
 1226              	.L44:
 581:../CX3RDKOV5640.c ****     }
 582:../CX3RDKOV5640.c **** }
 1227              		.loc 1 582 0
 1228 0190 04D04BE2 		sub	sp, fp, #4
 1229              		@ sp needed
 1230 0194 0088BDE8 		ldmfd	sp!, {fp, pc}
 1231              	.L59:
 1232              		.align	2
 1233              	.L58:
 1234 0198 00000000 		.word	glIsStreamingStarted
 1235 019c 00000000 		.word	glTimerEvent
 1236 01a0 00000000 		.word	glIsApplnActive
 1237 01a4 00000000 		.word	glIsClearFeature
 1238 01a8 00000000 		.word	glPreviewStarted
 1239 01ac 00000000 		.word	glcommitcount
 1240 01b0 00000000 		.word	glIsConfigured
 1241              		.cfi_endproc
 1242              	.LFE7:
 1244              		.section	.text.esUVCApplnLPMRqtCB,"ax",%progbits
 1245              		.align	2
 1247              	esUVCApplnLPMRqtCB:
 1248              	.LFB8:
 583:../CX3RDKOV5640.c **** 
 584:../CX3RDKOV5640.c **** /* Callback for LPM requests. Always return true to allow host to transition device
 585:../CX3RDKOV5640.c ****  * into required LPM state U1/U2/U3. When data transmission is active LPM management
 586:../CX3RDKOV5640.c ****  * is explicitly disabled to prevent data transmission errors.
 587:../CX3RDKOV5640.c ****  */
 588:../CX3RDKOV5640.c **** static CyBool_t esUVCApplnLPMRqtCB (
 589:../CX3RDKOV5640.c ****         CyU3PUsbLinkPowerMode link_mode         /*USB 3.0 linkmode requested by Host */
 590:../CX3RDKOV5640.c ****         )
 591:../CX3RDKOV5640.c **** {
 1249              		.loc 1 591 0
 1250              		.cfi_startproc
 1251              		@ args = 0, pretend = 0, frame = 8
 1252              		@ frame_needed = 1, uses_anonymous_args = 0
 1253              		@ link register save eliminated.
 1254 0000 04B02DE5 		str	fp, [sp, #-4]!
 1255              	.LCFI16:
 1256              		.cfi_def_cfa_offset 4
 1257              		.cfi_offset 11, -4
 1258 0004 00B08DE2 		add	fp, sp, #0
 1259              	.LCFI17:
 1260              		.cfi_def_cfa_register 11
 1261 0008 0CD04DE2 		sub	sp, sp, #12
 1262 000c 0030A0E1 		mov	r3, r0
 1263 0010 05304BE5 		strb	r3, [fp, #-5]
 592:../CX3RDKOV5640.c ****     return CyTrue;
 1264              		.loc 1 592 0
 1265 0014 0130A0E3 		mov	r3, #1
 593:../CX3RDKOV5640.c **** }
 1266              		.loc 1 593 0
 1267 0018 0300A0E1 		mov	r0, r3
 1268 001c 00D04BE2 		sub	sp, fp, #0
 1269              		@ sp needed
 1270 0020 04B09DE4 		ldr	fp, [sp], #4
 1271 0024 1EFF2FE1 		bx	lr
 1272              		.cfi_endproc
 1273              	.LFE8:
 1275              		.section	.rodata
 1276              		.align	2
 1277              	.LC5:
 1278 00a8 0A0D6573 		.ascii	"\012\015esSetCameraResolution %d\000"
 1278      53657443 
 1278      616D6572 
 1278      61526573 
 1278      6F6C7574 
 1279 00c3 00       		.align	2
 1280              	.LC6:
 1281 00c4 0A0D5553 		.ascii	"\012\015USBStpCB:SetIntfParams SS1 Err = 0x%x\000"
 1281      42537470 
 1281      43423A53 
 1281      6574496E 
 1281      74665061 
 1282              		.align	2
 1283              	.LC7:
 1284 00ec 0A0D5553 		.ascii	"\012\015USBStpCB:SetIntfParams FS Err = 0x%x\000"
 1284      42537470 
 1284      43423A53 
 1284      6574496E 
 1284      74665061 
 1285 0113 00       		.align	2
 1286              	.LC8:
 1287 0114 0A0D5553 		.ascii	"\012\015USBStpCB:SetIntfParams SS2 Err = 0x%x\000"
 1287      42537470 
 1287      43423A53 
 1287      6574496E 
 1287      74665061 
 1288              		.align	2
 1289              	.LC9:
 1290 013c 0A0D5553 		.ascii	"\012\015USBStpCB:SetIntfParams HS Err = 0x%x\000"
 1290      42537470 
 1290      43423A53 
 1290      6574496E 
 1290      74665061 
 1291              		.section	.text.esSetCameraResolution,"ax",%progbits
 1292              		.align	2
 1293              		.global	esSetCameraResolution
 1295              	esSetCameraResolution:
 1296              	.LFB9:
 594:../CX3RDKOV5640.c **** 
 595:../CX3RDKOV5640.c **** //TODO Change this function with "Sensor Specific" function to write the sensor settings & configur
 596:../CX3RDKOV5640.c **** void esSetCameraResolution(uint8_t FrameIndex)
 597:../CX3RDKOV5640.c **** {
 1297              		.loc 1 597 0
 1298              		.cfi_startproc
 1299              		@ args = 0, pretend = 0, frame = 16
 1300              		@ frame_needed = 1, uses_anonymous_args = 0
 1301 0000 00482DE9 		stmfd	sp!, {fp, lr}
 1302              	.LCFI18:
 1303              		.cfi_def_cfa_offset 8
 1304              		.cfi_offset 11, -8
 1305              		.cfi_offset 14, -4
 1306 0004 04B08DE2 		add	fp, sp, #4
 1307              	.LCFI19:
 1308              		.cfi_def_cfa 11, 4
 1309 0008 10D04DE2 		sub	sp, sp, #16
 1310 000c 0030A0E1 		mov	r3, r0
 1311 0010 0D304BE5 		strb	r3, [fp, #-13]
 598:../CX3RDKOV5640.c **** 	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 1312              		.loc 1 598 0
 1313 0014 0030A0E3 		mov	r3, #0
 1314 0018 08300BE5 		str	r3, [fp, #-8]
 599:../CX3RDKOV5640.c **** 	CyU3PDebugPrint (4, "\n\resSetCameraResolution %d", FrameIndex);
 1315              		.loc 1 599 0
 1316 001c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1317 0020 0400A0E3 		mov	r0, #4
 1318 0024 98119FE5 		ldr	r1, .L75
 1319 0028 0320A0E1 		mov	r2, r3
 1320 002c FEFFFFEB 		bl	CyU3PDebugPrint
 600:../CX3RDKOV5640.c **** 	FrameIndex = 0x03; //force to set VGA 30fps -debug
 1321              		.loc 1 600 0
 1322 0030 0330A0E3 		mov	r3, #3
 1323 0034 0D304BE5 		strb	r3, [fp, #-13]
 601:../CX3RDKOV5640.c **** 	/* Super Speed USB Streams*/
 602:../CX3RDKOV5640.c **** 	if (CyU3PUsbGetSpeed () == CY_U3P_SUPER_SPEED)
 1324              		.loc 1 602 0
 1325 0038 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1326 003c 0030A0E1 		mov	r3, r0
 1327 0040 030053E3 		cmp	r3, #3
 1328 0044 3E00001A 		bne	.L63
 603:../CX3RDKOV5640.c **** 	{
 604:../CX3RDKOV5640.c **** 		if(FrameIndex == 0x01)
 1329              		.loc 1 604 0
 1330 0048 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1331 004c 010053E3 		cmp	r3, #1
 1332 0050 0C00001A 		bne	.L64
 605:../CX3RDKOV5640.c **** 		{
 606:../CX3RDKOV5640.c **** 			/* Write 1080pSettings */
 607:../CX3RDKOV5640.c **** 			status = CyU3PMipicsiSetIntfParams (&cfgUvc1080p30NoMclk, CyTrue/*CyFalse*/);
 1333              		.loc 1 607 0
 1334 0054 6C019FE5 		ldr	r0, .L75+4
 1335 0058 0110A0E3 		mov	r1, #1
 1336 005c FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 1337 0060 08000BE5 		str	r0, [fp, #-8]
 608:../CX3RDKOV5640.c **** 			if (status != CY_U3P_SUCCESS)
 1338              		.loc 1 608 0
 1339 0064 08301BE5 		ldr	r3, [fp, #-8]
 1340 0068 000053E3 		cmp	r3, #0
 1341 006c 0300000A 		beq	.L65
 609:../CX3RDKOV5640.c **** 			{
 610:../CX3RDKOV5640.c **** 				CyU3PDebugPrint (4, "\n\rUSBStpCB:SetIntfParams SS1 Err = 0x%x", status);
 1342              		.loc 1 610 0
 1343 0070 0400A0E3 		mov	r0, #4
 1344 0074 50119FE5 		ldr	r1, .L75+8
 1345 0078 08201BE5 		ldr	r2, [fp, #-8]
 1346 007c FEFFFFEB 		bl	CyU3PDebugPrint
 1347              	.L65:
 611:../CX3RDKOV5640.c **** 			}
 612:../CX3RDKOV5640.c **** 			esOV5640_1080P_config();
 1348              		.loc 1 612 0
 1349 0080 FEFFFFEB 		bl	esOV5640_1080P_config
 1350 0084 4C0000EA 		b	.L62
 1351              	.L64:
 613:../CX3RDKOV5640.c **** 		}
 614:../CX3RDKOV5640.c **** 		else if(FrameIndex == 0x02)
 1352              		.loc 1 614 0
 1353 0088 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1354 008c 020053E3 		cmp	r3, #2
 1355 0090 0C00001A 		bne	.L67
 615:../CX3RDKOV5640.c **** 		{
 616:../CX3RDKOV5640.c **** 			/* Write VGA Settings */
 617:../CX3RDKOV5640.c **** 			status = CyU3PMipicsiSetIntfParams (&cfgUvcVga30NoMclk, CyTrue/*CyFalse*/);
 1356              		.loc 1 617 0
 1357 0094 34019FE5 		ldr	r0, .L75+12
 1358 0098 0110A0E3 		mov	r1, #1
 1359 009c FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 1360 00a0 08000BE5 		str	r0, [fp, #-8]
 618:../CX3RDKOV5640.c **** 			if (status != CY_U3P_SUCCESS)
 1361              		.loc 1 618 0
 1362 00a4 08301BE5 		ldr	r3, [fp, #-8]
 1363 00a8 000053E3 		cmp	r3, #0
 1364 00ac 0300000A 		beq	.L68
 619:../CX3RDKOV5640.c **** 			{
 620:../CX3RDKOV5640.c **** 				CyU3PDebugPrint (4, "\n\rUSBStpCB:SetIntfParams FS Err = 0x%x", status);
 1365              		.loc 1 620 0
 1366 00b0 0400A0E3 		mov	r0, #4
 1367 00b4 18119FE5 		ldr	r1, .L75+16
 1368 00b8 08201BE5 		ldr	r2, [fp, #-8]
 1369 00bc FEFFFFEB 		bl	CyU3PDebugPrint
 1370              	.L68:
 621:../CX3RDKOV5640.c **** 			}
 622:../CX3RDKOV5640.c **** 			esOV5640_VGA_config(); //for experiment
 1371              		.loc 1 622 0
 1372 00c0 FEFFFFEB 		bl	esOV5640_VGA_config
 1373 00c4 3C0000EA 		b	.L62
 1374              	.L67:
 623:../CX3RDKOV5640.c **** 		}
 624:../CX3RDKOV5640.c **** 		else if(FrameIndex == 0x03)
 1375              		.loc 1 624 0
 1376 00c8 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1377 00cc 030053E3 		cmp	r3, #3
 1378 00d0 0B00001A 		bne	.L69
 625:../CX3RDKOV5640.c **** 		{
 626:../CX3RDKOV5640.c **** 			/* Write 720pSettings */
 627:../CX3RDKOV5640.c **** 			status = CyU3PMipicsiSetIntfParams (&cfgUvc720p60NoMclk, CyTrue/*CyFalse*/);
 1379              		.loc 1 627 0
 1380 00d4 FC009FE5 		ldr	r0, .L75+20
 1381 00d8 0110A0E3 		mov	r1, #1
 1382 00dc FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 1383 00e0 08000BE5 		str	r0, [fp, #-8]
 628:../CX3RDKOV5640.c **** 			if (status != CY_U3P_SUCCESS)
 1384              		.loc 1 628 0
 1385 00e4 08301BE5 		ldr	r3, [fp, #-8]
 1386 00e8 000053E3 		cmp	r3, #0
 1387 00ec 3200000A 		beq	.L62
 629:../CX3RDKOV5640.c **** 			{
 630:../CX3RDKOV5640.c **** 				CyU3PDebugPrint (4, "\n\rUSBStpCB:SetIntfParams SS2 Err = 0x%x", status);
 1388              		.loc 1 630 0
 1389 00f0 0400A0E3 		mov	r0, #4
 1390 00f4 E0109FE5 		ldr	r1, .L75+24
 1391 00f8 08201BE5 		ldr	r2, [fp, #-8]
 1392 00fc FEFFFFEB 		bl	CyU3PDebugPrint
 1393 0100 2D0000EA 		b	.L62
 1394              	.L69:
 631:../CX3RDKOV5640.c **** 			}
 632:../CX3RDKOV5640.c **** 			//esOV5640_VGA_config();//esOV5640_720P_config(); //for experiment
 633:../CX3RDKOV5640.c **** 		}
 634:../CX3RDKOV5640.c **** 		else if(FrameIndex == 0x04)
 1395              		.loc 1 634 0
 1396 0104 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1397 0108 040053E3 		cmp	r3, #4
 1398 010c 2A00001A 		bne	.L62
 635:../CX3RDKOV5640.c **** 		{
 636:../CX3RDKOV5640.c **** 			status = CyU3PMipicsiSetIntfParams (&cfgUvc5Mp15NoMclk, CyTrue/*CyFalse*/);
 1399              		.loc 1 636 0
 1400 0110 C8009FE5 		ldr	r0, .L75+28
 1401 0114 0110A0E3 		mov	r1, #1
 1402 0118 FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 1403 011c 08000BE5 		str	r0, [fp, #-8]
 637:../CX3RDKOV5640.c **** 			if (status != CY_U3P_SUCCESS)
 1404              		.loc 1 637 0
 1405 0120 08301BE5 		ldr	r3, [fp, #-8]
 1406 0124 000053E3 		cmp	r3, #0
 1407 0128 0300000A 		beq	.L71
 638:../CX3RDKOV5640.c **** 			{
 639:../CX3RDKOV5640.c **** 				CyU3PDebugPrint (4, "\n\rUSBStpCB:SetIntfParams SS2 Err = 0x%x", status);
 1408              		.loc 1 639 0
 1409 012c 0400A0E3 		mov	r0, #4
 1410 0130 A4109FE5 		ldr	r1, .L75+24
 1411 0134 08201BE5 		ldr	r2, [fp, #-8]
 1412 0138 FEFFFFEB 		bl	CyU3PDebugPrint
 1413              	.L71:
 640:../CX3RDKOV5640.c **** 			}
 641:../CX3RDKOV5640.c **** 			esOV5640_5MP_config();
 1414              		.loc 1 641 0
 1415 013c FEFFFFEB 		bl	esOV5640_5MP_config
 1416 0140 1D0000EA 		b	.L62
 1417              	.L63:
 642:../CX3RDKOV5640.c **** 		}
 643:../CX3RDKOV5640.c **** 	}
 644:../CX3RDKOV5640.c **** 	/* High Speed USB Streams*/
 645:../CX3RDKOV5640.c **** 	else if (CyU3PUsbGetSpeed () == CY_U3P_HIGH_SPEED)
 1418              		.loc 1 645 0
 1419 0144 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1420 0148 0030A0E1 		mov	r3, r0
 1421 014c 020053E3 		cmp	r3, #2
 1422 0150 0D00001A 		bne	.L73
 646:../CX3RDKOV5640.c **** 	{
 647:../CX3RDKOV5640.c **** 		/* Write VGA Settings */
 648:../CX3RDKOV5640.c **** 		status = CyU3PMipicsiSetIntfParams (&cfgUvcVga30NoMclk, CyFalse);
 1423              		.loc 1 648 0
 1424 0154 74009FE5 		ldr	r0, .L75+12
 1425 0158 0010A0E3 		mov	r1, #0
 1426 015c FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 1427 0160 08000BE5 		str	r0, [fp, #-8]
 649:../CX3RDKOV5640.c **** 		if (status != CY_U3P_SUCCESS)
 1428              		.loc 1 649 0
 1429 0164 08301BE5 		ldr	r3, [fp, #-8]
 1430 0168 000053E3 		cmp	r3, #0
 1431 016c 0300000A 		beq	.L74
 650:../CX3RDKOV5640.c **** 		{
 651:../CX3RDKOV5640.c **** 			CyU3PDebugPrint (4, "\n\rUSBStpCB:SetIntfParams HS Err = 0x%x", status);
 1432              		.loc 1 651 0
 1433 0170 0400A0E3 		mov	r0, #4
 1434 0174 68109FE5 		ldr	r1, .L75+32
 1435 0178 08201BE5 		ldr	r2, [fp, #-8]
 1436 017c FEFFFFEB 		bl	CyU3PDebugPrint
 1437              	.L74:
 652:../CX3RDKOV5640.c **** 		}
 653:../CX3RDKOV5640.c **** 		esOV5640_VGA_config();
 1438              		.loc 1 653 0
 1439 0180 FEFFFFEB 		bl	esOV5640_VGA_config
 654:../CX3RDKOV5640.c **** 		esOV5640_VGA_HS_config();
 1440              		.loc 1 654 0
 1441 0184 FEFFFFEB 		bl	esOV5640_VGA_HS_config
 1442 0188 0B0000EA 		b	.L62
 1443              	.L73:
 655:../CX3RDKOV5640.c **** 	}
 656:../CX3RDKOV5640.c **** 	/* Full Speed USB Streams*/
 657:../CX3RDKOV5640.c **** 	else
 658:../CX3RDKOV5640.c **** 	{
 659:../CX3RDKOV5640.c **** 		/* Write VGA Settings */
 660:../CX3RDKOV5640.c **** 		esOV5640_VGA_config();
 1444              		.loc 1 660 0
 1445 018c FEFFFFEB 		bl	esOV5640_VGA_config
 661:../CX3RDKOV5640.c **** 		status = CyU3PMipicsiSetIntfParams (&cfgUvcVga30NoMclk, CyFalse);
 1446              		.loc 1 661 0
 1447 0190 38009FE5 		ldr	r0, .L75+12
 1448 0194 0010A0E3 		mov	r1, #0
 1449 0198 FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 1450 019c 08000BE5 		str	r0, [fp, #-8]
 662:../CX3RDKOV5640.c **** 		if (status != CY_U3P_SUCCESS)
 1451              		.loc 1 662 0
 1452 01a0 08301BE5 		ldr	r3, [fp, #-8]
 1453 01a4 000053E3 		cmp	r3, #0
 1454 01a8 0300000A 		beq	.L62
 663:../CX3RDKOV5640.c **** 		{
 664:../CX3RDKOV5640.c **** 			CyU3PDebugPrint (4, "\n\rUSBStpCB:SetIntfParams FS Err = 0x%x", status);
 1455              		.loc 1 664 0
 1456 01ac 0400A0E3 		mov	r0, #4
 1457 01b0 1C109FE5 		ldr	r1, .L75+16
 1458 01b4 08201BE5 		ldr	r2, [fp, #-8]
 1459 01b8 FEFFFFEB 		bl	CyU3PDebugPrint
 1460              	.L62:
 665:../CX3RDKOV5640.c **** 		}
 666:../CX3RDKOV5640.c **** 	}
 667:../CX3RDKOV5640.c **** }
 1461              		.loc 1 667 0
 1462 01bc 04D04BE2 		sub	sp, fp, #4
 1463              		@ sp needed
 1464 01c0 0088BDE8 		ldmfd	sp!, {fp, pc}
 1465              	.L76:
 1466              		.align	2
 1467              	.L75:
 1468 01c4 A8000000 		.word	.LC5
 1469 01c8 00000000 		.word	cfgUvc1080p30NoMclk
 1470 01cc C4000000 		.word	.LC6
 1471 01d0 00000000 		.word	cfgUvcVga30NoMclk
 1472 01d4 EC000000 		.word	.LC7
 1473 01d8 00000000 		.word	cfgUvc720p60NoMclk
 1474 01dc 14010000 		.word	.LC8
 1475 01e0 00000000 		.word	cfgUvc5Mp15NoMclk
 1476 01e4 3C010000 		.word	.LC9
 1477              		.cfi_endproc
 1478              	.LFE9:
 1480              		.section	.rodata
 1481 0163 00       		.align	2
 1482              	.LC10:
 1483 0164 0A0D6252 		.ascii	"\012\015bRType = 0x%x, bRequest = 0x%x, wValue = 0x"
 1483      54797065 
 1483      203D2030 
 1483      7825782C 
 1483      20625265 
 1484 0191 25782C20 		.ascii	"%x, wIndex = 0x%x, wLength= 0x%x\000"
 1484      77496E64 
 1484      6578203D 
 1484      20307825 
 1484      782C2077 
 1485 01b2 0000     		.align	2
 1486              	.LC11:
 1487 01b4 0A0D4675 		.ascii	"\012\015Full Speed Not Supported!\000"
 1487      6C6C2053 
 1487      70656564 
 1487      204E6F74 
 1487      20537570 
 1488              		.align	2
 1489              	.LC12:
 1490 01d0 0A0D5553 		.ascii	"\012\015USBStpCB:GET_CUR:SendEP0Data Err = 0x%x\000"
 1490      42537470 
 1490      43423A47 
 1490      45545F43 
 1490      55523A53 
 1491 01fa 0000     		.align	2
 1492              	.LC13:
 1493 01fc 0A0D5553 		.ascii	"\012\015USBStpCB:SET_CUR:GetEP0Data Err = 0x%x.\000"
 1493      42537470 
 1493      43423A53 
 1493      45545F43 
 1493      55523A47 
 1494 0226 0000     		.align	2
 1495              	.LC14:
 1496 0228 0A0D5553 		.ascii	"\012\015USBStpCB:Invalid SET_CUR Rqt Len.\000"
 1496      42537470 
 1496      43423A49 
 1496      6E76616C 
 1496      69642053 
 1497              		.align	2
 1498              	.LC15:
 1499 024c 0A0D5553 		.ascii	"\012\015USBStpCB:SET_CUR:still = 0x%x.\000"
 1499      42537470 
 1499      43423A53 
 1499      45545F43 
 1499      55523A73 
 1500 026d 000000   		.align	2
 1501              	.LC16:
 1502 0270 0A0D2025 		.ascii	"\012\015 %d %d %d %d %d %d %d %d %d %d %d\015\012\000"
 1502      64202564 
 1502      20256420 
 1502      25642025 
 1502      64202564 
 1503 0296 0000     		.align	2
 1504              	.LC17:
 1505 0298 0A0D5553 		.ascii	"\012\015USBStpCB:control interface wIndex = 0x%x wV"
 1505      42537470 
 1505      43423A63 
 1505      6F6E7472 
 1505      6F6C2069 
 1506 02c5 616C7565 		.ascii	"alue = 0x%x bRequest = 0x%x\000"
 1506      203D2030 
 1506      78257820 
 1506      62526571 
 1506      75657374 
 1507              		.section	.text.esUVCUvcApplnUSBSetupCB,"ax",%progbits
 1508              		.align	2
 1510              	esUVCUvcApplnUSBSetupCB:
 1511              	.LFB10:
 668:../CX3RDKOV5640.c **** 
 669:../CX3RDKOV5640.c **** /* Callback to handle the USB Setup Requests and UVC Class events */
 670:../CX3RDKOV5640.c ****     static CyBool_t
 671:../CX3RDKOV5640.c **** esUVCUvcApplnUSBSetupCB (
 672:../CX3RDKOV5640.c ****         uint32_t setupdat0,     /* SETUP Data 0 */
 673:../CX3RDKOV5640.c ****         uint32_t setupdat1      /* SETUP Data 1 */
 674:../CX3RDKOV5640.c ****         )
 675:../CX3RDKOV5640.c **** {
 1512              		.loc 1 675 0
 1513              		.cfi_startproc
 1514              		@ args = 0, pretend = 0, frame = 32
 1515              		@ frame_needed = 1, uses_anonymous_args = 0
 1516 0000 F0492DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, fp, lr}
 1517              	.LCFI20:
 1518              		.cfi_def_cfa_offset 28
 1519              		.cfi_offset 4, -28
 1520              		.cfi_offset 5, -24
 1521              		.cfi_offset 6, -20
 1522              		.cfi_offset 7, -16
 1523              		.cfi_offset 8, -12
 1524              		.cfi_offset 11, -8
 1525              		.cfi_offset 14, -4
 1526 0004 18B08DE2 		add	fp, sp, #24
 1527              	.LCFI21:
 1528              		.cfi_def_cfa 11, 4
 1529 0008 4CD04DE2 		sub	sp, sp, #76
 1530 000c 38000BE5 		str	r0, [fp, #-56]
 1531 0010 3C100BE5 		str	r1, [fp, #-60]
 676:../CX3RDKOV5640.c ****     uint8_t  bRequest, bType,bRType, bTarget;
 677:../CX3RDKOV5640.c ****     uint16_t wValue, wIndex, wLength;
 678:../CX3RDKOV5640.c ****     uint16_t readCount = 0;
 1532              		.loc 1 678 0
 1533 0014 0030A0E3 		mov	r3, #0
 1534 0018 B2334BE1 		strh	r3, [fp, #-50]	@ movhi
 679:../CX3RDKOV5640.c ****     uint8_t  ep0Buf[2];
 680:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 1535              		.loc 1 680 0
 1536 001c 0030A0E3 		mov	r3, #0
 1537 0020 24300BE5 		str	r3, [fp, #-36]
 681:../CX3RDKOV5640.c ****     uint8_t temp = 0;
 1538              		.loc 1 681 0
 1539 0024 0030A0E3 		mov	r3, #0
 1540 0028 25304BE5 		strb	r3, [fp, #-37]
 682:../CX3RDKOV5640.c ****     CyBool_t isHandled = CyFalse;
 1541              		.loc 1 682 0
 1542 002c 0030A0E3 		mov	r3, #0
 1543 0030 20300BE5 		str	r3, [fp, #-32]
 683:../CX3RDKOV5640.c ****     uint8_t RequestOption = 0;
 1544              		.loc 1 683 0
 1545 0034 0030A0E3 		mov	r3, #0
 1546 0038 26304BE5 		strb	r3, [fp, #-38]
 684:../CX3RDKOV5640.c **** 
 685:../CX3RDKOV5640.c ****     /* Decode the fields from the setup request. */
 686:../CX3RDKOV5640.c ****     bRType = (setupdat0 & CY_U3P_USB_REQUEST_TYPE_MASK);
 1547              		.loc 1 686 0
 1548 003c 38301BE5 		ldr	r3, [fp, #-56]
 1549 0040 27304BE5 		strb	r3, [fp, #-39]
 687:../CX3RDKOV5640.c ****     bType    = (bRType & CY_U3P_USB_TYPE_MASK);
 1550              		.loc 1 687 0
 1551 0044 27305BE5 		ldrb	r3, [fp, #-39]
 1552 0048 603003E2 		and	r3, r3, #96
 1553 004c 28304BE5 		strb	r3, [fp, #-40]
 688:../CX3RDKOV5640.c ****     bTarget  = (bRType & CY_U3P_USB_TARGET_MASK);
 1554              		.loc 1 688 0
 1555 0050 27305BE5 		ldrb	r3, [fp, #-39]
 1556 0054 033003E2 		and	r3, r3, #3
 1557 0058 29304BE5 		strb	r3, [fp, #-41]
 689:../CX3RDKOV5640.c ****     bRequest = ((setupdat0 & CY_U3P_USB_REQUEST_MASK) >> CY_U3P_USB_REQUEST_POS);
 1558              		.loc 1 689 0
 1559 005c 38301BE5 		ldr	r3, [fp, #-56]
 1560 0060 FF3C03E2 		and	r3, r3, #65280
 1561 0064 2334A0E1 		mov	r3, r3, lsr #8
 1562 0068 2A304BE5 		strb	r3, [fp, #-42]
 690:../CX3RDKOV5640.c ****     wValue   = ((setupdat0 & CY_U3P_USB_VALUE_MASK)   >> CY_U3P_USB_VALUE_POS);
 1563              		.loc 1 690 0
 1564 006c 38301BE5 		ldr	r3, [fp, #-56]
 1565 0070 2338A0E1 		mov	r3, r3, lsr #16
 1566 0074 BC324BE1 		strh	r3, [fp, #-44]	@ movhi
 691:../CX3RDKOV5640.c ****     wIndex   = ((setupdat1 & CY_U3P_USB_INDEX_MASK)   >> CY_U3P_USB_INDEX_POS);
 1567              		.loc 1 691 0
 1568 0078 3C301BE5 		ldr	r3, [fp, #-60]
 1569 007c BE324BE1 		strh	r3, [fp, #-46]	@ movhi
 692:../CX3RDKOV5640.c ****     wLength  = ((setupdat1 & CY_U3P_USB_LENGTH_MASK)  >> CY_U3P_USB_LENGTH_POS);
 1570              		.loc 1 692 0
 1571 0080 3C301BE5 		ldr	r3, [fp, #-60]
 1572 0084 2338A0E1 		mov	r3, r3, lsr #16
 1573 0088 B0334BE1 		strh	r3, [fp, #-48]	@ movhi
 693:../CX3RDKOV5640.c **** 
 694:../CX3RDKOV5640.c **** #if 1
 695:../CX3RDKOV5640.c ****    	CyU3PDebugPrint(4, "\n\rbRType = 0x%x, bRequest = 0x%x, wValue = 0x%x, wIndex = 0x%x, wLength= 
 1574              		.loc 1 695 0
 1575 008c 27205BE5 		ldrb	r2, [fp, #-39]	@ zero_extendqisi2
 1576 0090 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1577 0094 BCC25BE1 		ldrh	ip, [fp, #-44]
 1578 0098 BE025BE1 		ldrh	r0, [fp, #-46]
 1579 009c B0135BE1 		ldrh	r1, [fp, #-48]
 1580 00a0 00C08DE5 		str	ip, [sp]
 1581 00a4 04008DE5 		str	r0, [sp, #4]
 1582 00a8 08108DE5 		str	r1, [sp, #8]
 1583 00ac 0400A0E3 		mov	r0, #4
 1584 00b0 64179FE5 		ldr	r1, .L132
 1585 00b4 FEFFFFEB 		bl	CyU3PDebugPrint
 696:../CX3RDKOV5640.c **** #endif
 697:../CX3RDKOV5640.c **** 
 698:../CX3RDKOV5640.c ****     /* ClearFeature(Endpoint_Halt) received on the Streaming Endpoint. Stop Streaming */
 699:../CX3RDKOV5640.c ****     if((bTarget == CY_U3P_USB_TARGET_ENDPT) && (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 1586              		.loc 1 699 0
 1587 00b8 29305BE5 		ldrb	r3, [fp, #-41]	@ zero_extendqisi2
 1588 00bc 020053E3 		cmp	r3, #2
 1589 00c0 1C00001A 		bne	.L78
 1590              		.loc 1 699 0 is_stmt 0 discriminator 1
 1591 00c4 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1592 00c8 010053E3 		cmp	r3, #1
 1593 00cc 1900001A 		bne	.L78
 700:../CX3RDKOV5640.c ****             && (wIndex == ES_UVC_EP_BULK_VIDEO) && (wValue == CY_U3P_USBX_FS_EP_HALT))
 1594              		.loc 1 700 0 is_stmt 1
 1595 00d0 BE325BE1 		ldrh	r3, [fp, #-46]
 1596 00d4 830053E3 		cmp	r3, #131
 1597 00d8 1600001A 		bne	.L78
 1598              		.loc 1 700 0 is_stmt 0 discriminator 1
 1599 00dc BC325BE1 		ldrh	r3, [fp, #-44]
 1600 00e0 000053E3 		cmp	r3, #0
 1601 00e4 1300001A 		bne	.L78
 701:../CX3RDKOV5640.c ****     {
 702:../CX3RDKOV5640.c ****         if ((glIsApplnActive) && (glIsStreamingStarted))
 1602              		.loc 1 702 0 is_stmt 1
 1603 00e8 30379FE5 		ldr	r3, .L132+4
 1604 00ec 003093E5 		ldr	r3, [r3]
 1605 00f0 000053E3 		cmp	r3, #0
 1606 00f4 0D00000A 		beq	.L79
 1607              		.loc 1 702 0 is_stmt 0 discriminator 1
 1608 00f8 24379FE5 		ldr	r3, .L132+8
 1609 00fc 003093E5 		ldr	r3, [r3]
 1610 0100 000053E3 		cmp	r3, #0
 1611 0104 0900000A 		beq	.L79
 703:../CX3RDKOV5640.c ****         {
 704:../CX3RDKOV5640.c ****         	glPreviewStarted = CyFalse;
 1612              		.loc 1 704 0 is_stmt 1
 1613 0108 18379FE5 		ldr	r3, .L132+12
 1614 010c 0020A0E3 		mov	r2, #0
 1615 0110 002083E5 		str	r2, [r3]
 705:../CX3RDKOV5640.c ****             glIsClearFeature = CyTrue;
 1616              		.loc 1 705 0
 1617 0114 10379FE5 		ldr	r3, .L132+16
 1618 0118 0120A0E3 		mov	r2, #1
 1619 011c 002083E5 		str	r2, [r3]
 706:../CX3RDKOV5640.c ****             esUVCUvcApplnStop();
 1620              		.loc 1 706 0
 1621 0120 FEFFFFEB 		bl	esUVCUvcApplnStop
 707:../CX3RDKOV5640.c ****             glcommitcount = 0;
 1622              		.loc 1 707 0
 1623 0124 04379FE5 		ldr	r3, .L132+20
 1624 0128 0020A0E3 		mov	r2, #0
 1625 012c 0020C3E5 		strb	r2, [r3]
 1626              	.L79:
 708:../CX3RDKOV5640.c **** #ifdef VISDebug
 709:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rApplnUSBSetupCB: esUVCUvcApplnStop");
 710:../CX3RDKOV5640.c **** #endif
 711:../CX3RDKOV5640.c ****         }
 712:../CX3RDKOV5640.c ****         return CyFalse;
 1627              		.loc 1 712 0
 1628 0130 0030A0E3 		mov	r3, #0
 1629 0134 B50100EA 		b	.L130
 1630              	.L78:
 713:../CX3RDKOV5640.c ****     }
 714:../CX3RDKOV5640.c **** 
 715:../CX3RDKOV5640.c ****     if( bRType == CY_U3P_USB_GS_DEVICE)
 1631              		.loc 1 715 0
 1632 0138 27305BE5 		ldrb	r3, [fp, #-39]	@ zero_extendqisi2
 1633 013c 800053E3 		cmp	r3, #128
 1634 0140 0500001A 		bne	.L81
 716:../CX3RDKOV5640.c ****     {
 717:../CX3RDKOV5640.c ****         /* Make sure that we bring the link back to U0, so that the ERDY can be sent. */
 718:../CX3RDKOV5640.c ****         if (CyU3PUsbGetSpeed () == CY_U3P_SUPER_SPEED)
 1635              		.loc 1 718 0
 1636 0144 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1637 0148 0030A0E1 		mov	r3, r0
 1638 014c 030053E3 		cmp	r3, #3
 1639 0150 0100001A 		bne	.L81
 719:../CX3RDKOV5640.c ****             CyU3PUsbSetLinkPowerState (CyU3PUsbLPM_U0);
 1640              		.loc 1 719 0
 1641 0154 0000A0E3 		mov	r0, #0
 1642 0158 FEFFFFEB 		bl	CyU3PUsbSetLinkPowerState
 1643              	.L81:
 720:../CX3RDKOV5640.c ****     }
 721:../CX3RDKOV5640.c **** 
 722:../CX3RDKOV5640.c ****     if ((bTarget == CY_U3P_USB_TARGET_INTF) && ((bRequest == CY_U3P_USB_SC_SET_FEATURE)
 1644              		.loc 1 722 0
 1645 015c 29305BE5 		ldrb	r3, [fp, #-41]	@ zero_extendqisi2
 1646 0160 010053E3 		cmp	r3, #1
 1647 0164 1400001A 		bne	.L82
 1648              		.loc 1 722 0 is_stmt 0 discriminator 1
 1649 0168 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1650 016c 030053E3 		cmp	r3, #3
 1651 0170 0200000A 		beq	.L83
 723:../CX3RDKOV5640.c ****                 || (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)) && (wValue == 0))
 1652              		.loc 1 723 0 is_stmt 1
 1653 0174 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1654 0178 010053E3 		cmp	r3, #1
 1655 017c 0E00001A 		bne	.L82
 1656              	.L83:
 1657              		.loc 1 723 0 is_stmt 0 discriminator 1
 1658 0180 BC325BE1 		ldrh	r3, [fp, #-44]
 1659 0184 000053E3 		cmp	r3, #0
 1660 0188 0B00001A 		bne	.L82
 724:../CX3RDKOV5640.c ****     {
 725:../CX3RDKOV5640.c ****         if (glIsConfigured)
 1661              		.loc 1 725 0 is_stmt 1
 1662 018c A0369FE5 		ldr	r3, .L132+24
 1663 0190 003093E5 		ldr	r3, [r3]
 1664 0194 000053E3 		cmp	r3, #0
 1665 0198 0100000A 		beq	.L84
 726:../CX3RDKOV5640.c ****         {
 727:../CX3RDKOV5640.c ****             CyU3PUsbAckSetup ();
 1666              		.loc 1 727 0
 1667 019c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1668 01a0 030000EA 		b	.L85
 1669              	.L84:
 728:../CX3RDKOV5640.c ****         }
 729:../CX3RDKOV5640.c ****         else
 730:../CX3RDKOV5640.c ****         {
 731:../CX3RDKOV5640.c ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 1670              		.loc 1 731 0
 1671 01a4 0000A0E3 		mov	r0, #0
 1672 01a8 0110A0E3 		mov	r1, #1
 1673 01ac 0020A0E3 		mov	r2, #0
 1674 01b0 FEFFFFEB 		bl	CyU3PUsbStall
 1675              	.L85:
 732:../CX3RDKOV5640.c ****         }
 733:../CX3RDKOV5640.c ****         return CyTrue;
 1676              		.loc 1 733 0
 1677 01b4 0130A0E3 		mov	r3, #1
 1678 01b8 940100EA 		b	.L130
 1679              	.L82:
 734:../CX3RDKOV5640.c ****     }
 735:../CX3RDKOV5640.c **** 
 736:../CX3RDKOV5640.c ****     if ((bRequest == CY_U3P_USB_SC_GET_STATUS) &&
 1680              		.loc 1 736 0
 1681 01bc 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1682 01c0 000053E3 		cmp	r3, #0
 1683 01c4 1400001A 		bne	.L86
 1684              		.loc 1 736 0 is_stmt 0 discriminator 1
 1685 01c8 29305BE5 		ldrb	r3, [fp, #-41]	@ zero_extendqisi2
 1686 01cc 010053E3 		cmp	r3, #1
 1687 01d0 1100001A 		bne	.L86
 737:../CX3RDKOV5640.c ****             (bTarget == CY_U3P_USB_TARGET_INTF))
 738:../CX3RDKOV5640.c ****     {
 739:../CX3RDKOV5640.c ****         /* We support only interface 0. */
 740:../CX3RDKOV5640.c ****         if (wIndex == 0)
 1688              		.loc 1 740 0 is_stmt 1
 1689 01d4 BE325BE1 		ldrh	r3, [fp, #-46]
 1690 01d8 000053E3 		cmp	r3, #0
 1691 01dc 0800001A 		bne	.L87
 741:../CX3RDKOV5640.c ****         {
 742:../CX3RDKOV5640.c ****             ep0Buf[0] = 0;
 1692              		.loc 1 742 0
 1693 01e0 0030A0E3 		mov	r3, #0
 1694 01e4 34304BE5 		strb	r3, [fp, #-52]
 743:../CX3RDKOV5640.c ****             ep0Buf[1] = 0;
 1695              		.loc 1 743 0
 1696 01e8 0030A0E3 		mov	r3, #0
 1697 01ec 33304BE5 		strb	r3, [fp, #-51]
 744:../CX3RDKOV5640.c ****             CyU3PUsbSendEP0Data (0x02, ep0Buf);
 1698              		.loc 1 744 0
 1699 01f0 34304BE2 		sub	r3, fp, #52
 1700 01f4 0200A0E3 		mov	r0, #2
 1701 01f8 0310A0E1 		mov	r1, r3
 1702 01fc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1703 0200 030000EA 		b	.L88
 1704              	.L87:
 745:../CX3RDKOV5640.c ****         }
 746:../CX3RDKOV5640.c ****         else
 747:../CX3RDKOV5640.c ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 1705              		.loc 1 747 0
 1706 0204 0000A0E3 		mov	r0, #0
 1707 0208 0110A0E3 		mov	r1, #1
 1708 020c 0020A0E3 		mov	r2, #0
 1709 0210 FEFFFFEB 		bl	CyU3PUsbStall
 1710              	.L88:
 748:../CX3RDKOV5640.c ****         return CyTrue;
 1711              		.loc 1 748 0
 1712 0214 0130A0E3 		mov	r3, #1
 1713 0218 7C0100EA 		b	.L130
 1714              	.L86:
 749:../CX3RDKOV5640.c ****     }
 750:../CX3RDKOV5640.c **** 
 751:../CX3RDKOV5640.c ****     /* Check for UVC Class Requests */
 752:../CX3RDKOV5640.c ****     if (bType == CY_U3P_USB_CLASS_RQT)
 1715              		.loc 1 752 0
 1716 021c 28305BE5 		ldrb	r3, [fp, #-40]	@ zero_extendqisi2
 1717 0220 200053E3 		cmp	r3, #32
 1718 0224 7801001A 		bne	.L89
 753:../CX3RDKOV5640.c ****     {
 754:../CX3RDKOV5640.c **** 
 755:../CX3RDKOV5640.c ****         /* UVC Class Requests */
 756:../CX3RDKOV5640.c ****         /* Requests to the Video Streaming Interface (IF 1) */
 757:../CX3RDKOV5640.c ****         if((wIndex & 0x00FF) == ES_UVC_STREAM_INTERFACE)
 1719              		.loc 1 757 0
 1720 0228 BE325BE1 		ldrh	r3, [fp, #-46]
 1721 022c FF3003E2 		and	r3, r3, #255
 1722 0230 010053E3 		cmp	r3, #1
 1723 0234 4D01001A 		bne	.L90
 758:../CX3RDKOV5640.c ****         {
 759:../CX3RDKOV5640.c ****             /* GET_CUR Request Handling Probe/Commit Controls*/
 760:../CX3RDKOV5640.c ****             if ((bRequest == ES_UVC_USB_GET_CUR_REQ)||(bRequest == ES_UVC_USB_GET_MIN_REQ) || (bReq
 1724              		.loc 1 760 0
 1725 0238 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1726 023c 810053E3 		cmp	r3, #129
 1727 0240 0800000A 		beq	.L91
 1728              		.loc 1 760 0 is_stmt 0 discriminator 1
 1729 0244 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1730 0248 820053E3 		cmp	r3, #130
 1731 024c 0500000A 		beq	.L91
 1732 0250 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1733 0254 830053E3 		cmp	r3, #131
 1734 0258 0200000A 		beq	.L91
 1735 025c 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1736 0260 870053E3 		cmp	r3, #135
 1737 0264 5F00001A 		bne	.L92
 1738              	.L91:
 761:../CX3RDKOV5640.c ****             {
 762:../CX3RDKOV5640.c ****                 isHandled = CyTrue;
 1739              		.loc 1 762 0 is_stmt 1
 1740 0268 0130A0E3 		mov	r3, #1
 1741 026c 20300BE5 		str	r3, [fp, #-32]
 763:../CX3RDKOV5640.c ****                 if((wValue == ES_UVC_VS_PROBE_CONTROL) || (wValue == ES_UVC_VS_COMMIT_CONTROL))
 1742              		.loc 1 763 0
 1743 0270 BC325BE1 		ldrh	r3, [fp, #-44]
 1744 0274 010C53E3 		cmp	r3, #256
 1745 0278 0200000A 		beq	.L93
 1746              		.loc 1 763 0 is_stmt 0 discriminator 1
 1747 027c BC325BE1 		ldrh	r3, [fp, #-44]
 1748 0280 020C53E3 		cmp	r3, #512
 1749 0284 4000001A 		bne	.L94
 1750              	.L93:
 764:../CX3RDKOV5640.c ****                 {
 765:../CX3RDKOV5640.c ****                 	//TODO Modify this "glProbeCtrl" according to the Supported Preview Resolutions th
 766:../CX3RDKOV5640.c **** 
 767:../CX3RDKOV5640.c **** 					/* Host requests for probe data of 34 bytes (UVC 1.1) or 26 Bytes (UVC1.0). Send it over EP0. 
 768:../CX3RDKOV5640.c **** 					if (CyU3PUsbGetSpeed () == CY_U3P_SUPER_SPEED)
 1751              		.loc 1 768 0 is_stmt 1
 1752 0288 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1753 028c 0030A0E1 		mov	r3, r0
 1754 0290 030053E3 		cmp	r3, #3
 1755 0294 2300001A 		bne	.L95
 769:../CX3RDKOV5640.c **** 					{
 770:../CX3RDKOV5640.c **** 						if(glCurrentFrameIndex == 4)
 1756              		.loc 1 770 0
 1757 0298 98359FE5 		ldr	r3, .L132+28
 1758 029c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1759 02a0 040053E3 		cmp	r3, #4
 1760 02a4 0400001A 		bne	.L96
 771:../CX3RDKOV5640.c **** 						{
 772:../CX3RDKOV5640.c **** 							CyU3PMemCopy(glProbeCtrl, (uint8_t *)gl5MpProbeCtrl, ES_UVC_MAX_PROBE_SETTING);
 1761              		.loc 1 772 0
 1762 02a8 8C059FE5 		ldr	r0, .L132+32
 1763 02ac 8C159FE5 		ldr	r1, .L132+36
 1764 02b0 1A20A0E3 		mov	r2, #26
 1765 02b4 FEFFFFEB 		bl	CyU3PMemCopy
 1766 02b8 260000EA 		b	.L100
 1767              	.L96:
 773:../CX3RDKOV5640.c **** 						}
 774:../CX3RDKOV5640.c **** 						/* Probe Control for 1280x720 stream*/
 775:../CX3RDKOV5640.c **** 						else if(glCurrentFrameIndex == 3)
 1768              		.loc 1 775 0
 1769 02bc 74359FE5 		ldr	r3, .L132+28
 1770 02c0 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1771 02c4 030053E3 		cmp	r3, #3
 1772 02c8 0400001A 		bne	.L98
 776:../CX3RDKOV5640.c **** 						{
 777:../CX3RDKOV5640.c **** 							CyU3PMemCopy(glProbeCtrl, (uint8_t *)gl720pProbeCtrl, ES_UVC_MAX_PROBE_SETTING);
 1773              		.loc 1 777 0
 1774 02cc 68059FE5 		ldr	r0, .L132+32
 1775 02d0 6C159FE5 		ldr	r1, .L132+40
 1776 02d4 1A20A0E3 		mov	r2, #26
 1777 02d8 FEFFFFEB 		bl	CyU3PMemCopy
 1778 02dc 1D0000EA 		b	.L100
 1779              	.L98:
 778:../CX3RDKOV5640.c **** 						}
 779:../CX3RDKOV5640.c **** 						/* Probe Control for 640x480 stream*/
 780:../CX3RDKOV5640.c **** 						else  if(glCurrentFrameIndex == 2)
 1780              		.loc 1 780 0
 1781 02e0 50359FE5 		ldr	r3, .L132+28
 1782 02e4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1783 02e8 020053E3 		cmp	r3, #2
 1784 02ec 0400001A 		bne	.L99
 781:../CX3RDKOV5640.c **** 						{
 782:../CX3RDKOV5640.c **** 							CyU3PMemCopy(glProbeCtrl, (uint8_t *)glVga60ProbeCtrl, ES_UVC_MAX_PROBE_SETTING);
 1785              		.loc 1 782 0
 1786 02f0 44059FE5 		ldr	r0, .L132+32
 1787 02f4 4C159FE5 		ldr	r1, .L132+44
 1788 02f8 1A20A0E3 		mov	r2, #26
 1789 02fc FEFFFFEB 		bl	CyU3PMemCopy
 1790 0300 140000EA 		b	.L100
 1791              	.L99:
 783:../CX3RDKOV5640.c **** 						}
 784:../CX3RDKOV5640.c **** 						/* Probe Control for 1920x1080 stream*/
 785:../CX3RDKOV5640.c **** 						else  if(glCurrentFrameIndex == 1)
 1792              		.loc 1 785 0
 1793 0304 2C359FE5 		ldr	r3, .L132+28
 1794 0308 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1795 030c 010053E3 		cmp	r3, #1
 1796 0310 1000001A 		bne	.L100
 786:../CX3RDKOV5640.c **** 						{
 787:../CX3RDKOV5640.c **** 							CyU3PMemCopy(glProbeCtrl, (uint8_t *)gl1080pProbeCtrl, ES_UVC_MAX_PROBE_SETTING);
 1797              		.loc 1 787 0
 1798 0314 20059FE5 		ldr	r0, .L132+32
 1799 0318 2C159FE5 		ldr	r1, .L132+48
 1800 031c 1A20A0E3 		mov	r2, #26
 1801 0320 FEFFFFEB 		bl	CyU3PMemCopy
 1802 0324 0B0000EA 		b	.L100
 1803              	.L95:
 788:../CX3RDKOV5640.c **** 						}
 789:../CX3RDKOV5640.c **** 
 790:../CX3RDKOV5640.c **** 					}
 791:../CX3RDKOV5640.c **** 					else if (CyU3PUsbGetSpeed () == CY_U3P_HIGH_SPEED)
 1804              		.loc 1 791 0
 1805 0328 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1806 032c 0030A0E1 		mov	r3, r0
 1807 0330 020053E3 		cmp	r3, #2
 1808 0334 0400001A 		bne	.L101
 792:../CX3RDKOV5640.c **** 					{
 793:../CX3RDKOV5640.c **** 						/* Probe Control for 640x480 stream*/
 794:../CX3RDKOV5640.c **** 						CyU3PMemCopy(glProbeCtrl, (uint8_t *)glVga30ProbeCtrl, ES_UVC_MAX_PROBE_SETTING);
 1809              		.loc 1 794 0
 1810 0338 FC049FE5 		ldr	r0, .L132+32
 1811 033c 0C159FE5 		ldr	r1, .L132+52
 1812 0340 1A20A0E3 		mov	r2, #26
 1813 0344 FEFFFFEB 		bl	CyU3PMemCopy
 1814 0348 020000EA 		b	.L100
 1815              	.L101:
 795:../CX3RDKOV5640.c **** 					}
 796:../CX3RDKOV5640.c **** 					else /* FULL-Speed*/
 797:../CX3RDKOV5640.c **** 					{
 798:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rFull Speed Not Supported!");
 1816              		.loc 1 798 0
 1817 034c 0400A0E3 		mov	r0, #4
 1818 0350 FC149FE5 		ldr	r1, .L132+56
 1819 0354 FEFFFFEB 		bl	CyU3PDebugPrint
 1820              	.L100:
 799:../CX3RDKOV5640.c **** 					}
 800:../CX3RDKOV5640.c **** 
 801:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(ES_UVC_MAX_PROBE_SETTING, glProbeCtrl);
 1821              		.loc 1 801 0
 1822 0358 1A00A0E3 		mov	r0, #26
 1823 035c D8149FE5 		ldr	r1, .L132+32
 1824 0360 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1825 0364 24000BE5 		str	r0, [fp, #-36]
 802:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 1826              		.loc 1 802 0
 1827 0368 24301BE5 		ldr	r3, [fp, #-36]
 1828 036c 000053E3 		cmp	r3, #0
 1829 0370 0400000A 		beq	.L102
 803:../CX3RDKOV5640.c **** 					{
 804:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:GET_CUR:SendEP0Data Err = 0x%x", status);
 1830              		.loc 1 804 0
 1831 0374 0400A0E3 		mov	r0, #4
 1832 0378 D8149FE5 		ldr	r1, .L132+60
 1833 037c 24201BE5 		ldr	r2, [fp, #-36]
 1834 0380 FEFFFFEB 		bl	CyU3PDebugPrint
 802:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 1835              		.loc 1 802 0
 1836 0384 160000EA 		b	.L103
 1837              	.L102:
 802:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 1838              		.loc 1 802 0 is_stmt 0 discriminator 1
 1839 0388 150000EA 		b	.L103
 1840              	.L94:
 805:../CX3RDKOV5640.c **** 					}
 806:../CX3RDKOV5640.c ****                 }
 807:../CX3RDKOV5640.c ****                 else if((wValue == ES_UVC_STILL_PROBE_CONTROL) || (wValue == ES_UVC_STILL_COMMIT_CO
 1841              		.loc 1 807 0 is_stmt 1
 1842 038c BC325BE1 		ldrh	r3, [fp, #-44]
 1843 0390 030C53E3 		cmp	r3, #768
 1844 0394 0200000A 		beq	.L104
 1845              		.loc 1 807 0 is_stmt 0 discriminator 1
 1846 0398 BC325BE1 		ldrh	r3, [fp, #-44]
 1847 039c 010B53E3 		cmp	r3, #1024
 1848 03a0 0F00001A 		bne	.L103
 1849              	.L104:
 808:../CX3RDKOV5640.c ****                 {
 809:../CX3RDKOV5640.c ****                 	if (CyU3PUsbGetSpeed () == CY_U3P_SUPER_SPEED)
 1850              		.loc 1 809 0 is_stmt 1
 1851 03a4 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1852 03a8 0030A0E1 		mov	r3, r0
 1853 03ac 030053E3 		cmp	r3, #3
 1854 03b0 0B00001A 		bne	.L103
 810:../CX3RDKOV5640.c ****                 	{
 811:../CX3RDKOV5640.c **** 						status = CyU3PUsbSendEP0Data(ES_UVC_MAX_STILL_PROBE_SETTING, glStillProbeCtrl);
 1855              		.loc 1 811 0
 1856 03b4 0B00A0E3 		mov	r0, #11
 1857 03b8 9C149FE5 		ldr	r1, .L132+64
 1858 03bc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1859 03c0 24000BE5 		str	r0, [fp, #-36]
 812:../CX3RDKOV5640.c **** 						if (status != CY_U3P_SUCCESS)
 1860              		.loc 1 812 0
 1861 03c4 24301BE5 		ldr	r3, [fp, #-36]
 1862 03c8 000053E3 		cmp	r3, #0
 1863 03cc 0400000A 		beq	.L103
 813:../CX3RDKOV5640.c **** 						{
 814:../CX3RDKOV5640.c **** 							CyU3PDebugPrint (4, "\n\rUSBStpCB:GET_CUR:SendEP0Data Err = 0x%x", status);
 1864              		.loc 1 814 0
 1865 03d0 0400A0E3 		mov	r0, #4
 1866 03d4 7C149FE5 		ldr	r1, .L132+60
 1867 03d8 24201BE5 		ldr	r2, [fp, #-36]
 1868 03dc FEFFFFEB 		bl	CyU3PDebugPrint
 763:../CX3RDKOV5640.c ****                 {
 1869              		.loc 1 763 0
 1870 03e0 E10000EA 		b	.L105
 1871              	.L103:
 1872 03e4 E00000EA 		b	.L105
 1873              	.L92:
 815:../CX3RDKOV5640.c **** 						}
 816:../CX3RDKOV5640.c ****                 	}
 817:../CX3RDKOV5640.c ****                 }
 818:../CX3RDKOV5640.c ****             }
 819:../CX3RDKOV5640.c ****             /* SET_CUR request handling Probe/Commit controls */
 820:../CX3RDKOV5640.c ****             else if (bRequest == ES_UVC_USB_SET_CUR_REQ)
 1874              		.loc 1 820 0
 1875 03e8 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1876 03ec 010053E3 		cmp	r3, #1
 1877 03f0 DA00001A 		bne	.L106
 821:../CX3RDKOV5640.c ****             {
 822:../CX3RDKOV5640.c ****                 isHandled = CyTrue;
 1878              		.loc 1 822 0
 1879 03f4 0130A0E3 		mov	r3, #1
 1880 03f8 20300BE5 		str	r3, [fp, #-32]
 823:../CX3RDKOV5640.c ****                 if((wValue == ES_UVC_VS_PROBE_CONTROL) || (wValue == ES_UVC_VS_COMMIT_CONTROL))
 1881              		.loc 1 823 0
 1882 03fc BC325BE1 		ldrh	r3, [fp, #-44]
 1883 0400 010C53E3 		cmp	r3, #256
 1884 0404 0200000A 		beq	.L107
 1885              		.loc 1 823 0 is_stmt 0 discriminator 1
 1886 0408 BC325BE1 		ldrh	r3, [fp, #-44]
 1887 040c 020C53E3 		cmp	r3, #512
 1888 0410 5400001A 		bne	.L108
 1889              	.L107:
 824:../CX3RDKOV5640.c ****                 {
 825:../CX3RDKOV5640.c **** 					/* Get the UVC probe/commit control data from EP0 */
 826:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(ES_UVC_MAX_PROBE_SETTING_ALIGNED,
 1890              		.loc 1 826 0 is_stmt 1
 1891 0414 32304BE2 		sub	r3, fp, #50
 1892 0418 2000A0E3 		mov	r0, #32
 1893 041c 3C149FE5 		ldr	r1, .L132+68
 1894 0420 0320A0E1 		mov	r2, r3
 1895 0424 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1896 0428 24000BE5 		str	r0, [fp, #-36]
 827:../CX3RDKOV5640.c **** 							glCommitCtrl, &readCount);
 828:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 1897              		.loc 1 828 0
 1898 042c 24301BE5 		ldr	r3, [fp, #-36]
 1899 0430 000053E3 		cmp	r3, #0
 1900 0434 0300000A 		beq	.L109
 829:../CX3RDKOV5640.c **** 					{
 830:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:SET_CUR:GetEP0Data Err = 0x%x.", status);
 1901              		.loc 1 830 0
 1902 0438 0400A0E3 		mov	r0, #4
 1903 043c 20149FE5 		ldr	r1, .L132+72
 1904 0440 24201BE5 		ldr	r2, [fp, #-36]
 1905 0444 FEFFFFEB 		bl	CyU3PDebugPrint
 1906              	.L109:
 831:../CX3RDKOV5640.c **** 					}
 832:../CX3RDKOV5640.c **** 					/* Check the read count. Expecting a count of CX3_UVC_MAX_PROBE_SETTING bytes. */
 833:../CX3RDKOV5640.c **** 					if (readCount > (uint16_t)ES_UVC_MAX_PROBE_SETTING)
 1907              		.loc 1 833 0
 1908 0448 B2335BE1 		ldrh	r3, [fp, #-50]
 1909 044c 1A0053E3 		cmp	r3, #26
 1910 0450 0300009A 		bls	.L110
 834:../CX3RDKOV5640.c **** 					{
 835:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:Invalid SET_CUR Rqt Len.");
 1911              		.loc 1 835 0
 1912 0454 0400A0E3 		mov	r0, #4
 1913 0458 08149FE5 		ldr	r1, .L132+76
 1914 045c FEFFFFEB 		bl	CyU3PDebugPrint
 1915 0460 3F0000EA 		b	.L111
 1916              	.L110:
 836:../CX3RDKOV5640.c **** 					}
 837:../CX3RDKOV5640.c **** 					else
 838:../CX3RDKOV5640.c **** 					{
 839:../CX3RDKOV5640.c **** 						/* Set Probe Control */
 840:../CX3RDKOV5640.c **** 						if(wValue == ES_UVC_VS_PROBE_CONTROL)
 1917              		.loc 1 840 0
 1918 0464 BC325BE1 		ldrh	r3, [fp, #-44]
 1919 0468 010C53E3 		cmp	r3, #256
 1920 046c 0400001A 		bne	.L112
 841:../CX3RDKOV5640.c **** 						{
 842:../CX3RDKOV5640.c **** 							glCurrentFrameIndex = glCommitCtrl[3];
 1921              		.loc 1 842 0
 1922 0470 E8339FE5 		ldr	r3, .L132+68
 1923 0474 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 1924 0478 B8339FE5 		ldr	r3, .L132+28
 1925 047c 0020C3E5 		strb	r2, [r3]
 1926 0480 370000EA 		b	.L111
 1927              	.L112:
 843:../CX3RDKOV5640.c **** 						}
 844:../CX3RDKOV5640.c **** 						/* Set Commit Control and Start Streaming*/
 845:../CX3RDKOV5640.c **** 						else if(wValue == ES_UVC_VS_COMMIT_CONTROL)
 1928              		.loc 1 845 0
 1929 0484 BC325BE1 		ldrh	r3, [fp, #-44]
 1930 0488 020C53E3 		cmp	r3, #512
 1931 048c 3400001A 		bne	.L111
 846:../CX3RDKOV5640.c **** 						{
 847:../CX3RDKOV5640.c **** 
 848:../CX3RDKOV5640.c **** 							if((glcommitcount==0)||(glcheckframe!=glCommitCtrl[3]))
 1932              		.loc 1 848 0
 1933 0490 98339FE5 		ldr	r3, .L132+20
 1934 0494 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1935 0498 000053E3 		cmp	r3, #0
 1936 049c 0500000A 		beq	.L113
 1937              		.loc 1 848 0 is_stmt 0 discriminator 1
 1938 04a0 B8339FE5 		ldr	r3, .L132+68
 1939 04a4 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 1940 04a8 BC339FE5 		ldr	r3, .L132+80
 1941 04ac 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1942 04b0 030052E1 		cmp	r2, r3
 1943 04b4 2A00000A 		beq	.L111
 1944              	.L113:
 849:../CX3RDKOV5640.c **** 							{
 850:../CX3RDKOV5640.c **** 								glcommitcount++;
 1945              		.loc 1 850 0 is_stmt 1
 1946 04b8 70339FE5 		ldr	r3, .L132+20
 1947 04bc 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1948 04c0 013083E2 		add	r3, r3, #1
 1949 04c4 FF2003E2 		and	r2, r3, #255
 1950 04c8 60339FE5 		ldr	r3, .L132+20
 1951 04cc 0020C3E5 		strb	r2, [r3]
 851:../CX3RDKOV5640.c **** 								glcheckframe=glCommitCtrl[3];
 1952              		.loc 1 851 0
 1953 04d0 88339FE5 		ldr	r3, .L132+68
 1954 04d4 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 1955 04d8 8C339FE5 		ldr	r3, .L132+80
 1956 04dc 0020C3E5 		strb	r2, [r3]
 852:../CX3RDKOV5640.c **** 							glCurrentFrameIndex = glCommitCtrl[3];
 1957              		.loc 1 852 0
 1958 04e0 78339FE5 		ldr	r3, .L132+68
 1959 04e4 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 1960 04e8 48339FE5 		ldr	r3, .L132+28
 1961 04ec 0020C3E5 		strb	r2, [r3]
 853:../CX3RDKOV5640.c **** 							glFrameIndexToSet = glCurrentFrameIndex;
 1962              		.loc 1 853 0
 1963 04f0 40339FE5 		ldr	r3, .L132+28
 1964 04f4 0020D3E5 		ldrb	r2, [r3]	@ zero_extendqisi2
 1965 04f8 70339FE5 		ldr	r3, .L132+84
 1966 04fc 0020C3E5 		strb	r2, [r3]
 854:../CX3RDKOV5640.c **** 							glPreviewStarted = CyTrue;
 1967              		.loc 1 854 0
 1968 0500 20339FE5 		ldr	r3, .L132+12
 1969 0504 0120A0E3 		mov	r2, #1
 1970 0508 002083E5 		str	r2, [r3]
 855:../CX3RDKOV5640.c **** 
 856:../CX3RDKOV5640.c **** 							//TODO Change this function with "Sensor Specific" function to write the sensor settings & c
 857:../CX3RDKOV5640.c **** 						//	esSetCameraResolution(glCurrentFrameIndex);
 858:../CX3RDKOV5640.c **** 							esSetCameraResolution(glCommitCtrl[3]);
 1971              		.loc 1 858 0
 1972 050c 4C339FE5 		ldr	r3, .L132+68
 1973 0510 0330D3E5 		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 1974 0514 0300A0E1 		mov	r0, r3
 1975 0518 FEFFFFEB 		bl	esSetCameraResolution
 859:../CX3RDKOV5640.c **** 
 860:../CX3RDKOV5640.c **** 							if (glIsApplnActive)
 1976              		.loc 1 860 0
 1977 051c FC329FE5 		ldr	r3, .L132+4
 1978 0520 003093E5 		ldr	r3, [r3]
 1979 0524 000053E3 		cmp	r3, #0
 1980 0528 0B00000A 		beq	.L114
 861:../CX3RDKOV5640.c **** 							{
 862:../CX3RDKOV5640.c **** 								if(glcommitcount)
 1981              		.loc 1 862 0
 1982 052c FC329FE5 		ldr	r3, .L132+20
 1983 0530 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1984 0534 000053E3 		cmp	r3, #0
 1985 0538 0300000A 		beq	.L115
 863:../CX3RDKOV5640.c **** 									glIsClearFeature = CyFalse;
 1986              		.loc 1 863 0
 1987 053c E8329FE5 		ldr	r3, .L132+16
 1988 0540 0020A0E3 		mov	r2, #0
 1989 0544 002083E5 		str	r2, [r3]
 1990 0548 020000EA 		b	.L116
 1991              	.L115:
 864:../CX3RDKOV5640.c **** 								else
 865:../CX3RDKOV5640.c **** 									glIsClearFeature = CyTrue;
 1992              		.loc 1 865 0
 1993 054c D8329FE5 		ldr	r3, .L132+16
 1994 0550 0120A0E3 		mov	r2, #1
 1995 0554 002083E5 		str	r2, [r3]
 1996              	.L116:
 866:../CX3RDKOV5640.c **** 
 867:../CX3RDKOV5640.c **** 								esUVCUvcApplnStop();
 1997              		.loc 1 867 0
 1998 0558 FEFFFFEB 		bl	esUVCUvcApplnStop
 1999              	.L114:
 868:../CX3RDKOV5640.c **** #ifdef VISDebug
 869:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rApplnUSBSetupCB:ES_UVC_VS_COMMIT_CONTROL esUVCUvcApplnStop");
 870:../CX3RDKOV5640.c **** #endif
 871:../CX3RDKOV5640.c **** 							}
 872:../CX3RDKOV5640.c **** 							esUVCUvcApplnStart();
 2000              		.loc 1 872 0
 2001 055c FEFFFFEB 		bl	esUVCUvcApplnStart
 833:../CX3RDKOV5640.c **** 					{
 2002              		.loc 1 833 0
 2003 0560 7D0000EA 		b	.L117
 2004              	.L111:
 2005 0564 7C0000EA 		b	.L117
 2006              	.L108:
 873:../CX3RDKOV5640.c **** #ifdef VISDebug
 874:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rApplnUSBSetupCB:ES_UVC_VS_COMMIT_CONTROL esUVCUvcApplnStart");
 875:../CX3RDKOV5640.c **** #endif
 876:../CX3RDKOV5640.c **** 							}
 877:../CX3RDKOV5640.c **** 						}
 878:../CX3RDKOV5640.c **** 					}
 879:../CX3RDKOV5640.c ****                 }
 880:../CX3RDKOV5640.c ****                 else if((wValue == ES_UVC_STILL_PROBE_CONTROL) || (wValue == ES_UVC_STILL_COMMIT_CO
 2007              		.loc 1 880 0
 2008 0568 BC325BE1 		ldrh	r3, [fp, #-44]
 2009 056c 030C53E3 		cmp	r3, #768
 2010 0570 0200000A 		beq	.L118
 2011              		.loc 1 880 0 is_stmt 0 discriminator 1
 2012 0574 BC325BE1 		ldrh	r3, [fp, #-44]
 2013 0578 010B53E3 		cmp	r3, #1024
 2014 057c 5400001A 		bne	.L119
 2015              	.L118:
 881:../CX3RDKOV5640.c ****                 {
 882:../CX3RDKOV5640.c ****                 	/* Get the UVC STILL probe/commit control data from EP0 */
 883:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(ES_UVC_MAX_STILL_PROBE_SETTING_ALIGNED,glStillCommitCtrl, &readCou
 2016              		.loc 1 883 0 is_stmt 1
 2017 0580 32304BE2 		sub	r3, fp, #50
 2018 0584 2000A0E3 		mov	r0, #32
 2019 0588 E4129FE5 		ldr	r1, .L132+88
 2020 058c 0320A0E1 		mov	r2, r3
 2021 0590 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2022 0594 24000BE5 		str	r0, [fp, #-36]
 884:../CX3RDKOV5640.c **** 					CyU3PDebugPrint (4, "\n\rUSBStpCB:SET_CUR:still = 0x%x.", wValue);
 2023              		.loc 1 884 0
 2024 0598 BC325BE1 		ldrh	r3, [fp, #-44]
 2025 059c 0400A0E3 		mov	r0, #4
 2026 05a0 D0129FE5 		ldr	r1, .L132+92
 2027 05a4 0320A0E1 		mov	r2, r3
 2028 05a8 FEFFFFEB 		bl	CyU3PDebugPrint
 885:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 886:../CX3RDKOV5640.c ****                     		glStillCommitCtrl[0], glStillCommitCtrl[1],  glStillCommitCtrl[2], glStillCom
 2029              		.loc 1 886 0
 2030 05ac C0329FE5 		ldr	r3, .L132+88
 2031 05b0 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 885:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2032              		.loc 1 885 0
 2033 05b4 0320A0E1 		mov	r2, r3
 2034              		.loc 1 886 0
 2035 05b8 B4329FE5 		ldr	r3, .L132+88
 2036 05bc 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2037 05c0 AC129FE5 		ldr	r1, .L132+88
 2038 05c4 0210D1E5 		ldrb	r1, [r1, #2]	@ zero_extendqisi2
 885:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2039              		.loc 1 885 0
 2040 05c8 0180A0E1 		mov	r8, r1
 2041              		.loc 1 886 0
 2042 05cc A0129FE5 		ldr	r1, .L132+88
 2043 05d0 0310D1E5 		ldrb	r1, [r1, #3]	@ zero_extendqisi2
 885:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2044              		.loc 1 885 0
 2045 05d4 0170A0E1 		mov	r7, r1
 887:../CX3RDKOV5640.c ****                     		glStillCommitCtrl[4], glStillCommitCtrl[5],  glStillCommitCtrl[6], glStillCom
 2046              		.loc 1 887 0
 2047 05d8 94129FE5 		ldr	r1, .L132+88
 2048 05dc 0410D1E5 		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 885:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2049              		.loc 1 885 0
 2050 05e0 0160A0E1 		mov	r6, r1
 2051              		.loc 1 887 0
 2052 05e4 88129FE5 		ldr	r1, .L132+88
 2053 05e8 0510D1E5 		ldrb	r1, [r1, #5]	@ zero_extendqisi2
 885:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2054              		.loc 1 885 0
 2055 05ec 0150A0E1 		mov	r5, r1
 2056              		.loc 1 887 0
 2057 05f0 7C129FE5 		ldr	r1, .L132+88
 2058 05f4 0610D1E5 		ldrb	r1, [r1, #6]	@ zero_extendqisi2
 885:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2059              		.loc 1 885 0
 2060 05f8 0140A0E1 		mov	r4, r1
 2061              		.loc 1 887 0
 2062 05fc 70129FE5 		ldr	r1, .L132+88
 2063 0600 0710D1E5 		ldrb	r1, [r1, #7]	@ zero_extendqisi2
 885:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2064              		.loc 1 885 0
 2065 0604 01E0A0E1 		mov	lr, r1
 888:../CX3RDKOV5640.c ****                     		glStillCommitCtrl[8], glStillCommitCtrl[9], glStillCommitCtrl[10]);
 2066              		.loc 1 888 0
 2067 0608 64129FE5 		ldr	r1, .L132+88
 2068 060c 0810D1E5 		ldrb	r1, [r1, #8]	@ zero_extendqisi2
 885:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2069              		.loc 1 885 0
 2070 0610 01C0A0E1 		mov	ip, r1
 2071              		.loc 1 888 0
 2072 0614 58129FE5 		ldr	r1, .L132+88
 2073 0618 0910D1E5 		ldrb	r1, [r1, #9]	@ zero_extendqisi2
 885:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2074              		.loc 1 885 0
 2075 061c 0100A0E1 		mov	r0, r1
 2076              		.loc 1 888 0
 2077 0620 4C129FE5 		ldr	r1, .L132+88
 2078 0624 0A10D1E5 		ldrb	r1, [r1, #10]	@ zero_extendqisi2
 885:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2079              		.loc 1 885 0
 2080 0628 00808DE5 		str	r8, [sp]
 2081 062c 04708DE5 		str	r7, [sp, #4]
 2082 0630 08608DE5 		str	r6, [sp, #8]
 2083 0634 0C508DE5 		str	r5, [sp, #12]
 2084 0638 10408DE5 		str	r4, [sp, #16]
 2085 063c 14E08DE5 		str	lr, [sp, #20]
 2086 0640 18C08DE5 		str	ip, [sp, #24]
 2087 0644 1C008DE5 		str	r0, [sp, #28]
 2088 0648 20108DE5 		str	r1, [sp, #32]
 2089 064c 0400A0E3 		mov	r0, #4
 2090 0650 24129FE5 		ldr	r1, .L132+96
 2091 0654 FEFFFFEB 		bl	CyU3PDebugPrint
 889:../CX3RDKOV5640.c **** 
 890:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 2092              		.loc 1 890 0
 2093 0658 24301BE5 		ldr	r3, [fp, #-36]
 2094 065c 000053E3 		cmp	r3, #0
 2095 0660 0300000A 		beq	.L120
 891:../CX3RDKOV5640.c **** 					{
 892:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:SET_CUR:GetEP0Data Err = 0x%x.", status);
 2096              		.loc 1 892 0
 2097 0664 0400A0E3 		mov	r0, #4
 2098 0668 F4119FE5 		ldr	r1, .L132+72
 2099 066c 24201BE5 		ldr	r2, [fp, #-36]
 2100 0670 FEFFFFEB 		bl	CyU3PDebugPrint
 2101              	.L120:
 893:../CX3RDKOV5640.c **** 					}
 894:../CX3RDKOV5640.c **** 					/* Check the read count. Expecting a count of CX3_UVC_MAX_PROBE_SETTING bytes. */
 895:../CX3RDKOV5640.c **** 					if (readCount > (uint16_t)ES_UVC_MAX_STILL_PROBE_SETTING)
 2102              		.loc 1 895 0
 2103 0674 B2335BE1 		ldrh	r3, [fp, #-50]
 2104 0678 0B0053E3 		cmp	r3, #11
 2105 067c 0300009A 		bls	.L121
 896:../CX3RDKOV5640.c **** 					{
 897:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:Invalid SET_CUR Rqt Len.");
 2106              		.loc 1 897 0
 2107 0680 0400A0E3 		mov	r0, #4
 2108 0684 DC119FE5 		ldr	r1, .L132+76
 2109 0688 FEFFFFEB 		bl	CyU3PDebugPrint
 2110 068c 0F0000EA 		b	.L122
 2111              	.L121:
 898:../CX3RDKOV5640.c **** 					}
 899:../CX3RDKOV5640.c **** 					else
 900:../CX3RDKOV5640.c **** 					{
 901:../CX3RDKOV5640.c **** 						/* Set Probe Control */
 902:../CX3RDKOV5640.c **** 						if(wValue == ES_UVC_STILL_PROBE_CONTROL)
 2112              		.loc 1 902 0
 2113 0690 BC325BE1 		ldrh	r3, [fp, #-44]
 2114 0694 030C53E3 		cmp	r3, #768
 2115 0698 0400001A 		bne	.L123
 903:../CX3RDKOV5640.c **** 						{
 904:../CX3RDKOV5640.c **** 							glCurrentStillFrameIndex = glStillCommitCtrl[1];
 2116              		.loc 1 904 0
 2117 069c D0319FE5 		ldr	r3, .L132+88
 2118 06a0 0120D3E5 		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 2119 06a4 D4319FE5 		ldr	r3, .L132+100
 2120 06a8 0020C3E5 		strb	r2, [r3]
 2121 06ac 070000EA 		b	.L122
 2122              	.L123:
 905:../CX3RDKOV5640.c **** 						}
 906:../CX3RDKOV5640.c **** 						/* Set Commit Control and Start Streaming*/
 907:../CX3RDKOV5640.c **** 						else if(wValue == ES_UVC_STILL_COMMIT_CONTROL)
 2123              		.loc 1 907 0
 2124 06b0 BC325BE1 		ldrh	r3, [fp, #-44]
 2125 06b4 010B53E3 		cmp	r3, #1024
 2126 06b8 0400001A 		bne	.L122
 908:../CX3RDKOV5640.c **** 						{
 909:../CX3RDKOV5640.c **** 							glCurrentStillFrameIndex = glStillCommitCtrl[1];
 2127              		.loc 1 909 0
 2128 06bc B0319FE5 		ldr	r3, .L132+88
 2129 06c0 0120D3E5 		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 2130 06c4 B4319FE5 		ldr	r3, .L132+100
 2131 06c8 0020C3E5 		strb	r2, [r3]
 895:../CX3RDKOV5640.c **** 					{
 2132              		.loc 1 895 0
 2133 06cc 220000EA 		b	.L117
 2134              	.L122:
 2135 06d0 210000EA 		b	.L117
 2136              	.L119:
 910:../CX3RDKOV5640.c **** 						}
 911:../CX3RDKOV5640.c **** 					}
 912:../CX3RDKOV5640.c **** 
 913:../CX3RDKOV5640.c ****                 }
 914:../CX3RDKOV5640.c ****                 else if(wValue == ES_UVC_STILL_TRIGGER)
 2137              		.loc 1 914 0
 2138 06d4 BC325BE1 		ldrh	r3, [fp, #-44]
 2139 06d8 050C53E3 		cmp	r3, #1280
 2140 06dc 4A00001A 		bne	.L89
 915:../CX3RDKOV5640.c ****                 {
 916:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(ES_UVC_STILL_TRIGGER_ALIGNED,&glStillTriggerCtrl, &readCount);
 2141              		.loc 1 916 0
 2142 06e0 32304BE2 		sub	r3, fp, #50
 2143 06e4 1000A0E3 		mov	r0, #16
 2144 06e8 94119FE5 		ldr	r1, .L132+104
 2145 06ec 0320A0E1 		mov	r2, r3
 2146 06f0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2147 06f4 24000BE5 		str	r0, [fp, #-36]
 917:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 2148              		.loc 1 917 0
 2149 06f8 24301BE5 		ldr	r3, [fp, #-36]
 2150 06fc 000053E3 		cmp	r3, #0
 2151 0700 0300000A 		beq	.L124
 918:../CX3RDKOV5640.c **** 					{
 919:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:SET_CUR:GetEP0Data Err = 0x%x.", status);
 2152              		.loc 1 919 0
 2153 0704 0400A0E3 		mov	r0, #4
 2154 0708 54119FE5 		ldr	r1, .L132+72
 2155 070c 24201BE5 		ldr	r2, [fp, #-36]
 2156 0710 FEFFFFEB 		bl	CyU3PDebugPrint
 2157              	.L124:
 920:../CX3RDKOV5640.c **** 					}
 921:../CX3RDKOV5640.c **** 					/* Check the read count. Expecting a count of CX3_UVC_MAX_PROBE_SETTING bytes. */
 922:../CX3RDKOV5640.c **** 					if (readCount > (uint16_t)ES_UVC_STILL_TRIGGER_COUNT)
 2158              		.loc 1 922 0
 2159 0714 B2335BE1 		ldrh	r3, [fp, #-50]
 2160 0718 010053E3 		cmp	r3, #1
 2161 071c 0300009A 		bls	.L125
 923:../CX3RDKOV5640.c **** 					{
 924:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:Invalid SET_CUR Rqt Len.");
 2162              		.loc 1 924 0
 2163 0720 0400A0E3 		mov	r0, #4
 2164 0724 3C119FE5 		ldr	r1, .L132+76
 2165 0728 FEFFFFEB 		bl	CyU3PDebugPrint
 2166 072c 360000EA 		b	.L89
 2167              	.L125:
 925:../CX3RDKOV5640.c **** 					}
 926:../CX3RDKOV5640.c **** 					else
 927:../CX3RDKOV5640.c **** 					{
 928:../CX3RDKOV5640.c **** 						if(glStillTriggerCtrl == 0x01)
 2168              		.loc 1 928 0
 2169 0730 4C319FE5 		ldr	r3, .L132+104
 2170 0734 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2171 0738 010053E3 		cmp	r3, #1
 2172 073c 3200001A 		bne	.L89
 929:../CX3RDKOV5640.c **** 						{
 930:../CX3RDKOV5640.c **** 							glStillSkip = 3;
 2173              		.loc 1 930 0
 2174 0740 40319FE5 		ldr	r3, .L132+108
 2175 0744 0320A0E3 		mov	r2, #3
 2176 0748 0020C3E5 		strb	r2, [r3]
 931:../CX3RDKOV5640.c **** 							glStillCaptureStart = CyTrue;
 2177              		.loc 1 931 0
 2178 074c 38319FE5 		ldr	r3, .L132+112
 2179 0750 0120A0E3 		mov	r2, #1
 2180 0754 002083E5 		str	r2, [r3]
 2181 0758 2B0000EA 		b	.L89
 2182              	.L117:
 2183 075c 2A0000EA 		b	.L89
 2184              	.L106:
 932:../CX3RDKOV5640.c **** 						}
 933:../CX3RDKOV5640.c **** 					}
 934:../CX3RDKOV5640.c ****                 }
 935:../CX3RDKOV5640.c ****             }
 936:../CX3RDKOV5640.c ****             else
 937:../CX3RDKOV5640.c ****             {
 938:../CX3RDKOV5640.c ****                 /* Mark with error. */
 939:../CX3RDKOV5640.c ****                 status = CY_U3P_ERROR_FAILURE;
 2185              		.loc 1 939 0
 2186 0760 4A30A0E3 		mov	r3, #74
 2187 0764 24300BE5 		str	r3, [fp, #-36]
 2188 0768 270000EA 		b	.L89
 2189              	.L105:
 2190 076c 260000EA 		b	.L89
 2191              	.L90:
 940:../CX3RDKOV5640.c ****             }
 941:../CX3RDKOV5640.c ****         }
 942:../CX3RDKOV5640.c ****         else if((wIndex & 0x00FF) == ES_UVC_CONTROL_INTERFACE) /* Video Control Interface */
 2192              		.loc 1 942 0
 2193 0770 BE325BE1 		ldrh	r3, [fp, #-46]
 2194 0774 FF3003E2 		and	r3, r3, #255
 2195 0778 000053E3 		cmp	r3, #0
 2196 077c 2200001A 		bne	.L89
 943:../CX3RDKOV5640.c ****         {
 944:../CX3RDKOV5640.c ****             isHandled = CyTrue;
 2197              		.loc 1 944 0
 2198 0780 0130A0E3 		mov	r3, #1
 2199 0784 20300BE5 		str	r3, [fp, #-32]
 945:../CX3RDKOV5640.c ****             /* Respond to VC_REQUEST_ERROR_CODE_CONTROL and stall every other request as this examp
 946:../CX3RDKOV5640.c ****                any of the Video Control features */
 947:../CX3RDKOV5640.c **** #if 0 /* the two controls handler test */
 948:../CX3RDKOV5640.c ****             if((wIndex == 0x200) && (wValue == 0x200))/*Brightness*/
 949:../CX3RDKOV5640.c ****             {
 950:../CX3RDKOV5640.c ****             	switch(bRequest)
 951:../CX3RDKOV5640.c ****             	{
 952:../CX3RDKOV5640.c ****             	case ES_UVC_USB_GET_INFO_REQ:
 953:../CX3RDKOV5640.c ****             		glGet_Info=0x03;
 954:../CX3RDKOV5640.c ****             		status = CyU3PUsbSendEP0Data(1,&glGet_Info);
 955:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 956:../CX3RDKOV5640.c **** 					{
 957:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
 958:../CX3RDKOV5640.c **** 					}
 959:../CX3RDKOV5640.c **** 					break;
 960:../CX3RDKOV5640.c ****             	case ES_UVC_USB_GET_MIN_REQ:
 961:../CX3RDKOV5640.c **** 					glGet_Info=0x00;
 962:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,&glGet_Info);
 963:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 964:../CX3RDKOV5640.c **** 					{
 965:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
 966:../CX3RDKOV5640.c **** 					}
 967:../CX3RDKOV5640.c **** 					break;
 968:../CX3RDKOV5640.c ****             	case ES_UVC_USB_GET_MAX_REQ:
 969:../CX3RDKOV5640.c **** 					glGet_Info=0xFF;
 970:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,&glGet_Info);
 971:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 972:../CX3RDKOV5640.c **** 					{
 973:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
 974:../CX3RDKOV5640.c **** 					}
 975:../CX3RDKOV5640.c **** 					break;
 976:../CX3RDKOV5640.c ****             	case ES_UVC_USB_GET_RES_REQ:
 977:../CX3RDKOV5640.c **** 					glGet_Info=0x01;
 978:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,&glGet_Info);
 979:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 980:../CX3RDKOV5640.c **** 					{
 981:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
 982:../CX3RDKOV5640.c **** 					}
 983:../CX3RDKOV5640.c **** 					break;
 984:../CX3RDKOV5640.c ****             	case ES_UVC_USB_GET_CUR_REQ:
 985:../CX3RDKOV5640.c ****             	case ES_UVC_USB_GET_DEF_REQ:
 986:../CX3RDKOV5640.c ****             		RequestOption = (bRequest & 0x0F);
 987:../CX3RDKOV5640.c **** 
 988:../CX3RDKOV5640.c ****             		//TODO Change this function with the "Sensor specific" function to Service all the GE
 989:../CX3RDKOV5640.c ****             		gl16GetControl = SensorGetControl(AExReferleveReg0, I2C_EAGLESDP_ADDR);//esOV5640_Get
 990:../CX3RDKOV5640.c ****             		status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
 991:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 992:../CX3RDKOV5640.c **** 					{
 993:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
 994:../CX3RDKOV5640.c **** 					}
 995:../CX3RDKOV5640.c ****             		break;
 996:../CX3RDKOV5640.c ****             	case ES_UVC_USB_SET_CUR_REQ:
 997:../CX3RDKOV5640.c ****             		status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
 998:../CX3RDKOV5640.c ****             		if (status != CY_U3P_SUCCESS)
 999:../CX3RDKOV5640.c **** 					{
1000:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1001:../CX3RDKOV5640.c **** 					}
1002:../CX3RDKOV5640.c ****             		//TODO Change this function with the "Sensor specific" function to Service the SET re
1003:../CX3RDKOV5640.c ****             		SensorSetControl(AExReferleveReg0, I2C_EAGLESDP_ADDR, (int8_t)gl16SetControl);//esOV5
1004:../CX3RDKOV5640.c **** 					break;
1005:../CX3RDKOV5640.c ****             	}
1006:../CX3RDKOV5640.c ****             }
1007:../CX3RDKOV5640.c ****             else if((wIndex == 0x100) && (wValue == 0x200))/*Auto Exposure*/
1008:../CX3RDKOV5640.c **** 			{
1009:../CX3RDKOV5640.c ****             //	CyU3PDebugPrint (4, "\n\rAuto Exposure");
1010:../CX3RDKOV5640.c **** 				switch(bRequest)
1011:../CX3RDKOV5640.c **** 				{
1012:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1013:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1014:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1015:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1016:../CX3RDKOV5640.c **** 					{
1017:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1018:../CX3RDKOV5640.c **** 					}
1019:../CX3RDKOV5640.c **** 					break;
1020:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1021:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1022:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1023:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1024:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1025:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1026:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1027:../CX3RDKOV5640.c **** 					gl8GetControl = SensorGetControl(AExModeReg, I2C_EAGLESDP_ADDR);//esOV5640_GetAutoExposure(Req
1028:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,(uint8_t*)&gl8GetControl);
1029:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1030:../CX3RDKOV5640.c **** 					{
1031:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1032:../CX3RDKOV5640.c **** 					}
1033:../CX3RDKOV5640.c **** 					break;
1034:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1035:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl8SetControl,&readCount);
1036:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1037:../CX3RDKOV5640.c **** 					{
1038:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1039:../CX3RDKOV5640.c **** 					}
1040:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1041:../CX3RDKOV5640.c **** 				//	CyU3PDebugPrint (4, "\n\rAuto Exposure= %d",gl8SetControl);
1042:../CX3RDKOV5640.c **** 					SensorSetControl(AExModeReg, I2C_EAGLESDP_ADDR, (int8_t)gl16SetControl);//esOV5640_SetAutoExpo
1043:../CX3RDKOV5640.c **** 					break;
1044:../CX3RDKOV5640.c **** 				}
1045:../CX3RDKOV5640.c **** 			}
1046:../CX3RDKOV5640.c ****             else if((wIndex == 0x300) && (wValue == 0x300))/*Mirror (Contrast)*/
1047:../CX3RDKOV5640.c ****             {
1048:../CX3RDKOV5640.c ****             	switch(bRequest)
1049:../CX3RDKOV5640.c **** 				{
1050:../CX3RDKOV5640.c ****             	case CY_FX_USB_UVC_GET_LEN_REQ:
1051:../CX3RDKOV5640.c **** 					glGet_Info=0x02;
1052:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2, &glGet_Info);
1053:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1054:../CX3RDKOV5640.c **** 					{
1055:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1056:../CX3RDKOV5640.c **** 					}
1057:../CX3RDKOV5640.c **** 					CyU3PDebugPrint (4, "\n\rUSB_Ext: Mirror SendEP0Data = %d data %d", status, glGet_Info);
1058:../CX3RDKOV5640.c **** 					break;
1059:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1060:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1061:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1062:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1063:../CX3RDKOV5640.c **** 					{
1064:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1065:../CX3RDKOV5640.c **** 					}
1066:../CX3RDKOV5640.c **** 					break;
1067:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1068:../CX3RDKOV5640.c **** 					glGet_Info=0x00;
1069:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,&glGet_Info);
1070:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1071:../CX3RDKOV5640.c **** 					{
1072:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1073:../CX3RDKOV5640.c **** 					}
1074:../CX3RDKOV5640.c **** 					break;
1075:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1076:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1077:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,&glGet_Info);
1078:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1079:../CX3RDKOV5640.c **** 					{
1080:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1081:../CX3RDKOV5640.c **** 					}
1082:../CX3RDKOV5640.c **** 					break;
1083:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1084:../CX3RDKOV5640.c **** 					glGet_Info=0x01;
1085:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,&glGet_Info);
1086:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1087:../CX3RDKOV5640.c **** 					{
1088:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1089:../CX3RDKOV5640.c **** 					}
1090:../CX3RDKOV5640.c **** 					break;
1091:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1092:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1093:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1094:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1095:../CX3RDKOV5640.c **** 					gl16GetControl = SensorGetControl(MirrModeReg, I2C_EAGLESDP_ADDR);//esOV5640_GetContrast(Reque
1096:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
1097:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1098:../CX3RDKOV5640.c **** 					{
1099:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1100:../CX3RDKOV5640.c **** 					}
1101:../CX3RDKOV5640.c **** 					break;
1102:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1103:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1104:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1105:../CX3RDKOV5640.c **** 					{
1106:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1107:../CX3RDKOV5640.c **** 					}
1108:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1109:../CX3RDKOV5640.c **** 					SensorSetControl(MirrModeReg, I2C_EAGLESDP_ADDR, (int8_t)gl16SetControl);//esOV5640_SetContras
1110:../CX3RDKOV5640.c **** 					break;
1111:../CX3RDKOV5640.c **** 				}
1112:../CX3RDKOV5640.c ****             }
1113:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x100) && (wValue == 0x400))/*Manual Exposure*/
1114:../CX3RDKOV5640.c **** 			{
1115:../CX3RDKOV5640.c ****             	//CyU3PDebugPrint (4, "\n\rManual Exposure ");
1116:../CX3RDKOV5640.c **** 				switch(bRequest)
1117:../CX3RDKOV5640.c **** 				{
1118:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1119:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1120:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1121:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1122:../CX3RDKOV5640.c **** 					{
1123:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1124:../CX3RDKOV5640.c **** 					}
1125:../CX3RDKOV5640.c **** 					break;
1126:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1127:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1128:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1129:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1130:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1131:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1132:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1133:../CX3RDKOV5640.c **** 					gl32GetControl = esOV5640_GetExposure(RequestOption);
1134:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(4,(uint8_t*)&gl32GetControl);
1135:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1136:../CX3RDKOV5640.c **** 					{
1137:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1138:../CX3RDKOV5640.c **** 					}
1139:../CX3RDKOV5640.c **** 					break;
1140:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1141:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl32SetControl,&readCount);
1142:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1143:../CX3RDKOV5640.c **** 					{
1144:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1145:../CX3RDKOV5640.c **** 					}
1146:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1147:../CX3RDKOV5640.c **** 				//	CyU3PDebugPrint (4, "\n\rManual Exposure = %d", gl32SetControl);
1148:../CX3RDKOV5640.c **** 					esOV5640_SetExposure(gl32SetControl);
1149:../CX3RDKOV5640.c **** 					break;
1150:../CX3RDKOV5640.c **** 				}
1151:../CX3RDKOV5640.c **** 			}
1152:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x200) && (wValue == 0x600))/*Hue*/
1153:../CX3RDKOV5640.c **** 			{
1154:../CX3RDKOV5640.c **** 				switch(bRequest)
1155:../CX3RDKOV5640.c **** 				{
1156:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1157:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1158:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1159:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1160:../CX3RDKOV5640.c **** 					{
1161:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1162:../CX3RDKOV5640.c **** 					}
1163:../CX3RDKOV5640.c **** 					break;
1164:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1165:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1166:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1167:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1168:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1169:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1170:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1171:../CX3RDKOV5640.c **** 					gl32GetControl = (int32_t)esOV5640_GetHue(RequestOption);
1172:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(4,(uint8_t*)&gl32GetControl);
1173:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1174:../CX3RDKOV5640.c **** 					{
1175:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1176:../CX3RDKOV5640.c **** 					}
1177:../CX3RDKOV5640.c **** 					break;
1178:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1179:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl32SetControl,&readCount);
1180:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1181:../CX3RDKOV5640.c **** 					{
1182:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1183:../CX3RDKOV5640.c **** 					}
1184:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1185:../CX3RDKOV5640.c **** 					esOV5640_SetHue((int8_t)gl32SetControl);
1186:../CX3RDKOV5640.c **** 					break;
1187:../CX3RDKOV5640.c **** 				}
1188:../CX3RDKOV5640.c **** 			}
1189:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x100) && (wValue == 0x600))/*Manual Focus*/
1190:../CX3RDKOV5640.c **** 			{
1191:../CX3RDKOV5640.c ****             	//CyU3PDebugPrint (4, "\n\rManual Focus ");
1192:../CX3RDKOV5640.c **** 				switch(bRequest)
1193:../CX3RDKOV5640.c **** 				{
1194:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1195:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1196:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1197:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1198:../CX3RDKOV5640.c **** 					{
1199:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1200:../CX3RDKOV5640.c **** 					}
1201:../CX3RDKOV5640.c **** 					break;
1202:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1203:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1204:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1205:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1206:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1207:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1208:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1209:../CX3RDKOV5640.c **** 					gl16GetControl = esOV5640_GetManualfocus(RequestOption);
1210:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
1211:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1212:../CX3RDKOV5640.c **** 					{
1213:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1214:../CX3RDKOV5640.c **** 					}
1215:../CX3RDKOV5640.c **** 					break;
1216:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1217:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1218:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1219:../CX3RDKOV5640.c **** 					{
1220:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1221:../CX3RDKOV5640.c **** 					}
1222:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1223:../CX3RDKOV5640.c **** 				//	CyU3PDebugPrint (4, "\n\rManual Focus= %d",gl16SetControl);
1224:../CX3RDKOV5640.c **** 					esOV5640_SetManualfocus((uint16_t)gl16SetControl);
1225:../CX3RDKOV5640.c **** 					g_IsAutoFocus = 0;
1226:../CX3RDKOV5640.c **** 					break;
1227:../CX3RDKOV5640.c **** 				}
1228:../CX3RDKOV5640.c **** 			}
1229:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x200) && (wValue == 0x700))/*Saturation*/
1230:../CX3RDKOV5640.c **** 			{
1231:../CX3RDKOV5640.c **** 				switch(bRequest)
1232:../CX3RDKOV5640.c **** 				{
1233:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1234:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1235:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1236:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1237:../CX3RDKOV5640.c **** 					{
1238:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1239:../CX3RDKOV5640.c **** 					}
1240:../CX3RDKOV5640.c **** 					break;
1241:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1242:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1243:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1244:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1245:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1246:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1247:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1248:../CX3RDKOV5640.c **** 					gl16GetControl = esOV5640_GetSaturation(RequestOption);
1249:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
1250:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1251:../CX3RDKOV5640.c **** 					{
1252:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1253:../CX3RDKOV5640.c **** 					}
1254:../CX3RDKOV5640.c **** 					break;
1255:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1256:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1257:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1258:../CX3RDKOV5640.c **** 					{
1259:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1260:../CX3RDKOV5640.c **** 					}
1261:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1262:../CX3RDKOV5640.c **** 					esOV5640_SetSaturation((uint32_t)gl16SetControl);
1263:../CX3RDKOV5640.c **** 					break;
1264:../CX3RDKOV5640.c **** 				}
1265:../CX3RDKOV5640.c **** 			}
1266:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x200) && (wValue == 0x800))/*Sharpness*/
1267:../CX3RDKOV5640.c **** 			{
1268:../CX3RDKOV5640.c **** 				switch(bRequest)
1269:../CX3RDKOV5640.c **** 				{
1270:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1271:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1272:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1273:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1274:../CX3RDKOV5640.c **** 					{
1275:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1276:../CX3RDKOV5640.c **** 					}
1277:../CX3RDKOV5640.c **** 					break;
1278:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1279:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1280:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1281:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1282:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1283:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1284:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1285:../CX3RDKOV5640.c **** 					gl16GetControl = esOV5640_GetSharpness(RequestOption);
1286:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
1287:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1288:../CX3RDKOV5640.c **** 					{
1289:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1290:../CX3RDKOV5640.c **** 					}
1291:../CX3RDKOV5640.c **** 					break;
1292:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1293:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1294:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1295:../CX3RDKOV5640.c **** 					{
1296:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1297:../CX3RDKOV5640.c **** 					}
1298:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1299:../CX3RDKOV5640.c **** 					esOV5640_SetSharpness((uint8_t)gl16SetControl);
1300:../CX3RDKOV5640.c **** 					break;
1301:../CX3RDKOV5640.c **** 				}
1302:../CX3RDKOV5640.c **** 			}
1303:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x100) && (wValue == 0x800))/*Auto Focus*/
1304:../CX3RDKOV5640.c **** 			{
1305:../CX3RDKOV5640.c ****             	CyU3PDebugPrint (4, "\n\rAuto Focus");
1306:../CX3RDKOV5640.c **** 				switch(bRequest)
1307:../CX3RDKOV5640.c **** 				{
1308:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1309:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1310:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1311:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1312:../CX3RDKOV5640.c **** 					{
1313:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1314:../CX3RDKOV5640.c **** 					}
1315:../CX3RDKOV5640.c **** 					break;
1316:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1317:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1318:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1319:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1320:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1321:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1322:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1323:../CX3RDKOV5640.c **** 					gl8GetControl = esOV5640_GetAutofocus(RequestOption);
1324:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl8GetControl);
1325:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1326:../CX3RDKOV5640.c **** 					{
1327:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1328:../CX3RDKOV5640.c **** 					}
1329:../CX3RDKOV5640.c **** 					break;
1330:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1331:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl8SetControl,&readCount);
1332:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1333:../CX3RDKOV5640.c **** 					{
1334:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1335:../CX3RDKOV5640.c **** 					}
1336:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1337:../CX3RDKOV5640.c **** 				//	CyU3PDebugPrint (4, "\n\rAuto Focus =%d",gl8SetControl);
1338:../CX3RDKOV5640.c **** 					esOV5640_SetAutofocus((uint8_t)gl8SetControl);
1339:../CX3RDKOV5640.c **** 					g_IsAutoFocus = 1;
1340:../CX3RDKOV5640.c **** 					break;
1341:../CX3RDKOV5640.c **** 				}
1342:../CX3RDKOV5640.c **** 			}
1343:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x200) && (wValue == 0xA00))/*White Balance manual*/
1344:../CX3RDKOV5640.c **** 			{
1345:../CX3RDKOV5640.c **** 				switch(bRequest)
1346:../CX3RDKOV5640.c **** 				{
1347:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1348:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1349:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1350:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1351:../CX3RDKOV5640.c **** 					{
1352:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1353:../CX3RDKOV5640.c **** 					}
1354:../CX3RDKOV5640.c **** 					break;
1355:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1356:../CX3RDKOV5640.c **** 					glGet_Info=0x00;
1357:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&glGet_Info);
1358:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1359:../CX3RDKOV5640.c **** 					{
1360:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1361:../CX3RDKOV5640.c **** 					}
1362:../CX3RDKOV5640.c **** 					break;
1363:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1364:../CX3RDKOV5640.c **** 					glGet_Info=0xFF;
1365:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&glGet_Info);
1366:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1367:../CX3RDKOV5640.c **** 					{
1368:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1369:../CX3RDKOV5640.c **** 					}
1370:../CX3RDKOV5640.c **** 					break;
1371:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1372:../CX3RDKOV5640.c **** 					glGet_Info=0x1;
1373:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&glGet_Info);
1374:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1375:../CX3RDKOV5640.c **** 					{
1376:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1377:../CX3RDKOV5640.c **** 					}
1378:../CX3RDKOV5640.c **** 					break;
1379:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1380:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1381:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1382:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1383:../CX3RDKOV5640.c **** 					gl16GetControl = esOV5640_GetWhiteBalance(RequestOption);
1384:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
1385:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1386:../CX3RDKOV5640.c **** 					{
1387:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1388:../CX3RDKOV5640.c **** 					}
1389:../CX3RDKOV5640.c **** 					break;
1390:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1391:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1392:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1393:../CX3RDKOV5640.c **** 					{
1394:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1395:../CX3RDKOV5640.c **** 					}
1396:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1397:../CX3RDKOV5640.c **** 					esOV5640_SetWhiteBalance((uint8_t)gl16SetControl);
1398:../CX3RDKOV5640.c **** 					break;
1399:../CX3RDKOV5640.c **** 				}
1400:../CX3RDKOV5640.c **** 			}
1401:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x200) && (wValue == 0xB00))/*White Balance Auto*/
1402:../CX3RDKOV5640.c **** 			{
1403:../CX3RDKOV5640.c **** 				switch(bRequest)
1404:../CX3RDKOV5640.c **** 				{
1405:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1406:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1407:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1408:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1409:../CX3RDKOV5640.c **** 					{
1410:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1411:../CX3RDKOV5640.c **** 					}
1412:../CX3RDKOV5640.c **** 					break;
1413:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1414:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1415:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1416:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1417:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1418:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1419:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1420:../CX3RDKOV5640.c **** 					gl16GetControl = esOV5640_GetAutoWhiteBalance(RequestOption);
1421:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
1422:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1423:../CX3RDKOV5640.c **** 					{
1424:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1425:../CX3RDKOV5640.c **** 					}
1426:../CX3RDKOV5640.c **** 					break;
1427:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1428:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1429:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1430:../CX3RDKOV5640.c **** 					{
1431:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1432:../CX3RDKOV5640.c **** 					}
1433:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1434:../CX3RDKOV5640.c **** 					esOV5640_SetAutoWhiteBalance((uint8_t)gl16SetControl);
1435:../CX3RDKOV5640.c **** 					break;
1436:../CX3RDKOV5640.c **** 				}
1437:../CX3RDKOV5640.c **** 			}
1438:../CX3RDKOV5640.c ****             else if((wValue == ES_UVC_VC_REQUEST_ERROR_CODE_CONTROL) && (wIndex == 0x00))
1439:../CX3RDKOV5640.c ****             {
1440:../CX3RDKOV5640.c ****                 temp = ES_UVC_ERROR_INVALID_CONTROL;
1441:../CX3RDKOV5640.c ****                 status = CyU3PUsbSendEP0Data(0x01, &temp);
1442:../CX3RDKOV5640.c ****                 if (status != CY_U3P_SUCCESS)
1443:../CX3RDKOV5640.c ****                 {
1444:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1445:../CX3RDKOV5640.c ****                 }
1446:../CX3RDKOV5640.c ****             }
1447:../CX3RDKOV5640.c ****             else
1448:../CX3RDKOV5640.c ****                 CyU3PUsbStall(0,CyTrue, CyTrue);
1449:../CX3RDKOV5640.c **** #else
1450:../CX3RDKOV5640.c ****             /* the new UVC control requests handler */
1451:../CX3RDKOV5640.c ****         	switch ((wIndex >> 8))
 2200              		.loc 1 1451 0
 2201 0788 BE325BE1 		ldrh	r3, [fp, #-46]
 2202 078c 2334A0E1 		mov	r3, r3, lsr #8
 2203 0790 0338A0E1 		mov	r3, r3, asl #16
 2204 0794 2338A0E1 		mov	r3, r3, lsr #16
 2205 0798 020053E3 		cmp	r3, #2
 2206 079c 0200000A 		beq	.L127
 2207 07a0 030053E3 		cmp	r3, #3
 2208 07a4 0600000A 		beq	.L128
 2209 07a8 0B0000EA 		b	.L131
 2210              	.L127:
1452:../CX3RDKOV5640.c ****             {
1453:../CX3RDKOV5640.c **** 
1454:../CX3RDKOV5640.c ****                 case CY_FX_UVC_PROCESSING_UNIT_ID:
1455:../CX3RDKOV5640.c ****                     UVCHandleProcessingUnitRqts (wValue, bRequest);
 2211              		.loc 1 1455 0
 2212 07ac BC225BE1 		ldrh	r2, [fp, #-44]
 2213 07b0 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 2214 07b4 0200A0E1 		mov	r0, r2
 2215 07b8 0310A0E1 		mov	r1, r3
 2216 07bc FEFFFFEB 		bl	UVCHandleProcessingUnitRqts
1456:../CX3RDKOV5640.c ****                     break;
 2217              		.loc 1 1456 0
 2218 07c0 0A0000EA 		b	.L129
 2219              	.L128:
1457:../CX3RDKOV5640.c ****                 case CY_FX_UVC_EXTENSION_UNIT_ID:
1458:../CX3RDKOV5640.c ****                     UVCHandleExtensionUnitRqts (wValue, bRequest);
 2220              		.loc 1 1458 0
 2221 07c4 BC225BE1 		ldrh	r2, [fp, #-44]
 2222 07c8 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 2223 07cc 0200A0E1 		mov	r0, r2
 2224 07d0 0310A0E1 		mov	r1, r3
 2225 07d4 FEFFFFEB 		bl	UVCHandleExtensionUnitRqts
1459:../CX3RDKOV5640.c ****                     break;
 2226              		.loc 1 1459 0
 2227 07d8 040000EA 		b	.L129
 2228              	.L131:
1460:../CX3RDKOV5640.c ****                 case CY_FX_UVC_CAMERA_TERMINAL_ID:
1461:../CX3RDKOV5640.c ****                     //UVCHandleCameraTerminalRqts ();
1462:../CX3RDKOV5640.c ****                     //break;
1463:../CX3RDKOV5640.c ****                 case CY_FX_UVC_INTERFACE_CTRL:
1464:../CX3RDKOV5640.c ****                     //UVCHandleInterfaceCtrlRqts ();
1465:../CX3RDKOV5640.c ****                     //break;
1466:../CX3RDKOV5640.c **** 
1467:../CX3RDKOV5640.c ****                 default:
1468:../CX3RDKOV5640.c ****                     /* Unsupported request. Fail by stalling the control endpoint. */
1469:../CX3RDKOV5640.c ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
 2229              		.loc 1 1469 0
 2230 07dc 0000A0E3 		mov	r0, #0
 2231 07e0 0110A0E3 		mov	r1, #1
 2232 07e4 0020A0E3 		mov	r2, #0
 2233 07e8 FEFFFFEB 		bl	CyU3PUsbStall
1470:../CX3RDKOV5640.c ****                     break;
 2234              		.loc 1 1470 0
 2235 07ec 0000A0E1 		mov	r0, r0	@ nop
 2236              	.L129:
1471:../CX3RDKOV5640.c ****             }
1472:../CX3RDKOV5640.c ****         	CyU3PDebugPrint (4, "\n\rUSBStpCB:control interface wIndex = 0x%x wValue = 0x%x bRequest =
 2237              		.loc 1 1472 0
 2238 07f0 BE225BE1 		ldrh	r2, [fp, #-46]
 2239 07f4 BC325BE1 		ldrh	r3, [fp, #-44]
 2240 07f8 2A105BE5 		ldrb	r1, [fp, #-42]	@ zero_extendqisi2
 2241 07fc 00108DE5 		str	r1, [sp]
 2242 0800 0400A0E3 		mov	r0, #4
 2243 0804 84109FE5 		ldr	r1, .L132+116
 2244 0808 FEFFFFEB 		bl	CyU3PDebugPrint
 2245              	.L89:
1473:../CX3RDKOV5640.c ****         	/* the end of the controls handler */
1474:../CX3RDKOV5640.c **** #endif
1475:../CX3RDKOV5640.c ****         }
1476:../CX3RDKOV5640.c ****     }
1477:../CX3RDKOV5640.c ****     return isHandled;
 2246              		.loc 1 1477 0
 2247 080c 20301BE5 		ldr	r3, [fp, #-32]
 2248              	.L130:
1478:../CX3RDKOV5640.c **** }
 2249              		.loc 1 1478 0
 2250 0810 0300A0E1 		mov	r0, r3
 2251 0814 18D04BE2 		sub	sp, fp, #24
 2252              		@ sp needed
 2253 0818 F089BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, fp, pc}
 2254              	.L133:
 2255              		.align	2
 2256              	.L132:
 2257 081c 64010000 		.word	.LC10
 2258 0820 00000000 		.word	glIsApplnActive
 2259 0824 00000000 		.word	glIsStreamingStarted
 2260 0828 00000000 		.word	glPreviewStarted
 2261 082c 00000000 		.word	glIsClearFeature
 2262 0830 00000000 		.word	glcommitcount
 2263 0834 00000000 		.word	glIsConfigured
 2264 0838 00000000 		.word	glCurrentFrameIndex
 2265 083c 00000000 		.word	glProbeCtrl
 2266 0840 00000000 		.word	gl5MpProbeCtrl
 2267 0844 00000000 		.word	gl720pProbeCtrl
 2268 0848 00000000 		.word	glVga60ProbeCtrl
 2269 084c 00000000 		.word	gl1080pProbeCtrl
 2270 0850 00000000 		.word	glVga30ProbeCtrl
 2271 0854 B4010000 		.word	.LC11
 2272 0858 D0010000 		.word	.LC12
 2273 085c 00000000 		.word	glStillProbeCtrl
 2274 0860 00000000 		.word	glCommitCtrl
 2275 0864 FC010000 		.word	.LC13
 2276 0868 28020000 		.word	.LC14
 2277 086c 00000000 		.word	glcheckframe
 2278 0870 00000000 		.word	glFrameIndexToSet
 2279 0874 00000000 		.word	glStillCommitCtrl
 2280 0878 4C020000 		.word	.LC15
 2281 087c 70020000 		.word	.LC16
 2282 0880 00000000 		.word	glCurrentStillFrameIndex
 2283 0884 00000000 		.word	glStillTriggerCtrl
 2284 0888 00000000 		.word	glStillSkip
 2285 088c 00000000 		.word	glStillCaptureStart
 2286 0890 98020000 		.word	.LC17
 2287              		.cfi_endproc
 2288              	.LFE10:
 2290              		.section	.rodata
 2291 02e1 000000   		.align	2
 2292              	.LC18:
 2293 02e4 0A0D4170 		.ascii	"\012\015AppInit:I2CInit Err = 0x%x.\000"
 2293      70496E69 
 2293      743A4932 
 2293      43496E69 
 2293      74204572 
 2294 0302 0000     		.align	2
 2295              	.LC19:
 2296 0304 0A0D4170 		.ascii	"\012\015AppInit:GPIOInit Err = 0x%x\000"
 2296      70496E69 
 2296      743A4750 
 2296      494F496E 
 2296      69742045 
 2297 0322 0000     		.align	2
 2298              	.LC20:
 2299 0324 0A0D4170 		.ascii	"\012\015AppInit:PIBInit Err = 0x%x\000"
 2299      70496E69 
 2299      743A5049 
 2299      42496E69 
 2299      74204572 
 2300 0341 000000   		.align	2
 2301              	.LC21:
 2302 0344 0A0D4170 		.ascii	"\012\015AppInit:UsbStart Err = 0x%x\000"
 2302      70496E69 
 2302      743A5573 
 2302      62537461 
 2302      72742045 
 2303 0362 0000     		.align	2
 2304              	.LC22:
 2305 0364 0A0D4170 		.ascii	"\012\015AppInit:Set_SS_Device_Dscr Err = 0x%x\000"
 2305      70496E69 
 2305      743A5365 
 2305      745F5353 
 2305      5F446576 
 2306              		.align	2
 2307              	.LC23:
 2308 038c 0A0D4170 		.ascii	"\012\015AppInit:Set_HS_Device_Dscr Err = 0x%x\000"
 2308      70496E69 
 2308      743A5365 
 2308      745F4853 
 2308      5F446576 
 2309              		.align	2
 2310              	.LC24:
 2311 03b4 0A0D4170 		.ascii	"\012\015AppInit:Set_BOS_Dscr Err = 0x%x\000"
 2311      70496E69 
 2311      743A5365 
 2311      745F424F 
 2311      535F4473 
 2312 03d6 0000     		.align	2
 2313              	.LC25:
 2314 03d8 0A0D4170 		.ascii	"\012\015AppInit:Set_DEVQUAL_Dscr Err = 0x%x\000"
 2314      70496E69 
 2314      743A5365 
 2314      745F4445 
 2314      56515541 
 2315 03fe 0000     		.align	2
 2316              	.LC26:
 2317 0400 0A0D4170 		.ascii	"\012\015AppInit:Set_SS_CFG_Dscr Err = 0x%x\000"
 2317      70496E69 
 2317      743A5365 
 2317      745F5353 
 2317      5F434647 
 2318 0425 000000   		.align	2
 2319              	.LC27:
 2320 0428 0A0D4170 		.ascii	"\012\015AppInit:Set_HS_CFG_Dscr Err = 0x%x\000"
 2320      70496E69 
 2320      743A5365 
 2320      745F4853 
 2320      5F434647 
 2321 044d 000000   		.align	2
 2322              	.LC28:
 2323 0450 0A0D4170 		.ascii	"\012\015AppInit:Set_FS_CFG_Dscr Err = 0x%x\000"
 2323      70496E69 
 2323      743A5365 
 2323      745F4653 
 2323      5F434647 
 2324 0475 000000   		.align	2
 2325              	.LC29:
 2326 0478 0A0D4170 		.ascii	"\012\015AppInit:Set_STRNG_Dscr0 Err = 0x%x\000"
 2326      70496E69 
 2326      743A5365 
 2326      745F5354 
 2326      524E475F 
 2327 049d 000000   		.align	2
 2328              	.LC30:
 2329 04a0 0A0D4170 		.ascii	"\012\015AppInit:Set_STRNG_Dscr1 Err = 0x%x\000"
 2329      70496E69 
 2329      743A5365 
 2329      745F5354 
 2329      524E475F 
 2330 04c5 000000   		.align	2
 2331              	.LC31:
 2332 04c8 0A0D4170 		.ascii	"\012\015AppInit:Set_STRNG_Dscr2 Err = 0x%x\000"
 2332      70496E69 
 2332      743A5365 
 2332      745F5354 
 2332      524E475F 
 2333 04ed 000000   		.align	2
 2334              	.LC32:
 2335 04f0 0A0D4170 		.ascii	"\012\015AppInit:Set_STRNG_Dscr3 Err = 0x%x\000"
 2335      70496E69 
 2335      743A5365 
 2335      745F5354 
 2335      524E475F 
 2336 0515 000000   		.align	2
 2337              	.LC33:
 2338 0518 0A0D4170 		.ascii	"\012\015AppInit:Set_STRNG_Dscr4 Err = 0x%x\000"
 2338      70496E69 
 2338      743A5365 
 2338      745F5354 
 2338      524E475F 
 2339 053d 000000   		.align	2
 2340              	.LC34:
 2341 0540 0A0D4170 		.ascii	"\012\015AppInit:Set_STRNG_Dscr5 Err = 0x%x\000"
 2341      70496E69 
 2341      743A5365 
 2341      745F5354 
 2341      524E475F 
 2342 0565 000000   		.align	2
 2343              	.LC35:
 2344 0568 0A0D4170 		.ascii	"\012\015AppInit:ConnectState Err = 0x%x\000"
 2344      70496E69 
 2344      743A436F 
 2344      6E6E6563 
 2344      74537461 
 2345 058a 0000     		.align	2
 2346              	.LC36:
 2347 058c 0A0D4170 		.ascii	"\012\015AppInit:CyU3PSetEpConfig CtrlEp Err = 0x%x\000"
 2347      70496E69 
 2347      743A4379 
 2347      55335053 
 2347      65744570 
 2348 05b9 000000   		.align	2
 2349              	.LC37:
 2350 05bc 0A0D4170 		.ascii	"\012\015AppInit:CyU3PSetEpConfig BulkEp Err = 0x%x\000"
 2350      70496E69 
 2350      743A4379 
 2350      55335053 
 2350      65744570 
 2351 05e9 000000   		.align	2
 2352              	.LC38:
 2353 05ec 0A0D4170 		.ascii	"\012\015AppInit:DmaMultiChannelCreate Err = 0x%x\000"
 2353      70496E69 
 2353      743A446D 
 2353      614D756C 
 2353      74694368 
 2354 0617 00       		.align	2
 2355              	.LC39:
 2356 0618 0A0D4170 		.ascii	"\012\015AppInit:MultiChannelReset Err = 0x%x\000"
 2356      70496E69 
 2356      743A4D75 
 2356      6C746943 
 2356      68616E6E 
 2357 063f 00       		.align	2
 2358              	.LC40:
 2359 0640 0A0D4170 		.ascii	"\012\015AppInit:MipicsiGpifLoad Err = 0x%x\000"
 2359      70496E69 
 2359      743A4D69 
 2359      70696373 
 2359      69477069 
 2360 0665 000000   		.align	2
 2361              	.LC41:
 2362 0668 0A0D4170 		.ascii	"\012\015AppInit:GpifSMStart Err = 0x%x\000"
 2362      70496E69 
 2362      743A4770 
 2362      6966534D 
 2362      53746172 
 2363 0689 000000   		.align	2
 2364              	.LC42:
 2365 068c 0A0D4170 		.ascii	"\012\015AppInit:MipicsiInit Err = 0x%x\000"
 2365      70496E69 
 2365      743A4D69 
 2365      70696373 
 2365      69496E69 
 2366 06ad 000000   		.align	2
 2367              	.LC43:
 2368 06b0 0A0D4170 		.ascii	"\012\015AppInit:MipicsiSetIntfParams Err = 0x%x\000"
 2368      70496E69 
 2368      743A4D69 
 2368      70696373 
 2368      69536574 
 2369 06da 0000     		.align	2
 2370              	.LC44:
 2371 06dc 0A0D4669 		.ascii	"\012\015Firmware Version: %d.%d.%d.%d\000"
 2371      726D7761 
 2371      72652056 
 2371      65727369 
 2371      6F6E3A20 
 2372              		.section	.text.esUVCUvcApplnInit,"ax",%progbits
 2373              		.align	2
 2374              		.global	esUVCUvcApplnInit
 2376              	esUVCUvcApplnInit:
 2377              	.LFB11:
1479:../CX3RDKOV5640.c **** 
1480:../CX3RDKOV5640.c **** 
1481:../CX3RDKOV5640.c **** /* This function initializes the USB Module, creates event group,
1482:../CX3RDKOV5640.c ****    sets the enumeration descriptors, configures the Endpoints and
1483:../CX3RDKOV5640.c ****    configures the DMA module for the UVC Application */
1484:../CX3RDKOV5640.c ****     void
1485:../CX3RDKOV5640.c **** esUVCUvcApplnInit (void)
1486:../CX3RDKOV5640.c **** {
 2378              		.loc 1 1486 0
 2379              		.cfi_startproc
 2380              		@ args = 0, pretend = 0, frame = 56
 2381              		@ frame_needed = 1, uses_anonymous_args = 0
 2382 0000 00482DE9 		stmfd	sp!, {fp, lr}
 2383              	.LCFI22:
 2384              		.cfi_def_cfa_offset 8
 2385              		.cfi_offset 11, -8
 2386              		.cfi_offset 14, -4
 2387 0004 04B08DE2 		add	fp, sp, #4
 2388              	.LCFI23:
 2389              		.cfi_def_cfa 11, 4
 2390 0008 48D04DE2 		sub	sp, sp, #72
1487:../CX3RDKOV5640.c ****     CyU3PEpConfig_t endPointConfig;
1488:../CX3RDKOV5640.c ****     CyU3PDmaMultiChannelConfig_t dmaCfg;
1489:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 2391              		.loc 1 1489 0
 2392 000c 0030A0E3 		mov	r3, #0
 2393 0010 08300BE5 		str	r3, [fp, #-8]
1490:../CX3RDKOV5640.c **** 
1491:../CX3RDKOV5640.c ****     /* Initialize the I2C interface for Mipi Block Usage and Camera. */
1492:../CX3RDKOV5640.c ****     status = CyU3PMipicsiInitializeI2c (CY_U3P_MIPICSI_I2C_400KHZ);
 2394              		.loc 1 1492 0
 2395 0014 0100A0E3 		mov	r0, #1
 2396 0018 FEFFFFEB 		bl	CyU3PMipicsiInitializeI2c
 2397 001c 08000BE5 		str	r0, [fp, #-8]
1493:../CX3RDKOV5640.c ****     if( status != CY_U3P_SUCCESS)
 2398              		.loc 1 1493 0
 2399 0020 08301BE5 		ldr	r3, [fp, #-8]
 2400 0024 000053E3 		cmp	r3, #0
 2401 0028 0500000A 		beq	.L135
1494:../CX3RDKOV5640.c ****     {
1495:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:I2CInit Err = 0x%x.",status);
 2402              		.loc 1 1495 0
 2403 002c 0400A0E3 		mov	r0, #4
 2404 0030 70179FE5 		ldr	r1, .L166
 2405 0034 08201BE5 		ldr	r2, [fp, #-8]
 2406 0038 FEFFFFEB 		bl	CyU3PDebugPrint
1496:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2407              		.loc 1 1496 0
 2408 003c 08001BE5 		ldr	r0, [fp, #-8]
 2409 0040 FEFFFFEB 		bl	esUVCAppErrorHandler
 2410              	.L135:
1497:../CX3RDKOV5640.c ****     }
1498:../CX3RDKOV5640.c **** #ifdef VISDebug
1499:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:I2CInit");
1500:../CX3RDKOV5640.c **** #endif
1501:../CX3RDKOV5640.c ****     /* Initialize GPIO module. */
1502:../CX3RDKOV5640.c ****     status = CyU3PMipicsiInitializeGPIO ();
 2411              		.loc 1 1502 0
 2412 0044 FEFFFFEB 		bl	CyU3PMipicsiInitializeGPIO
 2413 0048 08000BE5 		str	r0, [fp, #-8]
1503:../CX3RDKOV5640.c ****     if( status != CY_U3P_SUCCESS)
 2414              		.loc 1 1503 0
 2415 004c 08301BE5 		ldr	r3, [fp, #-8]
 2416 0050 000053E3 		cmp	r3, #0
 2417 0054 0500000A 		beq	.L136
1504:../CX3RDKOV5640.c ****     {
1505:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:GPIOInit Err = 0x%x",status);
 2418              		.loc 1 1505 0
 2419 0058 0400A0E3 		mov	r0, #4
 2420 005c 48179FE5 		ldr	r1, .L166+4
 2421 0060 08201BE5 		ldr	r2, [fp, #-8]
 2422 0064 FEFFFFEB 		bl	CyU3PDebugPrint
1506:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2423              		.loc 1 1506 0
 2424 0068 08001BE5 		ldr	r0, [fp, #-8]
 2425 006c FEFFFFEB 		bl	esUVCAppErrorHandler
 2426              	.L136:
1507:../CX3RDKOV5640.c ****     }
1508:../CX3RDKOV5640.c **** #ifdef VISDebug
1509:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:GPIOInit");
1510:../CX3RDKOV5640.c **** #endif
1511:../CX3RDKOV5640.c ****     /* Initialize the PIB block */
1512:../CX3RDKOV5640.c ****     status = CyU3PMipicsiInitializePIB ();
 2427              		.loc 1 1512 0
 2428 0070 FEFFFFEB 		bl	CyU3PMipicsiInitializePIB
 2429 0074 08000BE5 		str	r0, [fp, #-8]
1513:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2430              		.loc 1 1513 0
 2431 0078 08301BE5 		ldr	r3, [fp, #-8]
 2432 007c 000053E3 		cmp	r3, #0
 2433 0080 0500000A 		beq	.L137
1514:../CX3RDKOV5640.c ****     {
1515:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:PIBInit Err = 0x%x",status);
 2434              		.loc 1 1515 0
 2435 0084 0400A0E3 		mov	r0, #4
 2436 0088 20179FE5 		ldr	r1, .L166+8
 2437 008c 08201BE5 		ldr	r2, [fp, #-8]
 2438 0090 FEFFFFEB 		bl	CyU3PDebugPrint
1516:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2439              		.loc 1 1516 0
 2440 0094 08001BE5 		ldr	r0, [fp, #-8]
 2441 0098 FEFFFFEB 		bl	esUVCAppErrorHandler
 2442              	.L137:
1517:../CX3RDKOV5640.c ****     }
1518:../CX3RDKOV5640.c **** #ifdef VISDebug
1519:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:PIBInit");
1520:../CX3RDKOV5640.c **** #endif
1521:../CX3RDKOV5640.c ****     /* Start the USB functionality */
1522:../CX3RDKOV5640.c ****     status = CyU3PUsbStart();
 2443              		.loc 1 1522 0
 2444 009c FEFFFFEB 		bl	CyU3PUsbStart
 2445 00a0 08000BE5 		str	r0, [fp, #-8]
1523:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2446              		.loc 1 1523 0
 2447 00a4 08301BE5 		ldr	r3, [fp, #-8]
 2448 00a8 000053E3 		cmp	r3, #0
 2449 00ac 0500000A 		beq	.L138
1524:../CX3RDKOV5640.c ****     {
1525:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:UsbStart Err = 0x%x",status);
 2450              		.loc 1 1525 0
 2451 00b0 0400A0E3 		mov	r0, #4
 2452 00b4 F8169FE5 		ldr	r1, .L166+12
 2453 00b8 08201BE5 		ldr	r2, [fp, #-8]
 2454 00bc FEFFFFEB 		bl	CyU3PDebugPrint
1526:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2455              		.loc 1 1526 0
 2456 00c0 08001BE5 		ldr	r0, [fp, #-8]
 2457 00c4 FEFFFFEB 		bl	esUVCAppErrorHandler
 2458              	.L138:
1527:../CX3RDKOV5640.c ****     }
1528:../CX3RDKOV5640.c **** #ifdef VISDebug
1529:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:UsbStart");
1530:../CX3RDKOV5640.c **** #endif
1531:../CX3RDKOV5640.c ****     /* The fast enumeration is the easiest way to setup a USB connection,
1532:../CX3RDKOV5640.c ****      * where all enumeration phase is handled by the library. Only the
1533:../CX3RDKOV5640.c ****      * class / vendor requests need to be handled by the application. */
1534:../CX3RDKOV5640.c ****     CyU3PUsbRegisterSetupCallback(esUVCUvcApplnUSBSetupCB, CyTrue);
 2459              		.loc 1 1534 0
 2460 00c8 E8069FE5 		ldr	r0, .L166+16
 2461 00cc 0110A0E3 		mov	r1, #1
 2462 00d0 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
1535:../CX3RDKOV5640.c **** 
1536:../CX3RDKOV5640.c ****     /* Setup the callback to handle the USB events */
1537:../CX3RDKOV5640.c ****     CyU3PUsbRegisterEventCallback(esUVCUvcApplnUSBEventCB);
 2463              		.loc 1 1537 0
 2464 00d4 E0069FE5 		ldr	r0, .L166+20
 2465 00d8 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
1538:../CX3RDKOV5640.c **** 
1539:../CX3RDKOV5640.c ****     /* Register a callback to handle LPM requests from the USB 3.0 host. */
1540:../CX3RDKOV5640.c ****     CyU3PUsbRegisterLPMRequestCallback (esUVCApplnLPMRqtCB);
 2466              		.loc 1 1540 0
 2467 00dc DC069FE5 		ldr	r0, .L166+24
 2468 00e0 FEFFFFEB 		bl	CyU3PUsbRegisterLPMRequestCallback
1541:../CX3RDKOV5640.c **** 
1542:../CX3RDKOV5640.c ****     /* Set the USB Enumeration descriptors */
1543:../CX3RDKOV5640.c **** 
1544:../CX3RDKOV5640.c ****     /* Super speed device descriptor. */
1545:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_DEVICE_DESCR, 0, (uint8_t *)esUVCUSB30DeviceDscr);
 2469              		.loc 1 1545 0
 2470 00e4 0000A0E3 		mov	r0, #0
 2471 00e8 0010A0E3 		mov	r1, #0
 2472 00ec D0269FE5 		ldr	r2, .L166+28
 2473 00f0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2474 00f4 08000BE5 		str	r0, [fp, #-8]
1546:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2475              		.loc 1 1546 0
 2476 00f8 08301BE5 		ldr	r3, [fp, #-8]
 2477 00fc 000053E3 		cmp	r3, #0
 2478 0100 0500000A 		beq	.L139
1547:../CX3RDKOV5640.c ****     {
1548:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_SS_Device_Dscr Err = 0x%x", status);
 2479              		.loc 1 1548 0
 2480 0104 0400A0E3 		mov	r0, #4
 2481 0108 B8169FE5 		ldr	r1, .L166+32
 2482 010c 08201BE5 		ldr	r2, [fp, #-8]
 2483 0110 FEFFFFEB 		bl	CyU3PDebugPrint
1549:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2484              		.loc 1 1549 0
 2485 0114 08001BE5 		ldr	r0, [fp, #-8]
 2486 0118 FEFFFFEB 		bl	esUVCAppErrorHandler
 2487              	.L139:
1550:../CX3RDKOV5640.c ****     }
1551:../CX3RDKOV5640.c **** #ifdef VISDebug
1552:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_SS_Device_Dscr");
1553:../CX3RDKOV5640.c **** #endif
1554:../CX3RDKOV5640.c ****     /* High speed device descriptor. */
1555:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_HS_DEVICE_DESCR, 0, (uint8_t *)esUVCUSB20DeviceDscr);
 2488              		.loc 1 1555 0
 2489 011c 0100A0E3 		mov	r0, #1
 2490 0120 0010A0E3 		mov	r1, #0
 2491 0124 A0269FE5 		ldr	r2, .L166+36
 2492 0128 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2493 012c 08000BE5 		str	r0, [fp, #-8]
1556:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2494              		.loc 1 1556 0
 2495 0130 08301BE5 		ldr	r3, [fp, #-8]
 2496 0134 000053E3 		cmp	r3, #0
 2497 0138 0500000A 		beq	.L140
1557:../CX3RDKOV5640.c ****     {
1558:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_HS_Device_Dscr Err = 0x%x", status);
 2498              		.loc 1 1558 0
 2499 013c 0400A0E3 		mov	r0, #4
 2500 0140 88169FE5 		ldr	r1, .L166+40
 2501 0144 08201BE5 		ldr	r2, [fp, #-8]
 2502 0148 FEFFFFEB 		bl	CyU3PDebugPrint
1559:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2503              		.loc 1 1559 0
 2504 014c 08001BE5 		ldr	r0, [fp, #-8]
 2505 0150 FEFFFFEB 		bl	esUVCAppErrorHandler
 2506              	.L140:
1560:../CX3RDKOV5640.c ****     }
1561:../CX3RDKOV5640.c **** #ifdef VISDebug
1562:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_HS_Device_Dscr");
1563:../CX3RDKOV5640.c **** #endif
1564:../CX3RDKOV5640.c ****     /* BOS descriptor */
1565:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_BOS_DESCR, 0, (uint8_t *)esUVCUSBBOSDscr);
 2507              		.loc 1 1565 0
 2508 0154 0700A0E3 		mov	r0, #7
 2509 0158 0010A0E3 		mov	r1, #0
 2510 015c 70269FE5 		ldr	r2, .L166+44
 2511 0160 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2512 0164 08000BE5 		str	r0, [fp, #-8]
1566:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2513              		.loc 1 1566 0
 2514 0168 08301BE5 		ldr	r3, [fp, #-8]
 2515 016c 000053E3 		cmp	r3, #0
 2516 0170 0500000A 		beq	.L141
1567:../CX3RDKOV5640.c ****     {
1568:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_BOS_Dscr Err = 0x%x", status);
 2517              		.loc 1 1568 0
 2518 0174 0400A0E3 		mov	r0, #4
 2519 0178 58169FE5 		ldr	r1, .L166+48
 2520 017c 08201BE5 		ldr	r2, [fp, #-8]
 2521 0180 FEFFFFEB 		bl	CyU3PDebugPrint
1569:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2522              		.loc 1 1569 0
 2523 0184 08001BE5 		ldr	r0, [fp, #-8]
 2524 0188 FEFFFFEB 		bl	esUVCAppErrorHandler
 2525              	.L141:
1570:../CX3RDKOV5640.c ****     }
1571:../CX3RDKOV5640.c **** #ifdef VISDebug
1572:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_BOS_Dscr");
1573:../CX3RDKOV5640.c **** #endif
1574:../CX3RDKOV5640.c ****     /* Device qualifier descriptor */
1575:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_DEVQUAL_DESCR, 0, (uint8_t *)esUVCUSBDeviceQualDscr);
 2526              		.loc 1 1575 0
 2527 018c 0200A0E3 		mov	r0, #2
 2528 0190 0010A0E3 		mov	r1, #0
 2529 0194 40269FE5 		ldr	r2, .L166+52
 2530 0198 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2531 019c 08000BE5 		str	r0, [fp, #-8]
1576:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2532              		.loc 1 1576 0
 2533 01a0 08301BE5 		ldr	r3, [fp, #-8]
 2534 01a4 000053E3 		cmp	r3, #0
 2535 01a8 0500000A 		beq	.L142
1577:../CX3RDKOV5640.c ****     {
1578:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_DEVQUAL_Dscr Err = 0x%x", status);
 2536              		.loc 1 1578 0
 2537 01ac 0400A0E3 		mov	r0, #4
 2538 01b0 28169FE5 		ldr	r1, .L166+56
 2539 01b4 08201BE5 		ldr	r2, [fp, #-8]
 2540 01b8 FEFFFFEB 		bl	CyU3PDebugPrint
1579:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2541              		.loc 1 1579 0
 2542 01bc 08001BE5 		ldr	r0, [fp, #-8]
 2543 01c0 FEFFFFEB 		bl	esUVCAppErrorHandler
 2544              	.L142:
1580:../CX3RDKOV5640.c ****     }
1581:../CX3RDKOV5640.c **** #ifdef VISDebug
1582:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_DEVQUAL_Dscr");
1583:../CX3RDKOV5640.c **** #endif
1584:../CX3RDKOV5640.c ****     /* Super speed configuration descriptor */
1585:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_CONFIG_DESCR, 0, (uint8_t *)esUVCUSBSSConfigDscr);
 2545              		.loc 1 1585 0
 2546 01c4 0600A0E3 		mov	r0, #6
 2547 01c8 0010A0E3 		mov	r1, #0
 2548 01cc 10269FE5 		ldr	r2, .L166+60
 2549 01d0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2550 01d4 08000BE5 		str	r0, [fp, #-8]
1586:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2551              		.loc 1 1586 0
 2552 01d8 08301BE5 		ldr	r3, [fp, #-8]
 2553 01dc 000053E3 		cmp	r3, #0
 2554 01e0 0500000A 		beq	.L143
1587:../CX3RDKOV5640.c ****     {
1588:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_SS_CFG_Dscr Err = 0x%x", status);
 2555              		.loc 1 1588 0
 2556 01e4 0400A0E3 		mov	r0, #4
 2557 01e8 F8159FE5 		ldr	r1, .L166+64
 2558 01ec 08201BE5 		ldr	r2, [fp, #-8]
 2559 01f0 FEFFFFEB 		bl	CyU3PDebugPrint
1589:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2560              		.loc 1 1589 0
 2561 01f4 08001BE5 		ldr	r0, [fp, #-8]
 2562 01f8 FEFFFFEB 		bl	esUVCAppErrorHandler
 2563              	.L143:
1590:../CX3RDKOV5640.c ****     }
1591:../CX3RDKOV5640.c **** #ifdef VISDebug
1592:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_SS_CFG_Dscr");
1593:../CX3RDKOV5640.c **** #endif
1594:../CX3RDKOV5640.c ****     /* High speed configuration descriptor */
1595:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_HS_CONFIG_DESCR, 0, (uint8_t *)esUVCUSBHSConfigDscr);
 2564              		.loc 1 1595 0
 2565 01fc 0400A0E3 		mov	r0, #4
 2566 0200 0010A0E3 		mov	r1, #0
 2567 0204 E0259FE5 		ldr	r2, .L166+68
 2568 0208 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2569 020c 08000BE5 		str	r0, [fp, #-8]
1596:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2570              		.loc 1 1596 0
 2571 0210 08301BE5 		ldr	r3, [fp, #-8]
 2572 0214 000053E3 		cmp	r3, #0
 2573 0218 0500000A 		beq	.L144
1597:../CX3RDKOV5640.c ****     {
1598:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_HS_CFG_Dscr Err = 0x%x", status);
 2574              		.loc 1 1598 0
 2575 021c 0400A0E3 		mov	r0, #4
 2576 0220 C8159FE5 		ldr	r1, .L166+72
 2577 0224 08201BE5 		ldr	r2, [fp, #-8]
 2578 0228 FEFFFFEB 		bl	CyU3PDebugPrint
1599:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2579              		.loc 1 1599 0
 2580 022c 08001BE5 		ldr	r0, [fp, #-8]
 2581 0230 FEFFFFEB 		bl	esUVCAppErrorHandler
 2582              	.L144:
1600:../CX3RDKOV5640.c ****     }
1601:../CX3RDKOV5640.c **** #ifdef VISDebug
1602:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_HS_CFG_Dscr");
1603:../CX3RDKOV5640.c **** #endif
1604:../CX3RDKOV5640.c ****     /* Full speed configuration descriptor */
1605:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_FS_CONFIG_DESCR, 0, (uint8_t *)esUVCUSBFSConfigDscr);
 2583              		.loc 1 1605 0
 2584 0234 0300A0E3 		mov	r0, #3
 2585 0238 0010A0E3 		mov	r1, #0
 2586 023c B0259FE5 		ldr	r2, .L166+76
 2587 0240 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2588 0244 08000BE5 		str	r0, [fp, #-8]
1606:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2589              		.loc 1 1606 0
 2590 0248 08301BE5 		ldr	r3, [fp, #-8]
 2591 024c 000053E3 		cmp	r3, #0
 2592 0250 0500000A 		beq	.L145
1607:../CX3RDKOV5640.c ****     {
1608:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_FS_CFG_Dscr Err = 0x%x", status);
 2593              		.loc 1 1608 0
 2594 0254 0400A0E3 		mov	r0, #4
 2595 0258 98159FE5 		ldr	r1, .L166+80
 2596 025c 08201BE5 		ldr	r2, [fp, #-8]
 2597 0260 FEFFFFEB 		bl	CyU3PDebugPrint
1609:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2598              		.loc 1 1609 0
 2599 0264 08001BE5 		ldr	r0, [fp, #-8]
 2600 0268 FEFFFFEB 		bl	esUVCAppErrorHandler
 2601              	.L145:
1610:../CX3RDKOV5640.c ****     }
1611:../CX3RDKOV5640.c **** #ifdef VISDebug
1612:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_FS_CFG_Dscr");
1613:../CX3RDKOV5640.c **** #endif
1614:../CX3RDKOV5640.c ****     /* String descriptor 0 */
1615:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)esUVCUSBStringLangIDDscr);
 2602              		.loc 1 1615 0
 2603 026c 0500A0E3 		mov	r0, #5
 2604 0270 0010A0E3 		mov	r1, #0
 2605 0274 80259FE5 		ldr	r2, .L166+84
 2606 0278 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2607 027c 08000BE5 		str	r0, [fp, #-8]
1616:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2608              		.loc 1 1616 0
 2609 0280 08301BE5 		ldr	r3, [fp, #-8]
 2610 0284 000053E3 		cmp	r3, #0
 2611 0288 0500000A 		beq	.L146
1617:../CX3RDKOV5640.c ****     {
1618:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_STRNG_Dscr0 Err = 0x%x", status);
 2612              		.loc 1 1618 0
 2613 028c 0400A0E3 		mov	r0, #4
 2614 0290 68159FE5 		ldr	r1, .L166+88
 2615 0294 08201BE5 		ldr	r2, [fp, #-8]
 2616 0298 FEFFFFEB 		bl	CyU3PDebugPrint
1619:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2617              		.loc 1 1619 0
 2618 029c 08001BE5 		ldr	r0, [fp, #-8]
 2619 02a0 FEFFFFEB 		bl	esUVCAppErrorHandler
 2620              	.L146:
1620:../CX3RDKOV5640.c ****     }
1621:../CX3RDKOV5640.c **** 
1622:../CX3RDKOV5640.c ****     /* String descriptor 1 */
1623:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)esUVCUSBManufactureDscr);
 2621              		.loc 1 1623 0
 2622 02a4 0500A0E3 		mov	r0, #5
 2623 02a8 0110A0E3 		mov	r1, #1
 2624 02ac 50259FE5 		ldr	r2, .L166+92
 2625 02b0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2626 02b4 08000BE5 		str	r0, [fp, #-8]
1624:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2627              		.loc 1 1624 0
 2628 02b8 08301BE5 		ldr	r3, [fp, #-8]
 2629 02bc 000053E3 		cmp	r3, #0
 2630 02c0 0500000A 		beq	.L147
1625:../CX3RDKOV5640.c ****     {
1626:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_STRNG_Dscr1 Err = 0x%x", status);
 2631              		.loc 1 1626 0
 2632 02c4 0400A0E3 		mov	r0, #4
 2633 02c8 38159FE5 		ldr	r1, .L166+96
 2634 02cc 08201BE5 		ldr	r2, [fp, #-8]
 2635 02d0 FEFFFFEB 		bl	CyU3PDebugPrint
1627:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2636              		.loc 1 1627 0
 2637 02d4 08001BE5 		ldr	r0, [fp, #-8]
 2638 02d8 FEFFFFEB 		bl	esUVCAppErrorHandler
 2639              	.L147:
1628:../CX3RDKOV5640.c ****     }
1629:../CX3RDKOV5640.c **** 
1630:../CX3RDKOV5640.c ****     /* String descriptor 2 */
1631:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)esUVCUSBProductDscr);
 2640              		.loc 1 1631 0
 2641 02dc 0500A0E3 		mov	r0, #5
 2642 02e0 0210A0E3 		mov	r1, #2
 2643 02e4 20259FE5 		ldr	r2, .L166+100
 2644 02e8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2645 02ec 08000BE5 		str	r0, [fp, #-8]
1632:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2646              		.loc 1 1632 0
 2647 02f0 08301BE5 		ldr	r3, [fp, #-8]
 2648 02f4 000053E3 		cmp	r3, #0
 2649 02f8 0500000A 		beq	.L148
1633:../CX3RDKOV5640.c ****     {
1634:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_STRNG_Dscr2 Err = 0x%x", status);
 2650              		.loc 1 1634 0
 2651 02fc 0400A0E3 		mov	r0, #4
 2652 0300 08159FE5 		ldr	r1, .L166+104
 2653 0304 08201BE5 		ldr	r2, [fp, #-8]
 2654 0308 FEFFFFEB 		bl	CyU3PDebugPrint
1635:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2655              		.loc 1 1635 0
 2656 030c 08001BE5 		ldr	r0, [fp, #-8]
 2657 0310 FEFFFFEB 		bl	esUVCAppErrorHandler
 2658              	.L148:
1636:../CX3RDKOV5640.c ****     }
1637:../CX3RDKOV5640.c ****     /* String descriptor 3 */
1638:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 3, (uint8_t *)esUVCUSBConfigSSDscr);
 2659              		.loc 1 1638 0
 2660 0314 0500A0E3 		mov	r0, #5
 2661 0318 0310A0E3 		mov	r1, #3
 2662 031c F0249FE5 		ldr	r2, .L166+108
 2663 0320 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2664 0324 08000BE5 		str	r0, [fp, #-8]
1639:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2665              		.loc 1 1639 0
 2666 0328 08301BE5 		ldr	r3, [fp, #-8]
 2667 032c 000053E3 		cmp	r3, #0
 2668 0330 0500000A 		beq	.L149
1640:../CX3RDKOV5640.c ****     {
1641:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_STRNG_Dscr3 Err = 0x%x", status);
 2669              		.loc 1 1641 0
 2670 0334 0400A0E3 		mov	r0, #4
 2671 0338 D8149FE5 		ldr	r1, .L166+112
 2672 033c 08201BE5 		ldr	r2, [fp, #-8]
 2673 0340 FEFFFFEB 		bl	CyU3PDebugPrint
1642:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2674              		.loc 1 1642 0
 2675 0344 08001BE5 		ldr	r0, [fp, #-8]
 2676 0348 FEFFFFEB 		bl	esUVCAppErrorHandler
 2677              	.L149:
1643:../CX3RDKOV5640.c ****     }
1644:../CX3RDKOV5640.c **** 
1645:../CX3RDKOV5640.c ****     /* String descriptor 4 */
1646:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 4, (uint8_t *)esUVCUSBConfigHSDscr);
 2678              		.loc 1 1646 0
 2679 034c 0500A0E3 		mov	r0, #5
 2680 0350 0410A0E3 		mov	r1, #4
 2681 0354 C0249FE5 		ldr	r2, .L166+116
 2682 0358 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2683 035c 08000BE5 		str	r0, [fp, #-8]
1647:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2684              		.loc 1 1647 0
 2685 0360 08301BE5 		ldr	r3, [fp, #-8]
 2686 0364 000053E3 		cmp	r3, #0
 2687 0368 0500000A 		beq	.L150
1648:../CX3RDKOV5640.c ****     {
1649:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_STRNG_Dscr4 Err = 0x%x", status);
 2688              		.loc 1 1649 0
 2689 036c 0400A0E3 		mov	r0, #4
 2690 0370 A8149FE5 		ldr	r1, .L166+120
 2691 0374 08201BE5 		ldr	r2, [fp, #-8]
 2692 0378 FEFFFFEB 		bl	CyU3PDebugPrint
1650:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2693              		.loc 1 1650 0
 2694 037c 08001BE5 		ldr	r0, [fp, #-8]
 2695 0380 FEFFFFEB 		bl	esUVCAppErrorHandler
 2696              	.L150:
1651:../CX3RDKOV5640.c ****     }
1652:../CX3RDKOV5640.c ****     /* String descriptor 2 */
1653:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 5, (uint8_t *)esUVCUSBConfigFSDscr);
 2697              		.loc 1 1653 0
 2698 0384 0500A0E3 		mov	r0, #5
 2699 0388 0510A0E3 		mov	r1, #5
 2700 038c 90249FE5 		ldr	r2, .L166+124
 2701 0390 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2702 0394 08000BE5 		str	r0, [fp, #-8]
1654:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2703              		.loc 1 1654 0
 2704 0398 08301BE5 		ldr	r3, [fp, #-8]
 2705 039c 000053E3 		cmp	r3, #0
 2706 03a0 0500000A 		beq	.L151
1655:../CX3RDKOV5640.c ****     {
1656:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_STRNG_Dscr5 Err = 0x%x", status);
 2707              		.loc 1 1656 0
 2708 03a4 0400A0E3 		mov	r0, #4
 2709 03a8 78149FE5 		ldr	r1, .L166+128
 2710 03ac 08201BE5 		ldr	r2, [fp, #-8]
 2711 03b0 FEFFFFEB 		bl	CyU3PDebugPrint
1657:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2712              		.loc 1 1657 0
 2713 03b4 08001BE5 		ldr	r0, [fp, #-8]
 2714 03b8 FEFFFFEB 		bl	esUVCAppErrorHandler
 2715              	.L151:
1658:../CX3RDKOV5640.c ****     }
1659:../CX3RDKOV5640.c **** 
1660:../CX3RDKOV5640.c ****     CyU3PUsbVBattEnable (CyTrue);
 2716              		.loc 1 1660 0
 2717 03bc 0100A0E3 		mov	r0, #1
 2718 03c0 FEFFFFEB 		bl	CyU3PUsbVBattEnable
1661:../CX3RDKOV5640.c ****     CyU3PUsbControlVBusDetect (CyFalse, CyTrue);
 2719              		.loc 1 1661 0
 2720 03c4 0000A0E3 		mov	r0, #0
 2721 03c8 0110A0E3 		mov	r1, #1
 2722 03cc FEFFFFEB 		bl	CyU3PUsbControlVBusDetect
1662:../CX3RDKOV5640.c **** 
1663:../CX3RDKOV5640.c ****     //TODO Change this function with the "Sensor specific" function to Write the Base I2C settings 
1664:../CX3RDKOV5640.c ****     /* Setup Image Sensor */
1665:../CX3RDKOV5640.c **** 	//esOV5640_Base_Config();
1666:../CX3RDKOV5640.c **** 	 //TODO Change this function with the "Sensor specific" function to Write the Base I2C settings fo
1667:../CX3RDKOV5640.c **** 	//esOV5640_Auto_Focus_Config();
1668:../CX3RDKOV5640.c **** 	//TODO Change this function with "Sensor Specific" PowerDown function to PowerDown the sensor
1669:../CX3RDKOV5640.c **** 	//esCamera_Power_Down();
1670:../CX3RDKOV5640.c **** 
1671:../CX3RDKOV5640.c ****     /* Connect the USB pins and enable super speed operation */
1672:../CX3RDKOV5640.c ****     status = CyU3PConnectState(CyTrue, CyTrue);
 2723              		.loc 1 1672 0
 2724 03d0 0100A0E3 		mov	r0, #1
 2725 03d4 0110A0E3 		mov	r1, #1
 2726 03d8 FEFFFFEB 		bl	CyU3PConnectState
 2727 03dc 08000BE5 		str	r0, [fp, #-8]
1673:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2728              		.loc 1 1673 0
 2729 03e0 08301BE5 		ldr	r3, [fp, #-8]
 2730 03e4 000053E3 		cmp	r3, #0
 2731 03e8 0500000A 		beq	.L152
1674:../CX3RDKOV5640.c ****     {
1675:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:ConnectState Err = 0x%x", status);
 2732              		.loc 1 1675 0
 2733 03ec 0400A0E3 		mov	r0, #4
 2734 03f0 34149FE5 		ldr	r1, .L166+132
 2735 03f4 08201BE5 		ldr	r2, [fp, #-8]
 2736 03f8 FEFFFFEB 		bl	CyU3PDebugPrint
1676:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2737              		.loc 1 1676 0
 2738 03fc 08001BE5 		ldr	r0, [fp, #-8]
 2739 0400 FEFFFFEB 		bl	esUVCAppErrorHandler
 2740              	.L152:
1677:../CX3RDKOV5640.c ****     }
1678:../CX3RDKOV5640.c **** #ifdef VISDebug
1679:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "n\rAppInit:ConnectState");
1680:../CX3RDKOV5640.c **** #endif
1681:../CX3RDKOV5640.c ****     /* Since the status interrupt endpoint is not used in this application,
1682:../CX3RDKOV5640.c ****      * just enable the EP in the beginning. */
1683:../CX3RDKOV5640.c ****     /* Control status interrupt endpoint configuration */
1684:../CX3RDKOV5640.c ****     endPointConfig.enable = 1;
 2741              		.loc 1 1684 0
 2742 0404 0130A0E3 		mov	r3, #1
 2743 0408 14300BE5 		str	r3, [fp, #-20]
1685:../CX3RDKOV5640.c ****     endPointConfig.epType = CY_U3P_USB_EP_INTR;
 2744              		.loc 1 1685 0
 2745 040c 0330A0E3 		mov	r3, #3
 2746 0410 10304BE5 		strb	r3, [fp, #-16]
1686:../CX3RDKOV5640.c ****     endPointConfig.pcktSize = 64;
 2747              		.loc 1 1686 0
 2748 0414 4030A0E3 		mov	r3, #64
 2749 0418 BC304BE1 		strh	r3, [fp, #-12]	@ movhi
1687:../CX3RDKOV5640.c ****     endPointConfig.isoPkts  = 1;
 2750              		.loc 1 1687 0
 2751 041c 0130A0E3 		mov	r3, #1
 2752 0420 09304BE5 		strb	r3, [fp, #-9]
1688:../CX3RDKOV5640.c ****     endPointConfig.burstLen = 1;
 2753              		.loc 1 1688 0
 2754 0424 0130A0E3 		mov	r3, #1
 2755 0428 0A304BE5 		strb	r3, [fp, #-10]
1689:../CX3RDKOV5640.c **** 
1690:../CX3RDKOV5640.c ****     status = CyU3PSetEpConfig(ES_UVC_EP_CONTROL_STATUS, &endPointConfig);
 2756              		.loc 1 1690 0
 2757 042c 14304BE2 		sub	r3, fp, #20
 2758 0430 8200A0E3 		mov	r0, #130
 2759 0434 0310A0E1 		mov	r1, r3
 2760 0438 FEFFFFEB 		bl	CyU3PSetEpConfig
 2761 043c 08000BE5 		str	r0, [fp, #-8]
1691:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2762              		.loc 1 1691 0
 2763 0440 08301BE5 		ldr	r3, [fp, #-8]
 2764 0444 000053E3 		cmp	r3, #0
 2765 0448 0500000A 		beq	.L153
1692:../CX3RDKOV5640.c ****     {
1693:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:CyU3PSetEpConfig CtrlEp Err = 0x%x", status);
 2766              		.loc 1 1693 0
 2767 044c 0400A0E3 		mov	r0, #4
 2768 0450 D8139FE5 		ldr	r1, .L166+136
 2769 0454 08201BE5 		ldr	r2, [fp, #-8]
 2770 0458 FEFFFFEB 		bl	CyU3PDebugPrint
1694:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2771              		.loc 1 1694 0
 2772 045c 08001BE5 		ldr	r0, [fp, #-8]
 2773 0460 FEFFFFEB 		bl	esUVCAppErrorHandler
 2774              	.L153:
1695:../CX3RDKOV5640.c ****     }
1696:../CX3RDKOV5640.c **** 
1697:../CX3RDKOV5640.c ****     CyU3PUsbFlushEp(ES_UVC_EP_CONTROL_STATUS);
 2775              		.loc 1 1697 0
 2776 0464 8200A0E3 		mov	r0, #130
 2777 0468 FEFFFFEB 		bl	CyU3PUsbFlushEp
1698:../CX3RDKOV5640.c **** 
1699:../CX3RDKOV5640.c ****     /* Setup the Bulk endpoint used for Video Streaming */
1700:../CX3RDKOV5640.c ****     endPointConfig.enable = CyTrue;
 2778              		.loc 1 1700 0
 2779 046c 0130A0E3 		mov	r3, #1
 2780 0470 14300BE5 		str	r3, [fp, #-20]
1701:../CX3RDKOV5640.c ****     endPointConfig.epType = CY_U3P_USB_EP_BULK;
 2781              		.loc 1 1701 0
 2782 0474 0230A0E3 		mov	r3, #2
 2783 0478 10304BE5 		strb	r3, [fp, #-16]
1702:../CX3RDKOV5640.c **** 
1703:../CX3RDKOV5640.c ****     endPointConfig.isoPkts  = 0;
 2784              		.loc 1 1703 0
 2785 047c 0030A0E3 		mov	r3, #0
 2786 0480 09304BE5 		strb	r3, [fp, #-9]
1704:../CX3RDKOV5640.c ****     endPointConfig.streams = 0;
 2787              		.loc 1 1704 0
 2788 0484 0030A0E3 		mov	r3, #0
 2789 0488 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
1705:../CX3RDKOV5640.c **** 
1706:../CX3RDKOV5640.c ****     CyU3PThreadSleep(1000);
 2790              		.loc 1 1706 0
 2791 048c FA0FA0E3 		mov	r0, #1000
 2792 0490 FEFFFFEB 		bl	_tx_thread_sleep
1707:../CX3RDKOV5640.c **** 
1708:../CX3RDKOV5640.c ****     switch(CyU3PUsbGetSpeed())
 2793              		.loc 1 1708 0
 2794 0494 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 2795 0498 0030A0E1 		mov	r3, r0
 2796 049c 010053E3 		cmp	r3, #1
 2797 04a0 0F00000A 		beq	.L155
 2798 04a4 020053E3 		cmp	r3, #2
 2799 04a8 1200001A 		bne	.L165
1709:../CX3RDKOV5640.c ****     {
1710:../CX3RDKOV5640.c ****         case CY_U3P_HIGH_SPEED:
1711:../CX3RDKOV5640.c ****             endPointConfig.pcktSize = 0x200;
 2800              		.loc 1 1711 0
 2801 04ac 023CA0E3 		mov	r3, #512
 2802 04b0 BC304BE1 		strh	r3, [fp, #-12]	@ movhi
1712:../CX3RDKOV5640.c ****             endPointConfig.burstLen = 1;
 2803              		.loc 1 1712 0
 2804 04b4 0130A0E3 		mov	r3, #1
 2805 04b8 0A304BE5 		strb	r3, [fp, #-10]
1713:../CX3RDKOV5640.c ****             ES_UVC_STREAM_BUF_SIZE 	= ES_UVC_HS_STREAM_BUF_SIZE;
 2806              		.loc 1 1713 0
 2807 04bc 70339FE5 		ldr	r3, .L166+140
 2808 04c0 032BA0E3 		mov	r2, #3072
 2809 04c4 B020C3E1 		strh	r2, [r3]	@ movhi
1714:../CX3RDKOV5640.c ****             ES_UVC_DATA_BUF_SIZE 	= ES_UVC_HS_DATA_BUF_SIZE;
 2810              		.loc 1 1714 0
 2811 04c8 68339FE5 		ldr	r3, .L166+144
 2812 04cc BF2EA0E3 		mov	r2, #3056
 2813 04d0 B020C3E1 		strh	r2, [r3]	@ movhi
1715:../CX3RDKOV5640.c ****             ES_UVC_STREAM_BUF_COUNT	= ES_UVC_HS_STREAM_BUF_COUNT;
 2814              		.loc 1 1715 0
 2815 04d4 60339FE5 		ldr	r3, .L166+148
 2816 04d8 0820A0E3 		mov	r2, #8
 2817 04dc 0020C3E5 		strb	r2, [r3]
1716:../CX3RDKOV5640.c ****             break;
 2818              		.loc 1 1716 0
 2819 04e0 120000EA 		b	.L157
 2820              	.L155:
1717:../CX3RDKOV5640.c **** 
1718:../CX3RDKOV5640.c ****         case CY_U3P_FULL_SPEED:
1719:../CX3RDKOV5640.c ****             endPointConfig.pcktSize = 0x40;
 2821              		.loc 1 1719 0
 2822 04e4 4030A0E3 		mov	r3, #64
 2823 04e8 BC304BE1 		strh	r3, [fp, #-12]	@ movhi
1720:../CX3RDKOV5640.c ****             endPointConfig.burstLen = 1;
 2824              		.loc 1 1720 0
 2825 04ec 0130A0E3 		mov	r3, #1
 2826 04f0 0A304BE5 		strb	r3, [fp, #-10]
1721:../CX3RDKOV5640.c ****             break;
 2827              		.loc 1 1721 0
 2828 04f4 0D0000EA 		b	.L157
 2829              	.L165:
1722:../CX3RDKOV5640.c **** 
1723:../CX3RDKOV5640.c ****         case CY_U3P_SUPER_SPEED:
1724:../CX3RDKOV5640.c ****         default:
1725:../CX3RDKOV5640.c ****             endPointConfig.pcktSize = ES_UVC_EP_BULK_VIDEO_PKT_SIZE;
 2830              		.loc 1 1725 0
 2831 04f8 013BA0E3 		mov	r3, #1024
 2832 04fc BC304BE1 		strh	r3, [fp, #-12]	@ movhi
1726:../CX3RDKOV5640.c ****             endPointConfig.burstLen = 16;
 2833              		.loc 1 1726 0
 2834 0500 1030A0E3 		mov	r3, #16
 2835 0504 0A304BE5 		strb	r3, [fp, #-10]
1727:../CX3RDKOV5640.c ****             ES_UVC_STREAM_BUF_SIZE 	= ES_UVC_SS_STREAM_BUF_SIZE;
 2836              		.loc 1 1727 0
 2837 0508 24339FE5 		ldr	r3, .L166+140
 2838 050c 062AA0E3 		mov	r2, #24576
 2839 0510 B020C3E1 		strh	r2, [r3]	@ movhi
1728:../CX3RDKOV5640.c ****             ES_UVC_DATA_BUF_SIZE 	= ES_UVC_SS_DATA_BUF_SIZE;
 2840              		.loc 1 1728 0
 2841 0514 1C339FE5 		ldr	r3, .L166+144
 2842 0518 20239FE5 		ldr	r2, .L166+152
 2843 051c B020C3E1 		strh	r2, [r3]	@ movhi
1729:../CX3RDKOV5640.c ****             ES_UVC_STREAM_BUF_COUNT	= ES_UVC_SS_STREAM_BUF_COUNT;
 2844              		.loc 1 1729 0
 2845 0520 14339FE5 		ldr	r3, .L166+148
 2846 0524 0420A0E3 		mov	r2, #4
 2847 0528 0020C3E5 		strb	r2, [r3]
1730:../CX3RDKOV5640.c ****             break;
 2848              		.loc 1 1730 0
 2849 052c 0000A0E1 		mov	r0, r0	@ nop
 2850              	.L157:
1731:../CX3RDKOV5640.c ****     }
1732:../CX3RDKOV5640.c **** 
1733:../CX3RDKOV5640.c ****     status = CyU3PSetEpConfig(ES_UVC_EP_BULK_VIDEO, &endPointConfig);
 2851              		.loc 1 1733 0
 2852 0530 14304BE2 		sub	r3, fp, #20
 2853 0534 8300A0E3 		mov	r0, #131
 2854 0538 0310A0E1 		mov	r1, r3
 2855 053c FEFFFFEB 		bl	CyU3PSetEpConfig
 2856 0540 08000BE5 		str	r0, [fp, #-8]
1734:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2857              		.loc 1 1734 0
 2858 0544 08301BE5 		ldr	r3, [fp, #-8]
 2859 0548 000053E3 		cmp	r3, #0
 2860 054c 0500000A 		beq	.L158
1735:../CX3RDKOV5640.c ****     {
1736:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:CyU3PSetEpConfig BulkEp Err = 0x%x", status);
 2861              		.loc 1 1736 0
 2862 0550 0400A0E3 		mov	r0, #4
 2863 0554 E8129FE5 		ldr	r1, .L166+156
 2864 0558 08201BE5 		ldr	r2, [fp, #-8]
 2865 055c FEFFFFEB 		bl	CyU3PDebugPrint
1737:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2866              		.loc 1 1737 0
 2867 0560 08001BE5 		ldr	r0, [fp, #-8]
 2868 0564 FEFFFFEB 		bl	esUVCAppErrorHandler
 2869              	.L158:
1738:../CX3RDKOV5640.c ****     }
1739:../CX3RDKOV5640.c **** #ifdef VISDebug
1740:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:CyU3PSetEpConfig BulkEp");
1741:../CX3RDKOV5640.c **** #endif
1742:../CX3RDKOV5640.c ****     CyU3PUsbEPSetBurstMode (ES_UVC_EP_BULK_VIDEO, CyTrue);
 2870              		.loc 1 1742 0
 2871 0568 8300A0E3 		mov	r0, #131
 2872 056c 0110A0E3 		mov	r1, #1
 2873 0570 FEFFFFEB 		bl	CyU3PUsbEPSetBurstMode
1743:../CX3RDKOV5640.c **** 
1744:../CX3RDKOV5640.c ****     /* Flush the endpoint memory */
1745:../CX3RDKOV5640.c ****     CyU3PUsbFlushEp(ES_UVC_EP_BULK_VIDEO);
 2874              		.loc 1 1745 0
 2875 0574 8300A0E3 		mov	r0, #131
 2876 0578 FEFFFFEB 		bl	CyU3PUsbFlushEp
1746:../CX3RDKOV5640.c **** 
1747:../CX3RDKOV5640.c ****     /* Create a DMA Manual OUT channel for streaming data */
1748:../CX3RDKOV5640.c ****     /* Video streaming Channel is not active till a stream request is received */
1749:../CX3RDKOV5640.c ****     dmaCfg.size                 = ES_UVC_STREAM_BUF_SIZE;
 2877              		.loc 1 1749 0
 2878 057c B0329FE5 		ldr	r3, .L166+140
 2879 0580 B030D3E1 		ldrh	r3, [r3]
 2880 0584 BC334BE1 		strh	r3, [fp, #-60]	@ movhi
1750:../CX3RDKOV5640.c ****     dmaCfg.count                = ES_UVC_STREAM_BUF_COUNT;
 2881              		.loc 1 1750 0
 2882 0588 AC329FE5 		ldr	r3, .L166+148
 2883 058c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2884 0590 BA334BE1 		strh	r3, [fp, #-58]	@ movhi
1751:../CX3RDKOV5640.c ****     dmaCfg.validSckCount        = 2;
 2885              		.loc 1 1751 0
 2886 0594 0230A0E3 		mov	r3, #2
 2887 0598 B8334BE1 		strh	r3, [fp, #-56]	@ movhi
1752:../CX3RDKOV5640.c **** 
1753:../CX3RDKOV5640.c ****     dmaCfg.prodSckId[0]         = ES_UVC_PRODUCER_PPORT_SOCKET_0;
 2888              		.loc 1 1753 0
 2889 059c 013CA0E3 		mov	r3, #256
 2890 05a0 B6334BE1 		strh	r3, [fp, #-54]	@ movhi
1754:../CX3RDKOV5640.c ****     dmaCfg.prodSckId[1]         = ES_UVC_PRODUCER_PPORT_SOCKET_1;
 2891              		.loc 1 1754 0
 2892 05a4 9C329FE5 		ldr	r3, .L166+160
 2893 05a8 B4334BE1 		strh	r3, [fp, #-52]	@ movhi
1755:../CX3RDKOV5640.c **** 
1756:../CX3RDKOV5640.c ****     dmaCfg.consSckId[0]         = ES_UVC_EP_VIDEO_CONS_SOCKET;
 2894              		.loc 1 1756 0
 2895 05ac 98329FE5 		ldr	r3, .L166+164
 2896 05b0 BE324BE1 		strh	r3, [fp, #-46]	@ movhi
1757:../CX3RDKOV5640.c ****     dmaCfg.dmaMode              = CY_U3P_DMA_MODE_BYTE;
 2897              		.loc 1 1757 0
 2898 05b4 0030A0E3 		mov	r3, #0
 2899 05b8 1E304BE5 		strb	r3, [fp, #-30]
1758:../CX3RDKOV5640.c ****     dmaCfg.notification         = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 2900              		.loc 1 1758 0
 2901 05bc 1830A0E3 		mov	r3, #24
 2902 05c0 1C300BE5 		str	r3, [fp, #-28]
1759:../CX3RDKOV5640.c ****     dmaCfg.cb                   = esUVCUvcAppDmaCallback;
 2903              		.loc 1 1759 0
 2904 05c4 84329FE5 		ldr	r3, .L166+168
 2905 05c8 18300BE5 		str	r3, [fp, #-24]
1760:../CX3RDKOV5640.c ****     dmaCfg.prodHeader           = ES_UVC_PROD_HEADER;
 2906              		.loc 1 1760 0
 2907 05cc 0C30A0E3 		mov	r3, #12
 2908 05d0 B4324BE1 		strh	r3, [fp, #-36]	@ movhi
1761:../CX3RDKOV5640.c ****     dmaCfg.prodFooter           = ES_UVC_PROD_FOOTER;
 2909              		.loc 1 1761 0
 2910 05d4 0430A0E3 		mov	r3, #4
 2911 05d8 B2324BE1 		strh	r3, [fp, #-34]	@ movhi
1762:../CX3RDKOV5640.c ****     dmaCfg.consHeader           = 0;
 2912              		.loc 1 1762 0
 2913 05dc 0030A0E3 		mov	r3, #0
 2914 05e0 B0324BE1 		strh	r3, [fp, #-32]	@ movhi
1763:../CX3RDKOV5640.c ****     dmaCfg.prodAvailCount       = 0;
 2915              		.loc 1 1763 0
 2916 05e4 0030A0E3 		mov	r3, #0
 2917 05e8 B6324BE1 		strh	r3, [fp, #-38]	@ movhi
1764:../CX3RDKOV5640.c **** 
1765:../CX3RDKOV5640.c ****     status = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO_ONE ,
 2918              		.loc 1 1765 0
 2919 05ec 3C304BE2 		sub	r3, fp, #60
 2920 05f0 5C029FE5 		ldr	r0, .L166+172
 2921 05f4 0710A0E3 		mov	r1, #7
 2922 05f8 0320A0E1 		mov	r2, r3
 2923 05fc FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 2924 0600 08000BE5 		str	r0, [fp, #-8]
1766:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2925              		.loc 1 1766 0
 2926 0604 08301BE5 		ldr	r3, [fp, #-8]
 2927 0608 000053E3 		cmp	r3, #0
 2928 060c 0300000A 		beq	.L159
1767:../CX3RDKOV5640.c ****     {
1768:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:DmaMultiChannelCreate Err = 0x%x", status);
 2929              		.loc 1 1768 0
 2930 0610 0400A0E3 		mov	r0, #4
 2931 0614 3C129FE5 		ldr	r1, .L166+176
 2932 0618 08201BE5 		ldr	r2, [fp, #-8]
 2933 061c FEFFFFEB 		bl	CyU3PDebugPrint
 2934              	.L159:
1769:../CX3RDKOV5640.c ****     }
1770:../CX3RDKOV5640.c ****     CyU3PThreadSleep(100);
 2935              		.loc 1 1770 0
 2936 0620 6400A0E3 		mov	r0, #100
 2937 0624 FEFFFFEB 		bl	_tx_thread_sleep
1771:../CX3RDKOV5640.c **** 
1772:../CX3RDKOV5640.c ****     /* Reset the channel: Set to DSCR chain starting point in PORD/CONS SCKT; set
1773:../CX3RDKOV5640.c ****        DSCR_SIZE field in DSCR memory */
1774:../CX3RDKOV5640.c ****     status = CyU3PDmaMultiChannelReset(&glChHandleUVCStream);  //-TODO the glChHandleUVCStream
 2938              		.loc 1 1774 0
 2939 0628 24029FE5 		ldr	r0, .L166+172
 2940 062c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 2941 0630 08000BE5 		str	r0, [fp, #-8]
1775:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2942              		.loc 1 1775 0
 2943 0634 08301BE5 		ldr	r3, [fp, #-8]
 2944 0638 000053E3 		cmp	r3, #0
 2945 063c 0300000A 		beq	.L160
1776:../CX3RDKOV5640.c ****     {
1777:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4,"\n\rAppInit:MultiChannelReset Err = 0x%x", status);
 2946              		.loc 1 1777 0
 2947 0640 0400A0E3 		mov	r0, #4
 2948 0644 10129FE5 		ldr	r1, .L166+180
 2949 0648 08201BE5 		ldr	r2, [fp, #-8]
 2950 064c FEFFFFEB 		bl	CyU3PDebugPrint
 2951              	.L160:
1778:../CX3RDKOV5640.c ****     }
1779:../CX3RDKOV5640.c **** #ifdef VISDebug
1780:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:MultiChannelReset");
1781:../CX3RDKOV5640.c **** #endif
1782:../CX3RDKOV5640.c ****     /* Configure the Fixed Function GPIF on the CX3 to use a 16 bit bus, and
1783:../CX3RDKOV5640.c ****      * a DMA Buffer of size CX3_UVC_DATA_BUF_SIZE
1784:../CX3RDKOV5640.c ****      */
1785:../CX3RDKOV5640.c ****     status = CyU3PMipicsiGpifLoad(CY_U3P_MIPICSI_BUS_16, ES_UVC_DATA_BUF_SIZE);
 2952              		.loc 1 1785 0
 2953 0650 E0319FE5 		ldr	r3, .L166+144
 2954 0654 B030D3E1 		ldrh	r3, [r3]
 2955 0658 0100A0E3 		mov	r0, #1
 2956 065c 0310A0E1 		mov	r1, r3
 2957 0660 FEFFFFEB 		bl	CyU3PMipicsiGpifLoad
 2958 0664 08000BE5 		str	r0, [fp, #-8]
1786:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2959              		.loc 1 1786 0
 2960 0668 08301BE5 		ldr	r3, [fp, #-8]
 2961 066c 000053E3 		cmp	r3, #0
 2962 0670 0500000A 		beq	.L161
1787:../CX3RDKOV5640.c ****     {
1788:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:MipicsiGpifLoad Err = 0x%x", status);
 2963              		.loc 1 1788 0
 2964 0674 0400A0E3 		mov	r0, #4
 2965 0678 E0119FE5 		ldr	r1, .L166+184
 2966 067c 08201BE5 		ldr	r2, [fp, #-8]
 2967 0680 FEFFFFEB 		bl	CyU3PDebugPrint
1789:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2968              		.loc 1 1789 0
 2969 0684 08001BE5 		ldr	r0, [fp, #-8]
 2970 0688 FEFFFFEB 		bl	esUVCAppErrorHandler
 2971              	.L161:
1790:../CX3RDKOV5640.c ****     }
1791:../CX3RDKOV5640.c ****     CyU3PThreadSleep(50);
 2972              		.loc 1 1791 0
 2973 068c 3200A0E3 		mov	r0, #50
 2974 0690 FEFFFFEB 		bl	_tx_thread_sleep
1792:../CX3RDKOV5640.c **** #ifdef VISDebug
1793:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:MipicsiGpifLoad");
1794:../CX3RDKOV5640.c **** #endif
1795:../CX3RDKOV5640.c ****     CyU3PGpifRegisterCallback(esUVCGpifCB);
 2975              		.loc 1 1795 0
 2976 0694 C8019FE5 		ldr	r0, .L166+188
 2977 0698 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
1796:../CX3RDKOV5640.c ****     CyU3PThreadSleep(50);
 2978              		.loc 1 1796 0
 2979 069c 3200A0E3 		mov	r0, #50
 2980 06a0 FEFFFFEB 		bl	_tx_thread_sleep
1797:../CX3RDKOV5640.c **** 
1798:../CX3RDKOV5640.c ****     /* Start the state machine. */
1799:../CX3RDKOV5640.c ****     status = CyU3PGpifSMStart (CX3_START_SCK0, ALPHA_CX3_START_SCK0);
 2981              		.loc 1 1799 0
 2982 06a4 0000A0E3 		mov	r0, #0
 2983 06a8 0010A0E3 		mov	r1, #0
 2984 06ac FEFFFFEB 		bl	CyU3PGpifSMStart
 2985 06b0 08000BE5 		str	r0, [fp, #-8]
1800:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2986              		.loc 1 1800 0
 2987 06b4 08301BE5 		ldr	r3, [fp, #-8]
 2988 06b8 000053E3 		cmp	r3, #0
 2989 06bc 0500000A 		beq	.L162
1801:../CX3RDKOV5640.c ****     {
1802:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:GpifSMStart Err = 0x%x", status);
 2990              		.loc 1 1802 0
 2991 06c0 0400A0E3 		mov	r0, #4
 2992 06c4 9C119FE5 		ldr	r1, .L166+192
 2993 06c8 08201BE5 		ldr	r2, [fp, #-8]
 2994 06cc FEFFFFEB 		bl	CyU3PDebugPrint
1803:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2995              		.loc 1 1803 0
 2996 06d0 08001BE5 		ldr	r0, [fp, #-8]
 2997 06d4 FEFFFFEB 		bl	esUVCAppErrorHandler
 2998              	.L162:
1804:../CX3RDKOV5640.c ****     }
1805:../CX3RDKOV5640.c ****     CyU3PThreadSleep(50);
 2999              		.loc 1 1805 0
 3000 06d8 3200A0E3 		mov	r0, #50
 3001 06dc FEFFFFEB 		bl	_tx_thread_sleep
1806:../CX3RDKOV5640.c **** #ifdef VISDebug
1807:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:GpifSMStart");
1808:../CX3RDKOV5640.c **** #endif
1809:../CX3RDKOV5640.c ****     /* Pause the GPIF*/
1810:../CX3RDKOV5640.c ****     CyU3PGpifSMControl(CyTrue);
 3002              		.loc 1 1810 0
 3003 06e0 0100A0E3 		mov	r0, #1
 3004 06e4 FEFFFFEB 		bl	CyU3PGpifSMControl
1811:../CX3RDKOV5640.c **** 
1812:../CX3RDKOV5640.c ****     /* Initialize the MIPI block */
1813:../CX3RDKOV5640.c ****     status =  CyU3PMipicsiInit();
 3005              		.loc 1 1813 0
 3006 06e8 FEFFFFEB 		bl	CyU3PMipicsiInit
 3007 06ec 08000BE5 		str	r0, [fp, #-8]
1814:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3008              		.loc 1 1814 0
 3009 06f0 08301BE5 		ldr	r3, [fp, #-8]
 3010 06f4 000053E3 		cmp	r3, #0
 3011 06f8 0500000A 		beq	.L163
1815:../CX3RDKOV5640.c ****     {
1816:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:MipicsiInit Err = 0x%x", status);
 3012              		.loc 1 1816 0
 3013 06fc 0400A0E3 		mov	r0, #4
 3014 0700 64119FE5 		ldr	r1, .L166+196
 3015 0704 08201BE5 		ldr	r2, [fp, #-8]
 3016 0708 FEFFFFEB 		bl	CyU3PDebugPrint
1817:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 3017              		.loc 1 1817 0
 3018 070c 08001BE5 		ldr	r0, [fp, #-8]
 3019 0710 FEFFFFEB 		bl	esUVCAppErrorHandler
 3020              	.L163:
1818:../CX3RDKOV5640.c ****     }
1819:../CX3RDKOV5640.c **** #ifdef VISDebug
1820:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:MipicsiInit");
1821:../CX3RDKOV5640.c **** #endif
1822:../CX3RDKOV5640.c ****     status = CyU3PMipicsiSetIntfParams(&cfgUvcVgaNoMclk, CyTrue/*CyFalse*/);
 3021              		.loc 1 1822 0
 3022 0714 54019FE5 		ldr	r0, .L166+200
 3023 0718 0110A0E3 		mov	r1, #1
 3024 071c FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 3025 0720 08000BE5 		str	r0, [fp, #-8]
1823:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3026              		.loc 1 1823 0
 3027 0724 08301BE5 		ldr	r3, [fp, #-8]
 3028 0728 000053E3 		cmp	r3, #0
 3029 072c 0500000A 		beq	.L164
1824:../CX3RDKOV5640.c ****     {
1825:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:MipicsiSetIntfParams Err = 0x%x",status);
 3030              		.loc 1 1825 0
 3031 0730 0400A0E3 		mov	r0, #4
 3032 0734 38119FE5 		ldr	r1, .L166+204
 3033 0738 08201BE5 		ldr	r2, [fp, #-8]
 3034 073c FEFFFFEB 		bl	CyU3PDebugPrint
1826:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 3035              		.loc 1 1826 0
 3036 0740 08001BE5 		ldr	r0, [fp, #-8]
 3037 0744 FEFFFFEB 		bl	esUVCAppErrorHandler
 3038              	.L164:
1827:../CX3RDKOV5640.c ****     }
1828:../CX3RDKOV5640.c **** #ifdef VISDebug
1829:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:MipicsiSetIntfParams");
1830:../CX3RDKOV5640.c **** #endif
1831:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
1832:../CX3RDKOV5640.c ****     CyU3PTimerCreate (&UvcTimer, UvcAppProgressTimer, 0x00, TIMER_PERIOD, 0, CYU3P_NO_ACTIVATE);
 3039              		.loc 1 1832 0
 3040 0748 7D3FA0E3 		mov	r3, #500
 3041 074c 00308DE5 		str	r3, [sp]
 3042 0750 0030A0E3 		mov	r3, #0
 3043 0754 04308DE5 		str	r3, [sp, #4]
 3044 0758 0030A0E3 		mov	r3, #0
 3045 075c 08308DE5 		str	r3, [sp, #8]
 3046 0760 2C30A0E3 		mov	r3, #44
 3047 0764 0C308DE5 		str	r3, [sp, #12]
 3048 0768 08019FE5 		ldr	r0, .L166+208
 3049 076c 0010A0E3 		mov	r1, #0
 3050 0770 04219FE5 		ldr	r2, .L166+212
 3051 0774 0030A0E3 		mov	r3, #0
 3052 0778 FEFFFFEB 		bl	_txe_timer_create
1833:../CX3RDKOV5640.c **** #endif
1834:../CX3RDKOV5640.c **** 
1835:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rFirmware Version: %d.%d.%d.%d",MajorVersion,MinorVersion,SubVersion,Su
 3053              		.loc 1 1835 0
 3054 077c 8530A0E3 		mov	r3, #133
 3055 0780 00308DE5 		str	r3, [sp]
 3056 0784 F4309FE5 		ldr	r3, .L166+216
 3057 0788 04308DE5 		str	r3, [sp, #4]
 3058 078c 0400A0E3 		mov	r0, #4
 3059 0790 EC109FE5 		ldr	r1, .L166+220
 3060 0794 0120A0E3 		mov	r2, #1
 3061 0798 0330A0E3 		mov	r3, #3
 3062 079c FEFFFFEB 		bl	CyU3PDebugPrint
1836:../CX3RDKOV5640.c **** }
 3063              		.loc 1 1836 0
 3064 07a0 04D04BE2 		sub	sp, fp, #4
 3065              		@ sp needed
 3066 07a4 0088BDE8 		ldmfd	sp!, {fp, pc}
 3067              	.L167:
 3068              		.align	2
 3069              	.L166:
 3070 07a8 E4020000 		.word	.LC18
 3071 07ac 04030000 		.word	.LC19
 3072 07b0 24030000 		.word	.LC20
 3073 07b4 44030000 		.word	.LC21
 3074 07b8 00000000 		.word	esUVCUvcApplnUSBSetupCB
 3075 07bc 00000000 		.word	esUVCUvcApplnUSBEventCB
 3076 07c0 00000000 		.word	esUVCApplnLPMRqtCB
 3077 07c4 00000000 		.word	esUVCUSB30DeviceDscr
 3078 07c8 64030000 		.word	.LC22
 3079 07cc 00000000 		.word	esUVCUSB20DeviceDscr
 3080 07d0 8C030000 		.word	.LC23
 3081 07d4 00000000 		.word	esUVCUSBBOSDscr
 3082 07d8 B4030000 		.word	.LC24
 3083 07dc 00000000 		.word	esUVCUSBDeviceQualDscr
 3084 07e0 D8030000 		.word	.LC25
 3085 07e4 00000000 		.word	esUVCUSBSSConfigDscr
 3086 07e8 00040000 		.word	.LC26
 3087 07ec 00000000 		.word	esUVCUSBHSConfigDscr
 3088 07f0 28040000 		.word	.LC27
 3089 07f4 00000000 		.word	esUVCUSBFSConfigDscr
 3090 07f8 50040000 		.word	.LC28
 3091 07fc 00000000 		.word	esUVCUSBStringLangIDDscr
 3092 0800 78040000 		.word	.LC29
 3093 0804 00000000 		.word	esUVCUSBManufactureDscr
 3094 0808 A0040000 		.word	.LC30
 3095 080c 00000000 		.word	esUVCUSBProductDscr
 3096 0810 C8040000 		.word	.LC31
 3097 0814 00000000 		.word	esUVCUSBConfigSSDscr
 3098 0818 F0040000 		.word	.LC32
 3099 081c 00000000 		.word	esUVCUSBConfigHSDscr
 3100 0820 18050000 		.word	.LC33
 3101 0824 00000000 		.word	esUVCUSBConfigFSDscr
 3102 0828 40050000 		.word	.LC34
 3103 082c 68050000 		.word	.LC35
 3104 0830 8C050000 		.word	.LC36
 3105 0834 00000000 		.word	ES_UVC_STREAM_BUF_SIZE
 3106 0838 00000000 		.word	ES_UVC_DATA_BUF_SIZE
 3107 083c 00000000 		.word	ES_UVC_STREAM_BUF_COUNT
 3108 0840 F05F0000 		.word	24560
 3109 0844 BC050000 		.word	.LC37
 3110 0848 01010000 		.word	257
 3111 084c 03030000 		.word	771
 3112 0850 00000000 		.word	esUVCUvcAppDmaCallback
 3113 0854 00000000 		.word	glChHandleUVCStream
 3114 0858 EC050000 		.word	.LC38
 3115 085c 18060000 		.word	.LC39
 3116 0860 40060000 		.word	.LC40
 3117 0864 00000000 		.word	esUVCGpifCB
 3118 0868 68060000 		.word	.LC41
 3119 086c 8C060000 		.word	.LC42
 3120 0870 00000000 		.word	cfgUvcVgaNoMclk
 3121 0874 B0060000 		.word	.LC43
 3122 0878 00000000 		.word	UvcTimer
 3123 087c 00000000 		.word	UvcAppProgressTimer
 3124 0880 35010000 		.word	309
 3125 0884 DC060000 		.word	.LC44
 3126              		.cfi_endproc
 3127              	.LFE11:
 3129              		.section	.rodata
 3130              		.align	2
 3131              	.LC45:
 3132 06fc 0A0D6573 		.ascii	"\012\015esUVCUvcApplnDebugInit:CyU3PUartInit failed"
 3132      55564355 
 3132      76634170 
 3132      706C6E44 
 3132      65627567 
 3133 0729 20457272 		.ascii	" Error = 0x%x\000"
 3133      6F72203D 
 3133      20307825 
 3133      7800
 3134 0737 00       		.align	2
 3135              	.LC46:
 3136 0738 0A0D6573 		.ascii	"\012\015esUVCUvcApplnDebugInit:CyU3PUartSetConfig f"
 3136      55564355 
 3136      76634170 
 3136      706C6E44 
 3136      65627567 
 3137 0765 61696C65 		.ascii	"ailed Error = 0x%x\000"
 3137      64204572 
 3137      726F7220 
 3137      3D203078 
 3137      257800
 3138              		.align	2
 3139              	.LC47:
 3140 0778 0A0D6573 		.ascii	"\012\015esUVCUvcApplnDebugInit:CyU3PUartTxSetBlockX"
 3140      55564355 
 3140      76634170 
 3140      706C6E44 
 3140      65627567 
 3141 07a5 66657220 		.ascii	"fer failed Error = 0x%x\000"
 3141      6661696C 
 3141      65642045 
 3141      72726F72 
 3141      203D2030 
 3142 07bd 000000   		.align	2
 3143              	.LC48:
 3144 07c0 0A0D6573 		.ascii	"\012\015esUVCUvcApplnDebugInit:CyU3PDebugInit faile"
 3144      55564355 
 3144      76634170 
 3144      706C6E44 
 3144      65627567 
 3145 07ed 64204572 		.ascii	"d Error = 0x%x\000"
 3145      726F7220 
 3145      3D203078 
 3145      257800
 3146              		.section	.text.esUVCUvcApplnDebugInit,"ax",%progbits
 3147              		.align	2
 3148              		.global	esUVCUvcApplnDebugInit
 3150              	esUVCUvcApplnDebugInit:
 3151              	.LFB12:
1837:../CX3RDKOV5640.c **** 
1838:../CX3RDKOV5640.c **** /* This function initializes the debug module for the UVC application */
1839:../CX3RDKOV5640.c ****     void
1840:../CX3RDKOV5640.c **** esUVCUvcApplnDebugInit (void)
1841:../CX3RDKOV5640.c **** {
 3152              		.loc 1 1841 0
 3153              		.cfi_startproc
 3154              		@ args = 0, pretend = 0, frame = 32
 3155              		@ frame_needed = 1, uses_anonymous_args = 0
 3156 0000 00482DE9 		stmfd	sp!, {fp, lr}
 3157              	.LCFI24:
 3158              		.cfi_def_cfa_offset 8
 3159              		.cfi_offset 11, -8
 3160              		.cfi_offset 14, -4
 3161 0004 04B08DE2 		add	fp, sp, #4
 3162              	.LCFI25:
 3163              		.cfi_def_cfa 11, 4
 3164 0008 20D04DE2 		sub	sp, sp, #32
1842:../CX3RDKOV5640.c ****     CyU3PUartConfig_t uartConfig;
1843:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 3165              		.loc 1 1843 0
 3166 000c 0030A0E3 		mov	r3, #0
 3167 0010 08300BE5 		str	r3, [fp, #-8]
1844:../CX3RDKOV5640.c **** 
1845:../CX3RDKOV5640.c ****     /* Initialize the UART for printing debug messages */
1846:../CX3RDKOV5640.c ****     status = CyU3PUartInit();
 3168              		.loc 1 1846 0
 3169 0014 FEFFFFEB 		bl	CyU3PUartInit
 3170 0018 08000BE5 		str	r0, [fp, #-8]
1847:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3171              		.loc 1 1847 0
 3172 001c 08301BE5 		ldr	r3, [fp, #-8]
 3173 0020 000053E3 		cmp	r3, #0
 3174 0024 0300000A 		beq	.L169
1848:../CX3RDKOV5640.c ****     {
1849:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\resUVCUvcApplnDebugInit:CyU3PUartInit failed Error = 0x%x",status);
 3175              		.loc 1 1849 0
 3176 0028 0400A0E3 		mov	r0, #4
 3177 002c D0109FE5 		ldr	r1, .L173
 3178 0030 08201BE5 		ldr	r2, [fp, #-8]
 3179 0034 FEFFFFEB 		bl	CyU3PDebugPrint
 3180              	.L169:
1850:../CX3RDKOV5640.c ****     }
1851:../CX3RDKOV5640.c **** 
1852:../CX3RDKOV5640.c ****     /* Set UART Configuration */
1853:../CX3RDKOV5640.c ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 3181              		.loc 1 1853 0
 3182 0038 C8309FE5 		ldr	r3, .L173+4
 3183 003c 10300BE5 		str	r3, [fp, #-16]
1854:../CX3RDKOV5640.c ****     uartConfig.stopBit = CY_U3P_UART_ONE_STOP_BIT;
 3184              		.loc 1 1854 0
 3185 0040 0130A0E3 		mov	r3, #1
 3186 0044 0C304BE5 		strb	r3, [fp, #-12]
1855:../CX3RDKOV5640.c ****     uartConfig.parity = CY_U3P_UART_NO_PARITY;
 3187              		.loc 1 1855 0
 3188 0048 0030A0E3 		mov	r3, #0
 3189 004c 0B304BE5 		strb	r3, [fp, #-11]
1856:../CX3RDKOV5640.c ****     uartConfig.txEnable = CyTrue;
 3190              		.loc 1 1856 0
 3191 0050 0130A0E3 		mov	r3, #1
 3192 0054 20300BE5 		str	r3, [fp, #-32]
1857:../CX3RDKOV5640.c ****     uartConfig.rxEnable = CyFalse;
 3193              		.loc 1 1857 0
 3194 0058 0030A0E3 		mov	r3, #0
 3195 005c 1C300BE5 		str	r3, [fp, #-28]
1858:../CX3RDKOV5640.c ****     uartConfig.flowCtrl = CyFalse;
 3196              		.loc 1 1858 0
 3197 0060 0030A0E3 		mov	r3, #0
 3198 0064 18300BE5 		str	r3, [fp, #-24]
1859:../CX3RDKOV5640.c ****     uartConfig.isDma = CyTrue;
 3199              		.loc 1 1859 0
 3200 0068 0130A0E3 		mov	r3, #1
 3201 006c 14300BE5 		str	r3, [fp, #-20]
1860:../CX3RDKOV5640.c **** 
1861:../CX3RDKOV5640.c ****     /* Set the UART configuration */
1862:../CX3RDKOV5640.c ****     status = CyU3PUartSetConfig (&uartConfig, NULL);
 3202              		.loc 1 1862 0
 3203 0070 20304BE2 		sub	r3, fp, #32
 3204 0074 0300A0E1 		mov	r0, r3
 3205 0078 0010A0E3 		mov	r1, #0
 3206 007c FEFFFFEB 		bl	CyU3PUartSetConfig
 3207 0080 08000BE5 		str	r0, [fp, #-8]
1863:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3208              		.loc 1 1863 0
 3209 0084 08301BE5 		ldr	r3, [fp, #-8]
 3210 0088 000053E3 		cmp	r3, #0
 3211 008c 0300000A 		beq	.L170
1864:../CX3RDKOV5640.c ****     {
1865:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\resUVCUvcApplnDebugInit:CyU3PUartSetConfig failed Error = 0x%x",sta
 3212              		.loc 1 1865 0
 3213 0090 0400A0E3 		mov	r0, #4
 3214 0094 70109FE5 		ldr	r1, .L173+8
 3215 0098 08201BE5 		ldr	r2, [fp, #-8]
 3216 009c FEFFFFEB 		bl	CyU3PDebugPrint
 3217              	.L170:
1866:../CX3RDKOV5640.c ****     }
1867:../CX3RDKOV5640.c **** 
1868:../CX3RDKOV5640.c ****     /* Set the UART transfer */
1869:../CX3RDKOV5640.c ****     status = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 3218              		.loc 1 1869 0
 3219 00a0 0000E0E3 		mvn	r0, #0
 3220 00a4 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 3221 00a8 08000BE5 		str	r0, [fp, #-8]
1870:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3222              		.loc 1 1870 0
 3223 00ac 08301BE5 		ldr	r3, [fp, #-8]
 3224 00b0 000053E3 		cmp	r3, #0
 3225 00b4 0300000A 		beq	.L171
1871:../CX3RDKOV5640.c ****     {
1872:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\resUVCUvcApplnDebugInit:CyU3PUartTxSetBlockXfer failed Error = 0x%x
 3226              		.loc 1 1872 0
 3227 00b8 0400A0E3 		mov	r0, #4
 3228 00bc 4C109FE5 		ldr	r1, .L173+12
 3229 00c0 08201BE5 		ldr	r2, [fp, #-8]
 3230 00c4 FEFFFFEB 		bl	CyU3PDebugPrint
 3231              	.L171:
1873:../CX3RDKOV5640.c ****     }
1874:../CX3RDKOV5640.c **** 
1875:../CX3RDKOV5640.c ****     /* Initialize the debug application */
1876:../CX3RDKOV5640.c ****     status = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 8);
 3232              		.loc 1 1876 0
 3233 00c8 0300A0E3 		mov	r0, #3
 3234 00cc 0810A0E3 		mov	r1, #8
 3235 00d0 FEFFFFEB 		bl	CyU3PDebugInit
 3236 00d4 08000BE5 		str	r0, [fp, #-8]
1877:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3237              		.loc 1 1877 0
 3238 00d8 08301BE5 		ldr	r3, [fp, #-8]
 3239 00dc 000053E3 		cmp	r3, #0
 3240 00e0 0300000A 		beq	.L172
1878:../CX3RDKOV5640.c ****     {
1879:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\resUVCUvcApplnDebugInit:CyU3PDebugInit failed Error = 0x%x",status)
 3241              		.loc 1 1879 0
 3242 00e4 0400A0E3 		mov	r0, #4
 3243 00e8 24109FE5 		ldr	r1, .L173+16
 3244 00ec 08201BE5 		ldr	r2, [fp, #-8]
 3245 00f0 FEFFFFEB 		bl	CyU3PDebugPrint
 3246              	.L172:
1880:../CX3RDKOV5640.c ****     }
1881:../CX3RDKOV5640.c ****     CyU3PDebugPreamble (CyFalse);
 3247              		.loc 1 1881 0
 3248 00f4 0000A0E3 		mov	r0, #0
 3249 00f8 FEFFFFEB 		bl	CyU3PDebugPreamble
1882:../CX3RDKOV5640.c **** 
1883:../CX3RDKOV5640.c **** }
 3250              		.loc 1 1883 0
 3251 00fc 04D04BE2 		sub	sp, fp, #4
 3252              		@ sp needed
 3253 0100 0088BDE8 		ldmfd	sp!, {fp, pc}
 3254              	.L174:
 3255              		.align	2
 3256              	.L173:
 3257 0104 FC060000 		.word	.LC45
 3258 0108 00C20100 		.word	115200
 3259 010c 38070000 		.word	.LC46
 3260 0110 78070000 		.word	.LC47
 3261 0114 C0070000 		.word	.LC48
 3262              		.cfi_endproc
 3263              	.LFE12:
 3265              		.section	.text.esUVCUvcAppThread_Entry,"ax",%progbits
 3266              		.align	2
 3267              		.global	esUVCUvcAppThread_Entry
 3269              	esUVCUvcAppThread_Entry:
 3270              	.LFB13:
1884:../CX3RDKOV5640.c **** 
1885:../CX3RDKOV5640.c **** /* Entry function for the UVC application thread. */
1886:../CX3RDKOV5640.c ****     void
1887:../CX3RDKOV5640.c **** esUVCUvcAppThread_Entry (
1888:../CX3RDKOV5640.c ****         uint32_t input)
1889:../CX3RDKOV5640.c **** {
 3271              		.loc 1 1889 0
 3272              		.cfi_startproc
 3273              		@ args = 0, pretend = 0, frame = 16
 3274              		@ frame_needed = 1, uses_anonymous_args = 0
 3275 0000 00482DE9 		stmfd	sp!, {fp, lr}
 3276              	.LCFI26:
 3277              		.cfi_def_cfa_offset 8
 3278              		.cfi_offset 11, -8
 3279              		.cfi_offset 14, -4
 3280 0004 04B08DE2 		add	fp, sp, #4
 3281              	.LCFI27:
 3282              		.cfi_def_cfa 11, 4
 3283 0008 18D04DE2 		sub	sp, sp, #24
 3284 000c 10000BE5 		str	r0, [fp, #-16]
1890:../CX3RDKOV5640.c ****     uint16_t wakeReason;
1891:../CX3RDKOV5640.c ****     uint32_t eventFlag;
1892:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status;
1893:../CX3RDKOV5640.c **** 
1894:../CX3RDKOV5640.c ****     /* Initialize the Debug Module */
1895:../CX3RDKOV5640.c ****     esUVCUvcApplnDebugInit();
 3285              		.loc 1 1895 0
 3286 0010 FEFFFFEB 		bl	esUVCUvcApplnDebugInit
1896:../CX3RDKOV5640.c **** 
1897:../CX3RDKOV5640.c ****     /* Initialize the UVC Application */
1898:../CX3RDKOV5640.c ****     esUVCUvcApplnInit();
 3287              		.loc 1 1898 0
 3288 0014 FEFFFFEB 		bl	esUVCUvcApplnInit
 3289              	.L181:
1899:../CX3RDKOV5640.c **** 
1900:../CX3RDKOV5640.c ****     for (;;)
1901:../CX3RDKOV5640.c ****     {
1902:../CX3RDKOV5640.c ****         CyU3PEventGet (&glTimerEvent,ES_USB_SUSP_EVENT_FLAG|ES_TIMER_RESET_EVENT, CYU3P_EVENT_OR_CL
 3290              		.loc 1 1902 0
 3291 0018 08304BE2 		sub	r3, fp, #8
 3292 001c 0020E0E3 		mvn	r2, #0
 3293 0020 00208DE5 		str	r2, [sp]
 3294 0024 9C009FE5 		ldr	r0, .L183
 3295 0028 3010A0E3 		mov	r1, #48
 3296 002c 0120A0E3 		mov	r2, #1
 3297 0030 FEFFFFEB 		bl	_txe_event_flags_get
1903:../CX3RDKOV5640.c **** 
1904:../CX3RDKOV5640.c ****         /* Handle TimerReset Event*/
1905:../CX3RDKOV5640.c ****         if( eventFlag & ES_TIMER_RESET_EVENT)
 3298              		.loc 1 1905 0
 3299 0034 08301BE5 		ldr	r3, [fp, #-8]
 3300 0038 103003E2 		and	r3, r3, #16
 3301 003c 000053E3 		cmp	r3, #0
 3302 0040 1400000A 		beq	.L176
1906:../CX3RDKOV5640.c ****         {
1907:../CX3RDKOV5640.c ****             if (glIsApplnActive)
 3303              		.loc 1 1907 0
 3304 0044 80309FE5 		ldr	r3, .L183+4
 3305 0048 003093E5 		ldr	r3, [r3]
 3306 004c 000053E3 		cmp	r3, #0
 3307 0050 0300000A 		beq	.L177
1908:../CX3RDKOV5640.c ****             {
1909:../CX3RDKOV5640.c ****             	glIsClearFeature = CyFalse;
 3308              		.loc 1 1909 0
 3309 0054 74309FE5 		ldr	r3, .L183+8
 3310 0058 0020A0E3 		mov	r2, #0
 3311 005c 002083E5 		str	r2, [r3]
1910:../CX3RDKOV5640.c ****                 esUVCUvcApplnStop();
 3312              		.loc 1 1910 0
 3313 0060 FEFFFFEB 		bl	esUVCUvcApplnStop
 3314              	.L177:
1911:../CX3RDKOV5640.c **** #ifdef VISDebug
1912:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rES_TIMER_RESET_EVENT: esUVCUvcApplnStop");
1913:../CX3RDKOV5640.c **** #endif
1914:../CX3RDKOV5640.c ****             }
1915:../CX3RDKOV5640.c ****             if(glPreviewStarted == CyTrue)
 3315              		.loc 1 1915 0
 3316 0064 68309FE5 		ldr	r3, .L183+12
 3317 0068 003093E5 		ldr	r3, [r3]
 3318 006c 010053E3 		cmp	r3, #1
 3319 0070 0400001A 		bne	.L178
1916:../CX3RDKOV5640.c ****             {
1917:../CX3RDKOV5640.c ****             	//TODO Change this function with "Sensor Specific" function to write the sensor settin
1918:../CX3RDKOV5640.c ****             	esSetCameraResolution(glFrameIndexToSet);
 3320              		.loc 1 1918 0
 3321 0074 5C309FE5 		ldr	r3, .L183+16
 3322 0078 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 3323 007c 0300A0E1 		mov	r0, r3
 3324 0080 FEFFFFEB 		bl	esSetCameraResolution
1919:../CX3RDKOV5640.c ****             	esUVCUvcApplnStart();
 3325              		.loc 1 1919 0
 3326 0084 FEFFFFEB 		bl	esUVCUvcApplnStart
 3327              	.L178:
1920:../CX3RDKOV5640.c **** #ifdef VISDebug
1921:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rES_TIMER_RESET_EVENT: esUVCUvcApplnStart");
1922:../CX3RDKOV5640.c **** #endif
1923:../CX3RDKOV5640.c ****             }
1924:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
1925:../CX3RDKOV5640.c ****             CyU3PTimerModify (&UvcTimer, TIMER_PERIOD, 0);
 3328              		.loc 1 1925 0
 3329 0088 4C009FE5 		ldr	r0, .L183+20
 3330 008c 7D1FA0E3 		mov	r1, #500
 3331 0090 0020A0E3 		mov	r2, #0
 3332 0094 FEFFFFEB 		bl	_txe_timer_change
 3333              	.L176:
1926:../CX3RDKOV5640.c **** #endif
1927:../CX3RDKOV5640.c ****         }
1928:../CX3RDKOV5640.c ****         /* Handle Suspend Event*/
1929:../CX3RDKOV5640.c ****         if(eventFlag & ES_USB_SUSP_EVENT_FLAG)
 3334              		.loc 1 1929 0
 3335 0098 08301BE5 		ldr	r3, [fp, #-8]
 3336 009c 203003E2 		and	r3, r3, #32
 3337 00a0 000053E3 		cmp	r3, #0
 3338 00a4 0600000A 		beq	.L179
1930:../CX3RDKOV5640.c ****         {
1931:../CX3RDKOV5640.c ****             /* Place CX3 in Low Power Suspend mode, with USB bus activity as the wakeup source. */
1932:../CX3RDKOV5640.c ****             //CyU3PMipicsiSleep();
1933:../CX3RDKOV5640.c ****             //TODO Change this function with "Sensor Specific" PowerDown function to PowerDown the 
1934:../CX3RDKOV5640.c ****             //esCamera_Power_Down();
1935:../CX3RDKOV5640.c **** 
1936:../CX3RDKOV5640.c ****             //status = CyU3PSysEnterSuspendMode (CY_U3P_SYS_USB_BUS_ACTVTY_WAKEUP_SRC, 0, &wakeReas
1937:../CX3RDKOV5640.c **** #ifdef VISDebug
1938:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rES_USB_SUSP_EVENT_FLAG %x", status);
1939:../CX3RDKOV5640.c **** #endif
1940:../CX3RDKOV5640.c ****     		if(glMipiActive)
 3339              		.loc 1 1940 0
 3340 00a8 30309FE5 		ldr	r3, .L183+24
 3341 00ac 003093E5 		ldr	r3, [r3]
 3342 00b0 000053E3 		cmp	r3, #0
 3343 00b4 0100000A 		beq	.L180
1941:../CX3RDKOV5640.c ****             {
1942:../CX3RDKOV5640.c ****                 CyU3PMipicsiWakeup();
 3344              		.loc 1 1942 0
 3345 00b8 FEFFFFEB 		bl	CyU3PMipicsiWakeup
1943:../CX3RDKOV5640.c ****                 //TODO Change this function with "Sensor Specific" PowerUp function to PowerUp the 
1944:../CX3RDKOV5640.c ****                 //esCamera_Power_Up();  // remove the camera operations function for VIS mipi camer
1945:../CX3RDKOV5640.c **** #ifdef VISDebug
1946:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rES_USB_SUSP_EVENT_FLAG: esCamera_Power_Up");
1947:../CX3RDKOV5640.c **** #endif
1948:../CX3RDKOV5640.c ****             }
1949:../CX3RDKOV5640.c ****             continue;
 3346              		.loc 1 1949 0
 3347 00bc FFFFFFEA 		b	.L182
 3348              	.L180:
 3349              	.L182:
 3350 00c0 0000A0E1 		mov	r0, r0	@ nop
 3351              	.L179:
1950:../CX3RDKOV5640.c ****         }
1951:../CX3RDKOV5640.c **** #ifdef VISDebug
1952:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rApp Thread Loop");
1953:../CX3RDKOV5640.c **** #endif
1954:../CX3RDKOV5640.c ****     } /* End of for(;;) */
 3352              		.loc 1 1954 0
 3353 00c4 D3FFFFEA 		b	.L181
 3354              	.L184:
 3355              		.align	2
 3356              	.L183:
 3357 00c8 00000000 		.word	glTimerEvent
 3358 00cc 00000000 		.word	glIsApplnActive
 3359 00d0 00000000 		.word	glIsClearFeature
 3360 00d4 00000000 		.word	glPreviewStarted
 3361 00d8 00000000 		.word	glFrameIndexToSet
 3362 00dc 00000000 		.word	UvcTimer
 3363 00e0 00000000 		.word	glMipiActive
 3364              		.cfi_endproc
 3365              	.LFE13:
 3367              		.section	.rodata
 3368              		.align	2
 3369              	.LC49:
 3370 07fc 53656E43 		.ascii	"SenCmdQue\000"
 3370      6D645175 
 3370      6500
 3371 0806 0000     		.align	2
 3372              	.LC50:
 3373 0808 53656E53 		.ascii	"SenStatQue\000"
 3373      74617451 
 3373      756500
 3374 0813 00       		.align	2
 3375              	.LC51:
 3376 0814 33303A55 		.ascii	"30:UVC_app_thread\000"
 3376      56435F61 
 3376      70705F74 
 3376      68726561 
 3376      6400
 3377 0826 0000     		.align	2
 3378              	.LC52:
 3379 0828 33313A53 		.ascii	"31:Sen_ctrl_thread\000"
 3379      656E5F63 
 3379      74726C5F 
 3379      74687265 
 3379      616400
 3380 083b 00       		.section	.text.CyFxApplicationDefine,"ax",%progbits
 3381              		.align	2
 3382              		.global	CyFxApplicationDefine
 3384              	CyFxApplicationDefine:
 3385              	.LFB14:
1955:../CX3RDKOV5640.c **** }
1956:../CX3RDKOV5640.c **** 
1957:../CX3RDKOV5640.c **** 
1958:../CX3RDKOV5640.c **** /* Application define function which creates the threads. */
1959:../CX3RDKOV5640.c ****     void
1960:../CX3RDKOV5640.c **** CyFxApplicationDefine (
1961:../CX3RDKOV5640.c ****         void)
1962:../CX3RDKOV5640.c **** {
 3386              		.loc 1 1962 0
 3387              		.cfi_startproc
 3388              		@ args = 0, pretend = 0, frame = 64
 3389              		@ frame_needed = 1, uses_anonymous_args = 0
 3390 0000 10482DE9 		stmfd	sp!, {r4, fp, lr}
 3391              	.LCFI28:
 3392              		.cfi_def_cfa_offset 12
 3393              		.cfi_offset 4, -12
 3394              		.cfi_offset 11, -8
 3395              		.cfi_offset 14, -4
 3396 0004 08B08DE2 		add	fp, sp, #8
 3397              	.LCFI29:
 3398              		.cfi_def_cfa 11, 4
 3399 0008 64D04DE2 		sub	sp, sp, #100
1963:../CX3RDKOV5640.c ****     void *ptrUvc = NULL, *ptrSen = NULL;
 3400              		.loc 1 1963 0
 3401 000c 0030A0E3 		mov	r3, #0
 3402 0010 10300BE5 		str	r3, [fp, #-16]
 3403 0014 0030A0E3 		mov	r3, #0
 3404 0018 14300BE5 		str	r3, [fp, #-20]
1964:../CX3RDKOV5640.c ****     uint32_t retThrdCreate = CY_U3P_SUCCESS;
 3405              		.loc 1 1964 0
 3406 001c 0030A0E3 		mov	r3, #0
 3407 0020 18300BE5 		str	r3, [fp, #-24]
1965:../CX3RDKOV5640.c ****     VdRingBuf *cmdQuptr = &cmdQu, *statQuptr = &statQu;
 3408              		.loc 1 1965 0
 3409 0024 60319FE5 		ldr	r3, .L192
 3410 0028 1C300BE5 		str	r3, [fp, #-28]
 3411 002c 5C319FE5 		ldr	r3, .L192+4
 3412 0030 20300BE5 		str	r3, [fp, #-32]
1966:../CX3RDKOV5640.c ****     /* Create/initialize Ring buffers for Sensor control */
1967:../CX3RDKOV5640.c ****     char *cmdName = "SenCmdQue", *StatName = "SenStatQue";
 3413              		.loc 1 1967 0
 3414 0034 58319FE5 		ldr	r3, .L192+8
 3415 0038 24300BE5 		str	r3, [fp, #-36]
 3416 003c 54319FE5 		ldr	r3, .L192+12
 3417 0040 28300BE5 		str	r3, [fp, #-40]
1968:../CX3RDKOV5640.c ****     cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 3418              		.loc 1 1968 0
 3419 0044 40419FE5 		ldr	r4, .L192
 3420 0048 4C304BE2 		sub	r3, fp, #76
 3421 004c 48219FE5 		ldr	r2, .L192+16
 3422 0050 00208DE5 		str	r2, [sp]
 3423 0054 0300A0E1 		mov	r0, r3
 3424 0058 4010A0E3 		mov	r1, #64
 3425 005c 24201BE5 		ldr	r2, [fp, #-36]
 3426 0060 0030A0E3 		mov	r3, #0
 3427 0064 FEFFFFEB 		bl	cmdbufCreate
 3428 0068 04C0A0E1 		mov	ip, r4
 3429 006c 4CE04BE2 		sub	lr, fp, #76
 3430 0070 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 3431 0074 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 3432 0078 0F009EE8 		ldmia	lr, {r0, r1, r2, r3}
 3433 007c 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
1969:../CX3RDKOV5640.c **** 	cmdquInit(cmdQuptr);
 3434              		.loc 1 1969 0
 3435 0080 1C001BE5 		ldr	r0, [fp, #-28]
 3436 0084 FEFFFFEB 		bl	cmdquInit
1970:../CX3RDKOV5640.c **** 
1971:../CX3RDKOV5640.c ****     /* Allocate the memory for the thread and create the thread */
1972:../CX3RDKOV5640.c ****     ptrUvc = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 3437              		.loc 1 1972 0
 3438 0088 010AA0E3 		mov	r0, #4096
 3439 008c FEFFFFEB 		bl	CyU3PMemAlloc
 3440 0090 10000BE5 		str	r0, [fp, #-16]
1973:../CX3RDKOV5640.c ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 3441              		.loc 1 1973 0
 3442 0094 10301BE5 		ldr	r3, [fp, #-16]
 3443 0098 00308DE5 		str	r3, [sp]
 3444 009c 013AA0E3 		mov	r3, #4096
 3445 00a0 04308DE5 		str	r3, [sp, #4]
 3446 00a4 0830A0E3 		mov	r3, #8
 3447 00a8 08308DE5 		str	r3, [sp, #8]
 3448 00ac 0830A0E3 		mov	r3, #8
 3449 00b0 0C308DE5 		str	r3, [sp, #12]
 3450 00b4 0030A0E3 		mov	r3, #0
 3451 00b8 10308DE5 		str	r3, [sp, #16]
 3452 00bc 0130A0E3 		mov	r3, #1
 3453 00c0 14308DE5 		str	r3, [sp, #20]
 3454 00c4 A830A0E3 		mov	r3, #168
 3455 00c8 18308DE5 		str	r3, [sp, #24]
 3456 00cc CC009FE5 		ldr	r0, .L192+20
 3457 00d0 CC109FE5 		ldr	r1, .L192+24
 3458 00d4 CC209FE5 		ldr	r2, .L192+28
 3459 00d8 0030A0E3 		mov	r3, #0
 3460 00dc FEFFFFEB 		bl	_txe_thread_create
 3461 00e0 18000BE5 		str	r0, [fp, #-24]
1974:../CX3RDKOV5640.c ****             "30:UVC_app_thread",         /* Thread Id and name */
1975:../CX3RDKOV5640.c ****             esUVCUvcAppThread_Entry,          /* UVC Application Thread Entry function */
1976:../CX3RDKOV5640.c ****             0,                           /* No input parameter to thread */
1977:../CX3RDKOV5640.c ****             ptrUvc,                         /* Pointer to the allocated thread stack */
1978:../CX3RDKOV5640.c ****             UVC_APP_THREAD_STACK,        /* UVC Application Thread stack size */
1979:../CX3RDKOV5640.c ****             UVC_APP_THREAD_PRIORITY,     /* UVC Application Thread priority */
1980:../CX3RDKOV5640.c ****             UVC_APP_THREAD_PRIORITY,     /* Pre-emption threshold */
1981:../CX3RDKOV5640.c ****             CYU3P_NO_TIME_SLICE,         /* No time slice for the application thread */
1982:../CX3RDKOV5640.c ****             CYU3P_AUTO_START             /* Start the Thread immediately */
1983:../CX3RDKOV5640.c ****             );
1984:../CX3RDKOV5640.c **** 
1985:../CX3RDKOV5640.c ****     /* Check the return code */
1986:../CX3RDKOV5640.c ****     if (retThrdCreate != 0)
 3462              		.loc 1 1986 0
 3463 00e4 18301BE5 		ldr	r3, [fp, #-24]
 3464 00e8 000053E3 		cmp	r3, #0
 3465 00ec 0000000A 		beq	.L186
 3466              	.L187:
1987:../CX3RDKOV5640.c ****     {
1988:../CX3RDKOV5640.c ****         /* Thread Creation failed with the error code retThrdCreate */
1989:../CX3RDKOV5640.c **** 
1990:../CX3RDKOV5640.c ****         /* Add custom recovery or debug actions here */
1991:../CX3RDKOV5640.c **** 
1992:../CX3RDKOV5640.c ****         /* Application cannot continue */
1993:../CX3RDKOV5640.c ****         /* Loop indefinitely */
1994:../CX3RDKOV5640.c ****         while(1);
 3467              		.loc 1 1994 0 discriminator 1
 3468 00f0 FEFFFFEA 		b	.L187
 3469              	.L186:
1995:../CX3RDKOV5640.c ****     }
1996:../CX3RDKOV5640.c **** 
1997:../CX3RDKOV5640.c ****     ptrSen = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 3470              		.loc 1 1997 0
 3471 00f4 010AA0E3 		mov	r0, #4096
 3472 00f8 FEFFFFEB 		bl	CyU3PMemAlloc
 3473 00fc 14000BE5 		str	r0, [fp, #-20]
1998:../CX3RDKOV5640.c ****     retThrdCreate = CyU3PThreadCreate (&SenAppThread,   /* UVC Thread structure */
 3474              		.loc 1 1998 0
 3475 0100 14301BE5 		ldr	r3, [fp, #-20]
 3476 0104 00308DE5 		str	r3, [sp]
 3477 0108 013AA0E3 		mov	r3, #4096
 3478 010c 04308DE5 		str	r3, [sp, #4]
 3479 0110 0830A0E3 		mov	r3, #8
 3480 0114 08308DE5 		str	r3, [sp, #8]
 3481 0118 0830A0E3 		mov	r3, #8
 3482 011c 0C308DE5 		str	r3, [sp, #12]
 3483 0120 0030A0E3 		mov	r3, #0
 3484 0124 10308DE5 		str	r3, [sp, #16]
 3485 0128 0130A0E3 		mov	r3, #1
 3486 012c 14308DE5 		str	r3, [sp, #20]
 3487 0130 A830A0E3 		mov	r3, #168
 3488 0134 18308DE5 		str	r3, [sp, #24]
 3489 0138 6C009FE5 		ldr	r0, .L192+32
 3490 013c 6C109FE5 		ldr	r1, .L192+36
 3491 0140 6C209FE5 		ldr	r2, .L192+40
 3492 0144 0030A0E3 		mov	r3, #0
 3493 0148 FEFFFFEB 		bl	_txe_thread_create
 3494 014c 18000BE5 		str	r0, [fp, #-24]
1999:../CX3RDKOV5640.c ****             "31:Sen_ctrl_thread",         /* Thread Id and name */
2000:../CX3RDKOV5640.c ****             SenAppThread_Entry,          /* UVC Application Thread Entry function */
2001:../CX3RDKOV5640.c ****             0,                           /* No input parameter to thread */
2002:../CX3RDKOV5640.c ****             ptrSen,                         /* Pointer to the allocated thread stack */
2003:../CX3RDKOV5640.c ****             UVC_APP_THREAD_STACK,        /* UVC Application Thread stack size */
2004:../CX3RDKOV5640.c ****             UVC_APP_THREAD_PRIORITY,     /* UVC Application Thread priority */
2005:../CX3RDKOV5640.c ****             UVC_APP_THREAD_PRIORITY,     /* Pre-emption threshold */
2006:../CX3RDKOV5640.c ****             CYU3P_NO_TIME_SLICE,         /* No time slice for the application thread */
2007:../CX3RDKOV5640.c ****             CYU3P_AUTO_START             /* Start the Thread immediately */
2008:../CX3RDKOV5640.c ****             );
2009:../CX3RDKOV5640.c **** 
2010:../CX3RDKOV5640.c ****     /* Check the return code */
2011:../CX3RDKOV5640.c ****     if (retThrdCreate != 0)
 3495              		.loc 1 2011 0
 3496 0150 18301BE5 		ldr	r3, [fp, #-24]
 3497 0154 000053E3 		cmp	r3, #0
 3498 0158 0000000A 		beq	.L188
 3499              	.L189:
2012:../CX3RDKOV5640.c ****     {
2013:../CX3RDKOV5640.c ****         /* Thread Creation failed with the error code retThrdCreate */
2014:../CX3RDKOV5640.c **** 
2015:../CX3RDKOV5640.c ****         /* Add custom recovery or debug actions here */
2016:../CX3RDKOV5640.c **** 
2017:../CX3RDKOV5640.c ****         /* Application cannot continue */
2018:../CX3RDKOV5640.c ****         /* Loop indefinitely */
2019:../CX3RDKOV5640.c ****         while(1);
 3500              		.loc 1 2019 0 discriminator 1
 3501 015c FEFFFFEA 		b	.L189
 3502              	.L188:
2020:../CX3RDKOV5640.c ****     }
2021:../CX3RDKOV5640.c ****     /* Create GPIO application event group */
2022:../CX3RDKOV5640.c ****     retThrdCreate = CyU3PEventCreate(&glTimerEvent);
 3503              		.loc 1 2022 0
 3504 0160 50009FE5 		ldr	r0, .L192+44
 3505 0164 0010A0E3 		mov	r1, #0
 3506 0168 2820A0E3 		mov	r2, #40
 3507 016c FEFFFFEB 		bl	_txe_event_flags_create
 3508 0170 18000BE5 		str	r0, [fp, #-24]
2023:../CX3RDKOV5640.c ****     if (retThrdCreate != 0)
 3509              		.loc 1 2023 0
 3510 0174 18301BE5 		ldr	r3, [fp, #-24]
 3511 0178 000053E3 		cmp	r3, #0
 3512 017c 0000000A 		beq	.L185
 3513              	.L191:
2024:../CX3RDKOV5640.c ****     {
2025:../CX3RDKOV5640.c ****         /* Event group creation failed with the error code retThrdCreate */
2026:../CX3RDKOV5640.c **** 
2027:../CX3RDKOV5640.c ****         /* Add custom recovery or debug actions here */
2028:../CX3RDKOV5640.c **** 
2029:../CX3RDKOV5640.c ****         /* Application cannot continue */
2030:../CX3RDKOV5640.c ****         /* Loop indefinitely */
2031:../CX3RDKOV5640.c ****         while(1);
 3514              		.loc 1 2031 0 discriminator 1
 3515 0180 FEFFFFEA 		b	.L191
 3516              	.L185:
2032:../CX3RDKOV5640.c ****     }
2033:../CX3RDKOV5640.c **** }
 3517              		.loc 1 2033 0
 3518 0184 08D04BE2 		sub	sp, fp, #8
 3519              		@ sp needed
 3520 0188 1088BDE8 		ldmfd	sp!, {r4, fp, pc}
 3521              	.L193:
 3522              		.align	2
 3523              	.L192:
 3524 018c 00000000 		.word	cmdQu
 3525 0190 00000000 		.word	statQu
 3526 0194 FC070000 		.word	.LC49
 3527 0198 08080000 		.word	.LC50
 3528 019c 00000000 		.word	cmdQuMux
 3529 01a0 00000000 		.word	uvcAppThread
 3530 01a4 14080000 		.word	.LC51
 3531 01a8 00000000 		.word	esUVCUvcAppThread_Entry
 3532 01ac 00000000 		.word	SenAppThread
 3533 01b0 28080000 		.word	.LC52
 3534 01b4 00000000 		.word	SenAppThread_Entry
 3535 01b8 00000000 		.word	glTimerEvent
 3536              		.cfi_endproc
 3537              	.LFE14:
 3539              		.section	.text.main,"ax",%progbits
 3540              		.align	2
 3541              		.global	main
 3543              	main:
 3544              	.LFB15:
2034:../CX3RDKOV5640.c **** 
2035:../CX3RDKOV5640.c **** /*
2036:../CX3RDKOV5640.c ****  * Main function
2037:../CX3RDKOV5640.c ****  */
2038:../CX3RDKOV5640.c **** 
2039:../CX3RDKOV5640.c ****     int
2040:../CX3RDKOV5640.c **** main (void)
2041:../CX3RDKOV5640.c **** {
 3545              		.loc 1 2041 0
 3546              		.cfi_startproc
 3547              		@ args = 0, pretend = 0, frame = 48
 3548              		@ frame_needed = 1, uses_anonymous_args = 0
 3549 0000 00482DE9 		stmfd	sp!, {fp, lr}
 3550              	.LCFI30:
 3551              		.cfi_def_cfa_offset 8
 3552              		.cfi_offset 11, -8
 3553              		.cfi_offset 14, -4
 3554 0004 04B08DE2 		add	fp, sp, #4
 3555              	.LCFI31:
 3556              		.cfi_def_cfa 11, 4
 3557 0008 30D04DE2 		sub	sp, sp, #48
2042:../CX3RDKOV5640.c ****     CyU3PIoMatrixConfig_t io_cfg;
2043:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 3558              		.loc 1 2043 0
 3559 000c 0030A0E3 		mov	r3, #0
 3560 0010 08300BE5 		str	r3, [fp, #-8]
2044:../CX3RDKOV5640.c **** 
2045:../CX3RDKOV5640.c ****     /* Initialize the device */
2046:../CX3RDKOV5640.c ****     status = CyU3PDeviceInit (NULL);
 3561              		.loc 1 2046 0
 3562 0014 0000A0E3 		mov	r0, #0
 3563 0018 FEFFFFEB 		bl	CyU3PDeviceInit
 3564 001c 08000BE5 		str	r0, [fp, #-8]
2047:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3565              		.loc 1 2047 0
 3566 0020 08301BE5 		ldr	r3, [fp, #-8]
 3567 0024 000053E3 		cmp	r3, #0
 3568 0028 0000000A 		beq	.L195
2048:../CX3RDKOV5640.c ****     {
2049:../CX3RDKOV5640.c ****         goto handle_fatal_error;
 3569              		.loc 1 2049 0
 3570 002c 270000EA 		b	.L196
 3571              	.L195:
2050:../CX3RDKOV5640.c ****     }
2051:../CX3RDKOV5640.c **** 
2052:../CX3RDKOV5640.c ****     /* Initialize the caches. Enable instruction cache and keep data cache disabled.
2053:../CX3RDKOV5640.c ****      * The data cache is useful only when there is a large amount of CPU based memory
2054:../CX3RDKOV5640.c ****      * accesses. When used in simple cases, it can decrease performance due to large
2055:../CX3RDKOV5640.c ****      * number of cache flushes and cleans and also it adds to the complexity of the
2056:../CX3RDKOV5640.c ****      * code. */
2057:../CX3RDKOV5640.c ****     status = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 3572              		.loc 1 2057 0
 3573 0030 0100A0E3 		mov	r0, #1
 3574 0034 0010A0E3 		mov	r1, #0
 3575 0038 0020A0E3 		mov	r2, #0
 3576 003c FEFFFFEB 		bl	CyU3PDeviceCacheControl
 3577 0040 08000BE5 		str	r0, [fp, #-8]
2058:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3578              		.loc 1 2058 0
 3579 0044 08301BE5 		ldr	r3, [fp, #-8]
 3580 0048 000053E3 		cmp	r3, #0
 3581 004c 0000000A 		beq	.L197
2059:../CX3RDKOV5640.c ****     {
2060:../CX3RDKOV5640.c ****         goto handle_fatal_error;
 3582              		.loc 1 2060 0
 3583 0050 1E0000EA 		b	.L196
 3584              	.L197:
2061:../CX3RDKOV5640.c ****     }
2062:../CX3RDKOV5640.c **** 
2063:../CX3RDKOV5640.c ****     /* Configure the IO matrix for the device.*/
2064:../CX3RDKOV5640.c ****     io_cfg.isDQ32Bit = CyFalse;
 3585              		.loc 1 2064 0
 3586 0054 0030A0E3 		mov	r3, #0
 3587 0058 30300BE5 		str	r3, [fp, #-48]
2065:../CX3RDKOV5640.c **** 
2066:../CX3RDKOV5640.c ****     io_cfg.useUart   = CyTrue;
 3588              		.loc 1 2066 0
 3589 005c 0130A0E3 		mov	r3, #1
 3590 0060 2C300BE5 		str	r3, [fp, #-44]
2067:../CX3RDKOV5640.c ****     io_cfg.useI2C    = CyTrue;
 3591              		.loc 1 2067 0
 3592 0064 0130A0E3 		mov	r3, #1
 3593 0068 28300BE5 		str	r3, [fp, #-40]
2068:../CX3RDKOV5640.c ****     io_cfg.useI2S    = CyFalse;
 3594              		.loc 1 2068 0
 3595 006c 0030A0E3 		mov	r3, #0
 3596 0070 24300BE5 		str	r3, [fp, #-36]
2069:../CX3RDKOV5640.c ****     io_cfg.useSpi    = CyFalse;
 3597              		.loc 1 2069 0
 3598 0074 0030A0E3 		mov	r3, #0
 3599 0078 20300BE5 		str	r3, [fp, #-32]
2070:../CX3RDKOV5640.c ****     io_cfg.lppMode   = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 3600              		.loc 1 2070 0
 3601 007c 0030A0E3 		mov	r3, #0
 3602 0080 1A304BE5 		strb	r3, [fp, #-26]
2071:../CX3RDKOV5640.c ****     /* No GPIOs are enabled. */
2072:../CX3RDKOV5640.c ****     io_cfg.gpioSimpleEn[0]  = 0;
 3603              		.loc 1 2072 0
 3604 0084 0030A0E3 		mov	r3, #0
 3605 0088 18300BE5 		str	r3, [fp, #-24]
2073:../CX3RDKOV5640.c ****     io_cfg.gpioSimpleEn[1]  = 0;
 3606              		.loc 1 2073 0
 3607 008c 0030A0E3 		mov	r3, #0
 3608 0090 14300BE5 		str	r3, [fp, #-20]
2074:../CX3RDKOV5640.c ****     io_cfg.gpioComplexEn[0] = 0;
 3609              		.loc 1 2074 0
 3610 0094 0030A0E3 		mov	r3, #0
 3611 0098 10300BE5 		str	r3, [fp, #-16]
2075:../CX3RDKOV5640.c ****     io_cfg.gpioComplexEn[1] = 0;
 3612              		.loc 1 2075 0
 3613 009c 0030A0E3 		mov	r3, #0
 3614 00a0 0C300BE5 		str	r3, [fp, #-12]
2076:../CX3RDKOV5640.c ****     status = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 3615              		.loc 1 2076 0
 3616 00a4 30304BE2 		sub	r3, fp, #48
 3617 00a8 0300A0E1 		mov	r0, r3
 3618 00ac FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 3619 00b0 08000BE5 		str	r0, [fp, #-8]
2077:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3620              		.loc 1 2077 0
 3621 00b4 08301BE5 		ldr	r3, [fp, #-8]
 3622 00b8 000053E3 		cmp	r3, #0
 3623 00bc 0000000A 		beq	.L198
2078:../CX3RDKOV5640.c ****     {
2079:../CX3RDKOV5640.c ****         goto handle_fatal_error;
 3624              		.loc 1 2079 0
 3625 00c0 020000EA 		b	.L196
 3626              	.L198:
2080:../CX3RDKOV5640.c ****     }
2081:../CX3RDKOV5640.c **** 
2082:../CX3RDKOV5640.c ****     /* This is a non returnable call for initializing the RTOS kernel */
2083:../CX3RDKOV5640.c ****     CyU3PKernelEntry ();
 3627              		.loc 1 2083 0
 3628 00c4 FEFFFFEB 		bl	_tx_initialize_kernel_enter
2084:../CX3RDKOV5640.c **** 
2085:../CX3RDKOV5640.c ****     /* Dummy return to make the compiler happy */
2086:../CX3RDKOV5640.c ****     return 0;
 3629              		.loc 1 2086 0
 3630 00c8 0030A0E3 		mov	r3, #0
 3631 00cc 000000EA 		b	.L200
 3632              	.L196:
2087:../CX3RDKOV5640.c **** 
2088:../CX3RDKOV5640.c **** handle_fatal_error:
2089:../CX3RDKOV5640.c ****     /* Cannot recover from this error. */
2090:../CX3RDKOV5640.c ****     while (1);
 3633              		.loc 1 2090 0 discriminator 1
 3634 00d0 FEFFFFEA 		b	.L196
 3635              	.L200:
2091:../CX3RDKOV5640.c **** }
 3636              		.loc 1 2091 0
 3637 00d4 0300A0E1 		mov	r0, r3
 3638 00d8 04D04BE2 		sub	sp, fp, #4
 3639              		@ sp needed
 3640 00dc 0088BDE8 		ldmfd	sp!, {fp, pc}
 3641              		.cfi_endproc
 3642              	.LFE15:
 3644              		.text
 3645              	.Letext0:
 3646              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 3647              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 3648              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyfx
 3649              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_p
 3650              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_a
 3651              		.file 7 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 3652              		.file 8 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 3653              		.file 9 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 3654              		.file 10 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 3655              		.file 11 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 3656              		.file 12 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 3657              		.file 13 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 3658              		.file 14 "../cmdqu.h"
 3659              		.file 15 "..\\..\\CX3OV5640LIB\\INC/CX3OV5640Lib.h"
 3660              		.file 16 "../CX3RDKOV5640.h"
DEFINED SYMBOLS
                            *ABS*:00000000 CX3RDKOV5640.c
                            *COM*:00000004 gl32SetControl
                            *COM*:00000002 gl16SetControl
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:19     .bss.glEp0Buffer:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:22     .bss.glEp0Buffer:00000000 glEp0Buffer
                            *COM*:000000a8 uvcAppThread
                            *COM*:000000a8 SenAppThread
                            *COM*:00000028 glTimerEvent
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 statQuMux
                            *COM*:00000038 timMux
                            *COM*:00000038 imgHdMux
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:34     .bss.UvcTimer:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:37     .bss.UvcTimer:00000000 UvcTimer
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:40     .text.UvcAppProgressTimer:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:42     .text.UvcAppProgressTimer:00000000 UvcAppProgressTimer
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:71     .text.UvcAppProgressTimer:00000028 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:80     .bss.glDMATxCount:00000000 glDMATxCount
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:77     .bss.glDMATxCount:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:87     .bss.glDmaDone:00000000 glDmaDone
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:84     .bss.glDmaDone:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:93     .bss.glActiveSocket:00000000 glActiveSocket
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:94     .bss.glActiveSocket:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:100    .data.doLpmDisable:00000000 doLpmDisable
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:97     .data.doLpmDisable:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:107    .bss.glHitFV:00000000 glHitFV
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:104    .bss.glHitFV:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:114    .bss.glMipiActive:00000000 glMipiActive
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:111    .bss.glMipiActive:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:121    .bss.glIsClearFeature:00000000 glIsClearFeature
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:118    .bss.glIsClearFeature:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:128    .bss.glPreviewStarted:00000000 glPreviewStarted
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:125    .bss.glPreviewStarted:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:135    .data.glUVCHeader:00000000 glUVCHeader
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:132    .data.glUVCHeader:00000000 $d
                            *COM*:00000020 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:153    .data.glCurrentFrameIndex:00000000 glCurrentFrameIndex
                            *COM*:00000020 glStillCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:160    .data.glCurrentStillFrameIndex:00000000 glCurrentStillFrameIndex
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:166    .bss.glStillTriggerCtrl:00000000 glStillTriggerCtrl
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:167    .bss.glStillTriggerCtrl:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:172    .bss.glFrameIndexToSet:00000000 glFrameIndexToSet
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:173    .bss.glFrameIndexToSet:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:179    .bss.glStillCaptureStart:00000000 glStillCaptureStart
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:176    .bss.glStillCaptureStart:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:186    .bss.glStillCaptured:00000000 glStillCaptured
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:183    .bss.glStillCaptured:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:192    .bss.glStillSkip:00000000 glStillSkip
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:193    .bss.glStillSkip:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:199    .bss.glIsApplnActive:00000000 glIsApplnActive
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:196    .bss.glIsApplnActive:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:206    .bss.glIsConfigured:00000000 glIsConfigured
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:203    .bss.glIsConfigured:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:213    .bss.glIsStreamingStarted:00000000 glIsStreamingStarted
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:210    .bss.glIsStreamingStarted:00000000 $d
                            *COM*:000000e8 glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:221    .bss.ES_UVC_STREAM_BUF_SIZE:00000000 ES_UVC_STREAM_BUF_SIZE
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:218    .bss.ES_UVC_STREAM_BUF_SIZE:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:228    .bss.ES_UVC_DATA_BUF_SIZE:00000000 ES_UVC_DATA_BUF_SIZE
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:225    .bss.ES_UVC_DATA_BUF_SIZE:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:234    .bss.ES_UVC_STREAM_BUF_COUNT:00000000 ES_UVC_STREAM_BUF_COUNT
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:235    .bss.ES_UVC_STREAM_BUF_COUNT:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:240    .data.g_IsAutoFocus:00000000 g_IsAutoFocus
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:246    .bss.glGet_Info:00000000 glGet_Info
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:247    .bss.glGet_Info:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:253    .bss.gl8GetControl:00000000 gl8GetControl
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:250    .bss.gl8GetControl:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:260    .bss.gl8SetControl:00000000 gl8SetControl
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:257    .bss.gl8SetControl:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:267    .bss.gl16GetControl:00000000 gl16GetControl
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:264    .bss.gl16GetControl:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:274    .bss.gl32GetControl:00000000 gl32GetControl
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:271    .bss.gl32GetControl:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:280    .bss.glcommitcount:00000000 glcommitcount
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:281    .bss.glcommitcount:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:286    .data.glcheckframe:00000000 glcheckframe
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:289    .text.esUVCAppErrorHandler:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:292    .text.esUVCAppErrorHandler:00000000 esUVCAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:318    .text.esUVCUvcAddHeader:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:320    .text.esUVCUvcAddHeader:00000000 esUVCUvcAddHeader
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:371    .text.esUVCUvcAddHeader:00000074 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:376    .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:383    .text.esUVCUvcApplnStart:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:386    .text.esUVCUvcApplnStart:00000000 esUVCUvcApplnStart
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:515    .text.esUVCUvcApplnStart:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:535    .text.esUVCUvcApplnStop:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:538    .text.esUVCUvcApplnStop:00000000 esUVCUvcApplnStop
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:639    .text.esUVCUvcApplnStop:000000f4 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:658    .text.esUVCGpifCB:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:661    .text.esUVCGpifCB:00000000 esUVCGpifCB
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:733    .text.esUVCGpifCB:000000ac $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:740    .text.esUVCUvcAppDmaCallback:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:743    .text.esUVCUvcAppDmaCallback:00000000 esUVCUvcAppDmaCallback
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:1050   .text.esUVCUvcAppDmaCallback:00000380 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:1070   .text.esUVCUvcApplnUSBEventCB:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:1072   .text.esUVCUvcApplnUSBEventCB:00000000 esUVCUvcApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:1102   .text.esUVCUvcApplnUSBEventCB:0000003c $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:1112   .text.esUVCUvcApplnUSBEventCB:0000005c $a
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:1234   .text.esUVCUvcApplnUSBEventCB:00000198 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:1245   .text.esUVCApplnLPMRqtCB:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:1247   .text.esUVCApplnLPMRqtCB:00000000 esUVCApplnLPMRqtCB
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:1292   .text.esSetCameraResolution:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:1295   .text.esSetCameraResolution:00000000 esSetCameraResolution
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:1468   .text.esSetCameraResolution:000001c4 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:1508   .text.esUVCUvcApplnUSBSetupCB:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:1510   .text.esUVCUvcApplnUSBSetupCB:00000000 esUVCUvcApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:2257   .text.esUVCUvcApplnUSBSetupCB:0000081c $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:2373   .text.esUVCUvcApplnInit:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:2376   .text.esUVCUvcApplnInit:00000000 esUVCUvcApplnInit
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:3070   .text.esUVCUvcApplnInit:000007a8 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:3147   .text.esUVCUvcApplnDebugInit:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:3150   .text.esUVCUvcApplnDebugInit:00000000 esUVCUvcApplnDebugInit
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:3257   .text.esUVCUvcApplnDebugInit:00000104 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:3266   .text.esUVCUvcAppThread_Entry:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:3269   .text.esUVCUvcAppThread_Entry:00000000 esUVCUvcAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:3357   .text.esUVCUvcAppThread_Entry:000000c8 $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:3381   .text.CyFxApplicationDefine:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:3384   .text.CyFxApplicationDefine:00000000 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:3524   .text.CyFxApplicationDefine:0000018c $d
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:3540   .text.main:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc0uywwB.s:3543   .text.main:00000000 main
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.29463082a45126943f020ea30bda05c8
                           .group:00000000 wm4.newlib.h.8.384a112feabb3bef7b573ae48cde2e3b
                           .group:00000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:00000000 wm4.config.h.219.8eb38badc3f446ace4f0fbbdc7b4e018
                           .group:00000000 wm4._ansi.h.23.5644b60c990a4800b02a6e654e88f93a
                           .group:00000000 wm4.stdint.h.20.54ad762faa59e3c05491630641c8d8bf
                           .group:00000000 wm4.cyu3types.h.80.f5310e165127de2daf78c334a454267e
                           .group:00000000 wm4.stdlib.h.18.8bab2fb43ac4e90235390733c30a4530
                           .group:00000000 wm4.stddef.h.184.aa65fb7281d578229bbad41b91862635
                           .group:00000000 wm4._default_types.h.6.5e12cd604db8ce00b62bb2f02708eaf3
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.59.db8450f33c1f6150c0372fa1091a887a
                           .group:00000000 wm4.stddef.h.348.9a99de77b6ba3b4278b57e9cc6d6e349
                           .group:00000000 wm4.reent.h.16.ec713094ff7b80200da61a1b94cca956
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.55.7091a050e07f1c4abd225630fe3d62f1
                           .group:00000000 wm4.stddef.h.39.d0197034aa5fd947cae140b9289e6734
                           .group:00000000 wm4.cdefs.h.56.efab90f4d89fbc41d6b3a5c5fb0d3d0f
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.string.h.126.6ff3aa59129e7f66b2c273baf353e066
                           .group:00000000 wm4.tx_port.h.95.54ef54ef950923016df123872c81f77f
                           .group:00000000 wm4.tx_api.h.90.d18ffa804751aa80b6d59c3d596c2234
                           .group:00000000 wm4.cyu3tx.h.61.421a5eac9b37f3e2677fcfe17ba1c9c3
                           .group:00000000 wm4.cyu3dma.h.569.521da17a880bb7dc9c063e240d18d9bc
                           .group:00000000 wm4.cyu3system.h.43.0fbd82548e591beefe95401c72410881
                           .group:00000000 wm4.cyu3usbconst.h.37.502980e110c2142a7316d50a53794397
                           .group:00000000 wm4.cyu3usb.h.302.ade7bb9b5b6e92c233eea1baf2851afa
                           .group:00000000 wm4.cyu3lpp.h.138.66435309bc2407b6684483dfed574450
                           .group:00000000 wm4.assert.h.11.060c3dc511517628fd4f958fa9448dce
                           .group:00000000 wm4.cyu3utils.h.45.ea1b88089ccad3d50489f6f768ad8e9f
                           .group:00000000 wm4.cyu3pib.h.192.a1483c513c81c352d6719814a4b66283
                           .group:00000000 wm4.cyu3descriptor.h.104.486178ff96f7d84792762d8905519d09
                           .group:00000000 wm4.cyu3socket.h.153.0d077cd39632ba9c913ec648cfa0f9e9
                           .group:00000000 wm4.sock_regs.h.24.15d70ab2b2a99b01b4189217fc091bd3
                           .group:00000000 wm4.cyu3sib.h.59.b1cff9a75023363cc612aef2b2314b23
                           .group:00000000 wm4.cyu3gpif.h.52.b01ef1bece12652336136a0aaabab45b
                           .group:00000000 wm4.cyu3mipicsi.h.46.b99df5b141b2543db3c56d6e408e0c5e
                           .group:00000000 wm4.CX3OV5640Lib.h.18.ebed1e57f77d2633a42de60cae388313
                           .group:00000000 wm4.cmdqu.h.19.d1373502bd3a7a56ccbd1736008f9f37
                           .group:00000000 wm4.CX3RDKOV5640.h.35.f7fe529c288b3942b3918d28808c5cde
                           .group:00000000 wm4.sensor.h.26.d38741ffaf0557280b1e48334d87d815
                           .group:00000000 wm4.uvc.h.35.a04ef8733ce74876578c7ba6b3d79b48

UNDEFINED SYMBOLS
_txe_event_flags_set
_tx_thread_sleep
CyU3PMemCopy
_txe_timer_deactivate
CyU3PUsbSetEpNak
CyFx3BusyWait
CyU3PUsbFlushEp
CyU3PDmaMultiChannelReset
CyU3PDebugPrint
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMControl
CyU3PGpifSMSwitch
CyU3PMipicsiWakeup
CyU3PMipicsiSleep
CyU3PUsbStall
CyU3PUsbLPMEnable
CyU3PDmaMultiChannelSetWrapUp
CyU3PUsbGetSpeed
CyU3PUsbLPMDisable
CyU3PUsbSetLinkPowerState
_txe_timer_activate
CyU3PDmaMultiChannelGetBuffer
CyU3PDmaMultiChannelCommitBuffer
_txe_timer_change
CyU3PMipicsiSetIntfParams
esOV5640_1080P_config
esOV5640_VGA_config
esOV5640_5MP_config
esOV5640_VGA_HS_config
cfgUvc1080p30NoMclk
cfgUvcVga30NoMclk
cfgUvc720p60NoMclk
cfgUvc5Mp15NoMclk
CyU3PUsbAckSetup
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
UVCHandleProcessingUnitRqts
UVCHandleExtensionUnitRqts
glProbeCtrl
gl5MpProbeCtrl
gl720pProbeCtrl
glVga60ProbeCtrl
gl1080pProbeCtrl
glVga30ProbeCtrl
glStillProbeCtrl
CyU3PMipicsiInitializeI2c
CyU3PMipicsiInitializeGPIO
CyU3PMipicsiInitializePIB
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbRegisterLPMRequestCallback
CyU3PUsbSetDesc
CyU3PUsbVBattEnable
CyU3PUsbControlVBusDetect
CyU3PConnectState
CyU3PSetEpConfig
CyU3PUsbEPSetBurstMode
CyU3PDmaMultiChannelCreate
CyU3PMipicsiGpifLoad
CyU3PGpifRegisterCallback
CyU3PGpifSMStart
CyU3PMipicsiInit
_txe_timer_create
esUVCUSB30DeviceDscr
esUVCUSB20DeviceDscr
esUVCUSBBOSDscr
esUVCUSBDeviceQualDscr
esUVCUSBSSConfigDscr
esUVCUSBHSConfigDscr
esUVCUSBFSConfigDscr
esUVCUSBStringLangIDDscr
esUVCUSBManufactureDscr
esUVCUSBProductDscr
esUVCUSBConfigSSDscr
esUVCUSBConfigHSDscr
esUVCUSBConfigFSDscr
cfgUvcVgaNoMclk
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
_txe_event_flags_get
cmdbufCreate
cmdquInit
CyU3PMemAlloc
_txe_thread_create
_txe_event_flags_create
SenAppThread_Entry
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
