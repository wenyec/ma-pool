   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"CX3RDKOV5640.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.section	.bss.glEp0Buffer,"aw",%nobits
  17              		.align	2
  20              	glEp0Buffer:
  21 0000 00000000 		.space	32
  21      00000000 
  21      00000000 
  21      00000000 
  21      00000000 
  22              		.comm	uvcAppThread,168,4
  23              		.comm	SenAppThread,168,4
  24              		.comm	glTimerEvent,40,4
  25              		.comm	cmdQu,32,4
  26              		.comm	statQu,32,4
  27              		.comm	cmdQuMux,56,4
  28              		.comm	statQuMux,56,4
  29              		.comm	timMux,56,4
  30              		.comm	imgHdMux,56,4
  31              		.section	.bss.UvcTimer,"aw",%nobits
  32              		.align	2
  35              	UvcTimer:
  36 0000 00000000 		.space	44
  36      00000000 
  36      00000000 
  36      00000000 
  36      00000000 
  37              		.section	.text.UvcAppProgressTimer,"ax",%progbits
  38              		.align	2
  40              	UvcAppProgressTimer:
  41              	.LFB0:
  42              		.file 1 "../CX3RDKOV5640.c"
   1:../CX3RDKOV5640.c **** /*
   2:../CX3RDKOV5640.c ****  ## e-con Systems USB UVC Stack – See3CAMCX3RDK Platform
   3:../CX3RDKOV5640.c **** 
   4:../CX3RDKOV5640.c ****  ## source file : CX3RDKOV5640.c
   5:../CX3RDKOV5640.c ****  ## ===========================
   6:../CX3RDKOV5640.c ****  ##
   7:../CX3RDKOV5640.c ****  ##  Copyright E-Con Systems, 2013-2014,
   8:../CX3RDKOV5640.c ****  ##  All Rights Reserved
   9:../CX3RDKOV5640.c ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
  10:../CX3RDKOV5640.c ****  ##
  11:../CX3RDKOV5640.c ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  12:../CX3RDKOV5640.c ****  ##  PROPERTY OF ECON SYSTEMS
  13:../CX3RDKOV5640.c **** 
  14:../CX3RDKOV5640.c ****  ## www.e-consystems.com
  15:../CX3RDKOV5640.c ****  ##
  16:../CX3RDKOV5640.c ****  ##
  17:../CX3RDKOV5640.c ****  ## ===========================
  18:../CX3RDKOV5640.c **** */
  19:../CX3RDKOV5640.c **** 
  20:../CX3RDKOV5640.c **** #include "cyu3system.h"
  21:../CX3RDKOV5640.c **** #include "cyu3os.h"
  22:../CX3RDKOV5640.c **** #include "cyu3dma.h"
  23:../CX3RDKOV5640.c **** #include "cyu3error.h"
  24:../CX3RDKOV5640.c **** #include "cyu3usb.h"
  25:../CX3RDKOV5640.c **** #include "cyu3i2c.h"
  26:../CX3RDKOV5640.c **** #include "cyu3uart.h"
  27:../CX3RDKOV5640.c **** #include "cyu3gpio.h"
  28:../CX3RDKOV5640.c **** #include "cyu3utils.h"
  29:../CX3RDKOV5640.c **** #include "cyu3pib.h"
  30:../CX3RDKOV5640.c **** #include "cyu3socket.h"
  31:../CX3RDKOV5640.c **** #include "sock_regs.h"
  32:../CX3RDKOV5640.c **** #include "cyu3mipicsi.h"
  33:../CX3RDKOV5640.c **** 
  34:../CX3RDKOV5640.c **** //#include "CX3OV5640Lib.h"
  35:../CX3RDKOV5640.c **** #include "CX3RDKOV5640.h"
  36:../CX3RDKOV5640.c **** #include "sensor.h"
  37:../CX3RDKOV5640.c **** #include "cmdqu.h"
  38:../CX3RDKOV5640.c **** #include "uvc.h"
  39:../CX3RDKOV5640.c **** 
  40:../CX3RDKOV5640.c **** /* Event generated on Timer overflow*/
  41:../CX3RDKOV5640.c **** #define ES_TIMER_RESET_EVENT		(1<<4)
  42:../CX3RDKOV5640.c **** 
  43:../CX3RDKOV5640.c **** /* Event generated on a USB Suspend Request*/
  44:../CX3RDKOV5640.c **** #define ES_USB_SUSP_EVENT_FLAG		(1<<5)
  45:../CX3RDKOV5640.c **** 
  46:../CX3RDKOV5640.c **** /* Firmware version*/
  47:../CX3RDKOV5640.c **** #define MajorVersion 				1
  48:../CX3RDKOV5640.c **** #define MinorVersion 				3
  49:../CX3RDKOV5640.c **** #define SubVersion					133
  50:../CX3RDKOV5640.c **** #define SubVersion1					309
  51:../CX3RDKOV5640.c **** #define RESET_TIMER_ENABLE 1
  52:../CX3RDKOV5640.c **** 
  53:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
  54:../CX3RDKOV5640.c **** #define TIMER_PERIOD	(500)
  55:../CX3RDKOV5640.c **** 
  56:../CX3RDKOV5640.c **** /****** for VIS debugging ******/
  57:../CX3RDKOV5640.c **** //#define VISDebug
  58:../CX3RDKOV5640.c **** 
  59:../CX3RDKOV5640.c **** /*************End***************/
  60:../CX3RDKOV5640.c **** 
  61:../CX3RDKOV5640.c **** /******* The Global Variables from FX3 code *******/
  62:../CX3RDKOV5640.c **** //VdRingBuf     cmdQu, statQu;
  63:../CX3RDKOV5640.c **** CyU3PMutex    cmdQuMux, statQuMux, timMux, imgHdMux;
  64:../CX3RDKOV5640.c **** 
  65:../CX3RDKOV5640.c **** /******************* End **************************/
  66:../CX3RDKOV5640.c **** 
  67:../CX3RDKOV5640.c **** static CyU3PTimer        UvcTimer;
  68:../CX3RDKOV5640.c **** 
  69:../CX3RDKOV5640.c **** static void UvcAppProgressTimer (uint32_t arg)
  70:../CX3RDKOV5640.c **** {
  43              		.loc 1 70 0
  44              		.cfi_startproc
  45              		@ args = 0, pretend = 0, frame = 8
  46              		@ frame_needed = 1, uses_anonymous_args = 0
  47 0000 00482DE9 		stmfd	sp!, {fp, lr}
  48              	.LCFI0:
  49              		.cfi_def_cfa_offset 8
  50              		.cfi_offset 11, -8
  51              		.cfi_offset 14, -4
  52 0004 04B08DE2 		add	fp, sp, #4
  53              	.LCFI1:
  54              		.cfi_def_cfa 11, 4
  55 0008 08D04DE2 		sub	sp, sp, #8
  56 000c 08000BE5 		str	r0, [fp, #-8]
  71:../CX3RDKOV5640.c ****     /* This frame has taken too long to complete.
  72:../CX3RDKOV5640.c ****      * Abort it, so that the next frame can be started. */
  73:../CX3RDKOV5640.c ****     CyU3PEventSet(&glTimerEvent, ES_TIMER_RESET_EVENT,CYU3P_EVENT_OR);
  57              		.loc 1 73 0
  58 0010 10009FE5 		ldr	r0, .L2
  59 0014 1010A0E3 		mov	r1, #16
  60 0018 0020A0E3 		mov	r2, #0
  61 001c FEFFFFEB 		bl	_txe_event_flags_set
  74:../CX3RDKOV5640.c **** }
  62              		.loc 1 74 0
  63 0020 04D04BE2 		sub	sp, fp, #4
  64              		@ sp needed
  65 0024 0088BDE8 		ldmfd	sp!, {fp, pc}
  66              	.L3:
  67              		.align	2
  68              	.L2:
  69 0028 00000000 		.word	glTimerEvent
  70              		.cfi_endproc
  71              	.LFE0:
  73              		.global	glDMATxCount
  74              		.section	.bss.glDMATxCount,"aw",%nobits
  75              		.align	2
  78              	glDMATxCount:
  79 0000 00000000 		.space	4
  80              		.global	glDmaDone
  81              		.section	.bss.glDmaDone,"aw",%nobits
  82              		.align	2
  85              	glDmaDone:
  86 0000 00000000 		.space	4
  87              		.global	glActiveSocket
  88              		.section	.bss.glActiveSocket,"aw",%nobits
  91              	glActiveSocket:
  92 0000 00       		.space	1
  93              		.global	doLpmDisable
  94              		.section	.data.doLpmDisable,"aw",%progbits
  95              		.align	2
  98              	doLpmDisable:
  99 0000 01000000 		.word	1
 100              		.global	glHitFV
 101              		.section	.bss.glHitFV,"aw",%nobits
 102              		.align	2
 105              	glHitFV:
 106 0000 00000000 		.space	4
 107              		.global	glMipiActive
 108              		.section	.bss.glMipiActive,"aw",%nobits
 109              		.align	2
 112              	glMipiActive:
 113 0000 00000000 		.space	4
 114              		.global	glIsClearFeature
 115              		.section	.bss.glIsClearFeature,"aw",%nobits
 116              		.align	2
 119              	glIsClearFeature:
 120 0000 00000000 		.space	4
 121              		.global	glPreviewStarted
 122              		.section	.bss.glPreviewStarted,"aw",%nobits
 123              		.align	2
 126              	glPreviewStarted:
 127 0000 00000000 		.space	4
 128              		.global	glUVCHeader
 129              		.section	.data.glUVCHeader,"aw",%progbits
 130              		.align	2
 133              	glUVCHeader:
 134 0000 0C       		.byte	12
 135 0001 8C       		.byte	-116
 136 0002 00       		.byte	0
 137 0003 00       		.byte	0
 138 0004 00       		.byte	0
 139 0005 00       		.byte	0
 140 0006 00       		.byte	0
 141 0007 00       		.byte	0
 142 0008 00       		.byte	0
 143 0009 00       		.byte	0
 144 000a 00       		.byte	0
 145 000b 00       		.byte	0
 146              		.comm	glCommitCtrl,32,4
 147              		.global	glCurrentFrameIndex
 148              		.section	.data.glCurrentFrameIndex,"aw",%progbits
 151              	glCurrentFrameIndex:
 152 0000 01       		.byte	1
 153              		.comm	glStillCommitCtrl,32,4
 154              		.global	glCurrentStillFrameIndex
 155              		.section	.data.glCurrentStillFrameIndex,"aw",%progbits
 158              	glCurrentStillFrameIndex:
 159 0000 01       		.byte	1
 160              		.global	glStillTriggerCtrl
 161              		.section	.bss.glStillTriggerCtrl,"aw",%nobits
 164              	glStillTriggerCtrl:
 165 0000 00       		.space	1
 166              		.global	glFrameIndexToSet
 167              		.section	.bss.glFrameIndexToSet,"aw",%nobits
 170              	glFrameIndexToSet:
 171 0000 00       		.space	1
 172              		.global	glStillCaptureStart
 173              		.section	.bss.glStillCaptureStart,"aw",%nobits
 174              		.align	2
 177              	glStillCaptureStart:
 178 0000 00000000 		.space	4
 179              		.global	glStillCaptured
 180              		.section	.bss.glStillCaptured,"aw",%nobits
 181              		.align	2
 184              	glStillCaptured:
 185 0000 00000000 		.space	4
 186              		.global	glStillSkip
 187              		.section	.bss.glStillSkip,"aw",%nobits
 190              	glStillSkip:
 191 0000 00       		.space	1
 192              		.global	glIsApplnActive
 193              		.section	.bss.glIsApplnActive,"aw",%nobits
 194              		.align	2
 197              	glIsApplnActive:
 198 0000 00000000 		.space	4
 199              		.global	glIsConfigured
 200              		.section	.bss.glIsConfigured,"aw",%nobits
 201              		.align	2
 204              	glIsConfigured:
 205 0000 00000000 		.space	4
 206              		.global	glIsStreamingStarted
 207              		.section	.bss.glIsStreamingStarted,"aw",%nobits
 208              		.align	2
 211              	glIsStreamingStarted:
 212 0000 00000000 		.space	4
 213              		.comm	glChHandleUVCStream,232,4
 214              		.global	ES_UVC_STREAM_BUF_SIZE
 215              		.section	.bss.ES_UVC_STREAM_BUF_SIZE,"aw",%nobits
 216              		.align	1
 219              	ES_UVC_STREAM_BUF_SIZE:
 220 0000 0000     		.space	2
 221              		.global	ES_UVC_DATA_BUF_SIZE
 222              		.section	.bss.ES_UVC_DATA_BUF_SIZE,"aw",%nobits
 223              		.align	1
 226              	ES_UVC_DATA_BUF_SIZE:
 227 0000 0000     		.space	2
 228              		.global	ES_UVC_STREAM_BUF_COUNT
 229              		.section	.bss.ES_UVC_STREAM_BUF_COUNT,"aw",%nobits
 232              	ES_UVC_STREAM_BUF_COUNT:
 233 0000 00       		.space	1
 234              		.global	g_IsAutoFocus
 235              		.section	.data.g_IsAutoFocus,"aw",%progbits
 238              	g_IsAutoFocus:
 239 0000 01       		.byte	1
 240              		.global	glGet_Info
 241              		.section	.bss.glGet_Info,"aw",%nobits
 244              	glGet_Info:
 245 0000 00       		.space	1
 246              		.global	gl8GetControl
 247              		.section	.bss.gl8GetControl,"aw",%nobits
 248              		.align	1
 251              	gl8GetControl:
 252 0000 0000     		.space	2
 253              		.global	gl8SetControl
 254              		.section	.bss.gl8SetControl,"aw",%nobits
 255              		.align	1
 258              	gl8SetControl:
 259 0000 0000     		.space	2
 260              		.global	gl16GetControl
 261              		.section	.bss.gl16GetControl,"aw",%nobits
 262              		.align	1
 265              	gl16GetControl:
 266 0000 0000     		.space	2
 267              		.global	gl32GetControl
 268              		.section	.bss.gl32GetControl,"aw",%nobits
 269              		.align	2
 272              	gl32GetControl:
 273 0000 00000000 		.space	4
 274              		.global	glcommitcount
 275              		.section	.bss.glcommitcount,"aw",%nobits
 278              	glcommitcount:
 279 0000 00       		.space	1
 280              		.global	glcheckframe
 281              		.section	.data.glcheckframe,"aw",%progbits
 284              	glcheckframe:
 285 0000 01       		.byte	1
 286              		.section	.text.esUVCAppErrorHandler,"ax",%progbits
 287              		.align	2
 288              		.global	esUVCAppErrorHandler
 290              	esUVCAppErrorHandler:
 291              	.LFB1:
  75:../CX3RDKOV5640.c **** #endif
  76:../CX3RDKOV5640.c **** 
  77:../CX3RDKOV5640.c **** volatile int32_t glDMATxCount = 0;          /* Counter used to count the Dma Transfers */
  78:../CX3RDKOV5640.c **** volatile int32_t glDmaDone = 0;
  79:../CX3RDKOV5640.c **** volatile uint8_t glActiveSocket = 0;
  80:../CX3RDKOV5640.c **** volatile CyBool_t doLpmDisable = CyTrue;	/* Flag used to Enable/Disable low USB 3.0 LPM */
  81:../CX3RDKOV5640.c **** CyBool_t glHitFV = CyFalse;             	/* Flag used for state of FV signal. */
  82:../CX3RDKOV5640.c **** CyBool_t glMipiActive = CyFalse;        	/* Flag set to true when Mipi interface is active. Used fo
  83:../CX3RDKOV5640.c **** CyBool_t glIsClearFeature = CyFalse;    	/* Flag to signal when AppStop is called from the ClearFea
  84:../CX3RDKOV5640.c **** CyBool_t glPreviewStarted = CyFalse;		/* Flag to support Mac os */
  85:../CX3RDKOV5640.c **** 
  86:../CX3RDKOV5640.c **** /* UVC Header */
  87:../CX3RDKOV5640.c **** uint8_t glUVCHeader[ES_UVC_HEADER_LENGTH] =
  88:../CX3RDKOV5640.c **** {
  89:../CX3RDKOV5640.c ****     0x0C,                           /* Header Length */
  90:../CX3RDKOV5640.c ****     0x8C,                           /* Bit field header field */
  91:../CX3RDKOV5640.c ****     0x00,0x00,0x00,0x00,            /* Presentation time stamp field */
  92:../CX3RDKOV5640.c ****     0x00,0x00,0x00,0x00,0x00,0x00   /* Source clock reference field */
  93:../CX3RDKOV5640.c **** };
  94:../CX3RDKOV5640.c **** 
  95:../CX3RDKOV5640.c **** /* Video Probe Commit Control */
  96:../CX3RDKOV5640.c **** uint8_t glCommitCtrl[ES_UVC_MAX_PROBE_SETTING_ALIGNED];
  97:../CX3RDKOV5640.c **** uint8_t glCurrentFrameIndex = 1;
  98:../CX3RDKOV5640.c **** uint8_t glStillCommitCtrl[ES_UVC_MAX_STILL_PROBE_SETTING_ALIGNED];
  99:../CX3RDKOV5640.c **** uint8_t glCurrentStillFrameIndex = 1;
 100:../CX3RDKOV5640.c **** uint8_t glStillTriggerCtrl = 0;
 101:../CX3RDKOV5640.c **** uint8_t glFrameIndexToSet = 0;
 102:../CX3RDKOV5640.c **** CyBool_t glStillCaptureStart = CyFalse;
 103:../CX3RDKOV5640.c **** CyBool_t glStillCaptured = CyFalse;
 104:../CX3RDKOV5640.c **** uint8_t glStillSkip = 0;
 105:../CX3RDKOV5640.c **** 
 106:../CX3RDKOV5640.c **** CyBool_t glIsApplnActive = CyFalse;             /* Whether the Mipi->USB application is active or n
 107:../CX3RDKOV5640.c **** CyBool_t glIsConfigured = CyFalse;              /* Whether Application is in configured state or no
 108:../CX3RDKOV5640.c **** CyBool_t glIsStreamingStarted = CyFalse;        /* Whether streaming has started - Used for MAC OS 
 109:../CX3RDKOV5640.c **** 
 110:../CX3RDKOV5640.c **** /* DMA Channel */
 111:../CX3RDKOV5640.c **** CyU3PDmaMultiChannel glChHandleUVCStream;       /* DMA Channel Handle for UVC Stream  */
 112:../CX3RDKOV5640.c **** uint16_t ES_UVC_STREAM_BUF_SIZE=0;
 113:../CX3RDKOV5640.c **** uint16_t ES_UVC_DATA_BUF_SIZE=0;
 114:../CX3RDKOV5640.c **** uint8_t ES_UVC_STREAM_BUF_COUNT=0;
 115:../CX3RDKOV5640.c **** 
 116:../CX3RDKOV5640.c **** uint8_t g_IsAutoFocus=1;						/* Check the AutoFocus is Enabled or not*/
 117:../CX3RDKOV5640.c **** 
 118:../CX3RDKOV5640.c **** /* USB control request processing variables*/
 119:../CX3RDKOV5640.c **** #if 1
 120:../CX3RDKOV5640.c **** 
 121:../CX3RDKOV5640.c **** uint8_t glGet_Info = 0;
 122:../CX3RDKOV5640.c **** int16_t gl8GetControl = 0;
 123:../CX3RDKOV5640.c **** int16_t gl8SetControl = 0;
 124:../CX3RDKOV5640.c **** int16_t gl16GetControl = 0;
 125:../CX3RDKOV5640.c **** 
 126:../CX3RDKOV5640.c **** int32_t gl32GetControl = 0;
 127:../CX3RDKOV5640.c **** 
 128:../CX3RDKOV5640.c **** #endif
 129:../CX3RDKOV5640.c **** 
 130:../CX3RDKOV5640.c **** uint8_t glcommitcount=0,glcheckframe=1;
 131:../CX3RDKOV5640.c **** 
 132:../CX3RDKOV5640.c **** /* Application critical error handler */
 133:../CX3RDKOV5640.c ****     void
 134:../CX3RDKOV5640.c **** esUVCAppErrorHandler (
 135:../CX3RDKOV5640.c ****         CyU3PReturnStatus_t status        /* API return status */
 136:../CX3RDKOV5640.c ****         )
 137:../CX3RDKOV5640.c **** {
 292              		.loc 1 137 0
 293              		.cfi_startproc
 294              		@ args = 0, pretend = 0, frame = 8
 295              		@ frame_needed = 1, uses_anonymous_args = 0
 296 0000 00482DE9 		stmfd	sp!, {fp, lr}
 297              	.LCFI2:
 298              		.cfi_def_cfa_offset 8
 299              		.cfi_offset 11, -8
 300              		.cfi_offset 14, -4
 301 0004 04B08DE2 		add	fp, sp, #4
 302              	.LCFI3:
 303              		.cfi_def_cfa 11, 4
 304 0008 08D04DE2 		sub	sp, sp, #8
 305 000c 08000BE5 		str	r0, [fp, #-8]
 306              	.L5:
 138:../CX3RDKOV5640.c ****     /* Application failed with the error code status */
 139:../CX3RDKOV5640.c **** 
 140:../CX3RDKOV5640.c ****     /* Add custom debug or recovery actions here */
 141:../CX3RDKOV5640.c **** 
 142:../CX3RDKOV5640.c ****     /* Loop indefinitely */
 143:../CX3RDKOV5640.c ****     for (;;)
 144:../CX3RDKOV5640.c ****     {
 145:../CX3RDKOV5640.c ****         /* Thread sleep : 100 ms */
 146:../CX3RDKOV5640.c ****         CyU3PThreadSleep (100);
 307              		.loc 1 146 0 discriminator 1
 308 0010 6400A0E3 		mov	r0, #100
 309 0014 FEFFFFEB 		bl	_tx_thread_sleep
 147:../CX3RDKOV5640.c ****     }
 310              		.loc 1 147 0 discriminator 1
 311 0018 FCFFFFEA 		b	.L5
 312              		.cfi_endproc
 313              	.LFE1:
 315              		.section	.text.esUVCUvcAddHeader,"ax",%progbits
 316              		.align	2
 318              	esUVCUvcAddHeader:
 319              	.LFB2:
 148:../CX3RDKOV5640.c **** }
 149:../CX3RDKOV5640.c **** 
 150:../CX3RDKOV5640.c **** 
 151:../CX3RDKOV5640.c **** /* UVC header addition function */
 152:../CX3RDKOV5640.c ****     static void
 153:../CX3RDKOV5640.c **** esUVCUvcAddHeader (
 154:../CX3RDKOV5640.c ****         uint8_t *buffer_p,      /* Buffer pointer */
 155:../CX3RDKOV5640.c ****         uint8_t frameInd        /* EOF or normal frame indication */
 156:../CX3RDKOV5640.c ****         )
 157:../CX3RDKOV5640.c **** {
 320              		.loc 1 157 0
 321              		.cfi_startproc
 322              		@ args = 0, pretend = 0, frame = 8
 323              		@ frame_needed = 1, uses_anonymous_args = 0
 324 0000 00482DE9 		stmfd	sp!, {fp, lr}
 325              	.LCFI4:
 326              		.cfi_def_cfa_offset 8
 327              		.cfi_offset 11, -8
 328              		.cfi_offset 14, -4
 329 0004 04B08DE2 		add	fp, sp, #4
 330              	.LCFI5:
 331              		.cfi_def_cfa 11, 4
 332 0008 08D04DE2 		sub	sp, sp, #8
 333 000c 08000BE5 		str	r0, [fp, #-8]
 334 0010 0130A0E1 		mov	r3, r1
 335 0014 09304BE5 		strb	r3, [fp, #-9]
 158:../CX3RDKOV5640.c ****     /* Copy header to buffer */
 159:../CX3RDKOV5640.c ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, ES_UVC_HEADER_LENGTH);
 336              		.loc 1 159 0
 337 0018 08001BE5 		ldr	r0, [fp, #-8]
 338 001c 50109FE5 		ldr	r1, .L8
 339 0020 0C20A0E3 		mov	r2, #12
 340 0024 FEFFFFEB 		bl	CyU3PMemCopy
 160:../CX3RDKOV5640.c **** 
 161:../CX3RDKOV5640.c ****     /* Check if last packet of the frame. */
 162:../CX3RDKOV5640.c ****     if (frameInd == ES_UVC_HEADER_EOF)
 341              		.loc 1 162 0
 342 0028 09305BE5 		ldrb	r3, [fp, #-9]	@ zero_extendqisi2
 343 002c 020053E3 		cmp	r3, #2
 344 0030 0D00001A 		bne	.L6
 163:../CX3RDKOV5640.c ****     {
 164:../CX3RDKOV5640.c ****         /* Modify UVC header to toggle Frame ID */
 165:../CX3RDKOV5640.c ****         glUVCHeader[1] ^= ES_UVC_HEADER_FRAME_ID;
 345              		.loc 1 165 0
 346 0034 38309FE5 		ldr	r3, .L8
 347 0038 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 348 003c 013023E2 		eor	r3, r3, #1
 349 0040 FF2003E2 		and	r2, r3, #255
 350 0044 28309FE5 		ldr	r3, .L8
 351 0048 0120C3E5 		strb	r2, [r3, #1]
 166:../CX3RDKOV5640.c **** 
 167:../CX3RDKOV5640.c ****         /* Indicate End of Frame in the buffer */
 168:../CX3RDKOV5640.c ****         buffer_p[1] |=  ES_UVC_HEADER_EOF;
 352              		.loc 1 168 0
 353 004c 08301BE5 		ldr	r3, [fp, #-8]
 354 0050 013083E2 		add	r3, r3, #1
 355 0054 08201BE5 		ldr	r2, [fp, #-8]
 356 0058 012082E2 		add	r2, r2, #1
 357 005c 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 358 0060 022082E3 		orr	r2, r2, #2
 359 0064 FF2002E2 		and	r2, r2, #255
 360 0068 0020C3E5 		strb	r2, [r3]
 361              	.L6:
 169:../CX3RDKOV5640.c ****     }
 170:../CX3RDKOV5640.c **** }
 362              		.loc 1 170 0
 363 006c 04D04BE2 		sub	sp, fp, #4
 364              		@ sp needed
 365 0070 0088BDE8 		ldmfd	sp!, {fp, pc}
 366              	.L9:
 367              		.align	2
 368              	.L8:
 369 0074 00000000 		.word	glUVCHeader
 370              		.cfi_endproc
 371              	.LFE2:
 373              		.section	.rodata
 374              		.align	2
 375              	.LC0:
 376 0000 0A0D4170 		.ascii	"\012\015AplnStrt:ChannelReset Err = 0x%x\000"
 376      6C6E5374 
 376      72743A43 
 376      68616E6E 
 376      656C5265 
 377 0023 00       		.align	2
 378              	.LC1:
 379 0024 0A0D4170 		.ascii	"\012\015AplnStrt:SetXfer Err = 0x%x\000"
 379      6C6E5374 
 379      72743A53 
 379      65745866 
 379      65722045 
 380              		.section	.text.esUVCUvcApplnStart,"ax",%progbits
 381              		.align	2
 382              		.global	esUVCUvcApplnStart
 384              	esUVCUvcApplnStart:
 385              	.LFB3:
 171:../CX3RDKOV5640.c **** 
 172:../CX3RDKOV5640.c **** 
 173:../CX3RDKOV5640.c **** /* This function starts the video streaming application. It is called
 174:../CX3RDKOV5640.c ****  * when there is a SET_INTERFACE event for alternate interface 1
 175:../CX3RDKOV5640.c ****  * (in case of UVC over Isochronous Endpoint usage) or when a
 176:../CX3RDKOV5640.c ****  * COMMIT_CONTROL(SET_CUR) request is received (when using BULK only UVC).
 177:../CX3RDKOV5640.c ****  */
 178:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t
 179:../CX3RDKOV5640.c **** esUVCUvcApplnStart (void)
 180:../CX3RDKOV5640.c **** {
 386              		.loc 1 180 0
 387              		.cfi_startproc
 388              		@ args = 0, pretend = 0, frame = 8
 389              		@ frame_needed = 1, uses_anonymous_args = 0
 390 0000 00482DE9 		stmfd	sp!, {fp, lr}
 391              	.LCFI6:
 392              		.cfi_def_cfa_offset 8
 393              		.cfi_offset 11, -8
 394              		.cfi_offset 14, -4
 395 0004 04B08DE2 		add	fp, sp, #4
 396              	.LCFI7:
 397              		.cfi_def_cfa 11, 4
 398 0008 10D04DE2 		sub	sp, sp, #16
 181:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 399              		.loc 1 181 0
 400 000c 0030A0E3 		mov	r3, #0
 401 0010 08300BE5 		str	r3, [fp, #-8]
 182:../CX3RDKOV5640.c **** 
 183:../CX3RDKOV5640.c ****     glIsApplnActive = CyTrue;
 402              		.loc 1 183 0
 403 0014 2C319FE5 		ldr	r3, .L14
 404 0018 0120A0E3 		mov	r2, #1
 405 001c 002083E5 		str	r2, [r3]
 184:../CX3RDKOV5640.c ****     glDmaDone = 0;
 406              		.loc 1 184 0
 407 0020 24319FE5 		ldr	r3, .L14+4
 408 0024 0020A0E3 		mov	r2, #0
 409 0028 002083E5 		str	r2, [r3]
 185:../CX3RDKOV5640.c ****     glDMATxCount = 0;
 410              		.loc 1 185 0
 411 002c 1C319FE5 		ldr	r3, .L14+8
 412 0030 0020A0E3 		mov	r2, #0
 413 0034 002083E5 		str	r2, [r3]
 186:../CX3RDKOV5640.c ****     glHitFV = CyFalse;
 414              		.loc 1 186 0
 415 0038 14319FE5 		ldr	r3, .L14+12
 416 003c 0020A0E3 		mov	r2, #0
 417 0040 002083E5 		str	r2, [r3]
 187:../CX3RDKOV5640.c ****     doLpmDisable = CyTrue;
 418              		.loc 1 187 0
 419 0044 0C319FE5 		ldr	r3, .L14+16
 420 0048 0120A0E3 		mov	r2, #1
 421 004c 002083E5 		str	r2, [r3]
 188:../CX3RDKOV5640.c **** 
 189:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
 190:../CX3RDKOV5640.c ****     CyU3PTimerStop (&UvcTimer);
 422              		.loc 1 190 0
 423 0050 04019FE5 		ldr	r0, .L14+20
 424 0054 FEFFFFEB 		bl	_txe_timer_deactivate
 191:../CX3RDKOV5640.c **** #endif
 192:../CX3RDKOV5640.c **** 
 193:../CX3RDKOV5640.c **** 
 194:../CX3RDKOV5640.c ****     /* Place the EP in NAK mode before cleaning up the pipe. */
 195:../CX3RDKOV5640.c ****     CyU3PUsbSetEpNak (ES_UVC_EP_BULK_VIDEO, CyTrue);
 425              		.loc 1 195 0
 426 0058 8300A0E3 		mov	r0, #131
 427 005c 0110A0E3 		mov	r1, #1
 428 0060 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 196:../CX3RDKOV5640.c ****     CyU3PBusyWait (100);
 429              		.loc 1 196 0
 430 0064 6400A0E3 		mov	r0, #100
 431 0068 FEFFFFEB 		bl	CyFx3BusyWait
 197:../CX3RDKOV5640.c **** 
 198:../CX3RDKOV5640.c ****     /* Reset USB EP and DMA */
 199:../CX3RDKOV5640.c ****     CyU3PUsbFlushEp(ES_UVC_EP_BULK_VIDEO);
 432              		.loc 1 199 0
 433 006c 8300A0E3 		mov	r0, #131
 434 0070 FEFFFFEB 		bl	CyU3PUsbFlushEp
 200:../CX3RDKOV5640.c ****     status = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 435              		.loc 1 200 0
 436 0074 E4009FE5 		ldr	r0, .L14+24
 437 0078 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 438 007c 08000BE5 		str	r0, [fp, #-8]
 201:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 439              		.loc 1 201 0
 440 0080 08301BE5 		ldr	r3, [fp, #-8]
 441 0084 000053E3 		cmp	r3, #0
 442 0088 0500000A 		beq	.L11
 202:../CX3RDKOV5640.c ****     {
 203:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4,"\n\rAplnStrt:ChannelReset Err = 0x%x", status);
 443              		.loc 1 203 0
 444 008c 0400A0E3 		mov	r0, #4
 445 0090 CC109FE5 		ldr	r1, .L14+28
 446 0094 08201BE5 		ldr	r2, [fp, #-8]
 447 0098 FEFFFFEB 		bl	CyU3PDebugPrint
 204:../CX3RDKOV5640.c ****         return status;
 448              		.loc 1 204 0
 449 009c 08301BE5 		ldr	r3, [fp, #-8]
 450 00a0 250000EA 		b	.L12
 451              	.L11:
 205:../CX3RDKOV5640.c ****     }
 206:../CX3RDKOV5640.c **** 
 207:../CX3RDKOV5640.c ****     status = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 452              		.loc 1 207 0
 453 00a4 B4009FE5 		ldr	r0, .L14+24
 454 00a8 0010A0E3 		mov	r1, #0
 455 00ac 0020A0E3 		mov	r2, #0
 456 00b0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 457 00b4 08000BE5 		str	r0, [fp, #-8]
 208:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 458              		.loc 1 208 0
 459 00b8 08301BE5 		ldr	r3, [fp, #-8]
 460 00bc 000053E3 		cmp	r3, #0
 461 00c0 0500000A 		beq	.L13
 209:../CX3RDKOV5640.c ****     {
 210:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAplnStrt:SetXfer Err = 0x%x", status);
 462              		.loc 1 210 0
 463 00c4 0400A0E3 		mov	r0, #4
 464 00c8 98109FE5 		ldr	r1, .L14+32
 465 00cc 08201BE5 		ldr	r2, [fp, #-8]
 466 00d0 FEFFFFEB 		bl	CyU3PDebugPrint
 211:../CX3RDKOV5640.c ****         return status;
 467              		.loc 1 211 0
 468 00d4 08301BE5 		ldr	r3, [fp, #-8]
 469 00d8 170000EA 		b	.L12
 470              	.L13:
 212:../CX3RDKOV5640.c ****     }
 213:../CX3RDKOV5640.c **** 
 214:../CX3RDKOV5640.c ****     CyU3PUsbSetEpNak (ES_UVC_EP_BULK_VIDEO, CyFalse);
 471              		.loc 1 214 0
 472 00dc 8300A0E3 		mov	r0, #131
 473 00e0 0010A0E3 		mov	r1, #0
 474 00e4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 215:../CX3RDKOV5640.c ****     CyU3PBusyWait (200);
 475              		.loc 1 215 0
 476 00e8 C800A0E3 		mov	r0, #200
 477 00ec FEFFFFEB 		bl	CyFx3BusyWait
 216:../CX3RDKOV5640.c **** //
 217:../CX3RDKOV5640.c **** //    /* Place the EP in NAK mode before cleaning up the pipe. */
 218:../CX3RDKOV5640.c **** //    CyU3PUsbSetEpNak (ES_UVC_EP_BULK_VIDEO, CyTrue);
 219:../CX3RDKOV5640.c **** //    CyU3PBusyWait (100);
 220:../CX3RDKOV5640.c **** //
 221:../CX3RDKOV5640.c **** //    /* Reset USB EP and DMA */
 222:../CX3RDKOV5640.c **** //    CyU3PUsbFlushEp(ES_UVC_EP_BULK_VIDEO);
 223:../CX3RDKOV5640.c **** //    status = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 224:../CX3RDKOV5640.c **** //    if (status != CY_U3P_SUCCESS)
 225:../CX3RDKOV5640.c **** //    {
 226:../CX3RDKOV5640.c **** //        CyU3PDebugPrint (4,"\n\rAplnStrt:ChannelReset Err = 0x%x", status);
 227:../CX3RDKOV5640.c **** //        return status;
 228:../CX3RDKOV5640.c **** //    }
 229:../CX3RDKOV5640.c **** //    status = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 230:../CX3RDKOV5640.c **** //    if (status != CY_U3P_SUCCESS)
 231:../CX3RDKOV5640.c **** //    {
 232:../CX3RDKOV5640.c **** //        CyU3PDebugPrint (4, "\n\rAplnStrt:SetXfer Err = 0x%x", status);
 233:../CX3RDKOV5640.c **** //        return status;
 234:../CX3RDKOV5640.c **** //    }
 235:../CX3RDKOV5640.c **** //    CyU3PUsbSetEpNak (ES_UVC_EP_BULK_VIDEO, CyFalse);
 236:../CX3RDKOV5640.c **** //    CyU3PBusyWait (200);
 237:../CX3RDKOV5640.c **** 
 238:../CX3RDKOV5640.c **** 	 /* Night Mode function
 239:../CX3RDKOV5640.c **** 	 *  --------------------
 240:../CX3RDKOV5640.c **** 	 *  esOV5640_Nightmode API is used to enable the Nightmode
 241:../CX3RDKOV5640.c **** 	 *  of OV5640 sensor.
 242:../CX3RDKOV5640.c **** 	 *  Set Enable -- Cytrue to enable Nightmode
 243:../CX3RDKOV5640.c **** 	 * 				  CyFalse to Disable Nightmode
 244:../CX3RDKOV5640.c **** 	 *
 245:../CX3RDKOV5640.c **** 	 *  Set NightMode_option -- 1 to 6 to set different night modes
 246:../CX3RDKOV5640.c **** 	 *
 247:../CX3RDKOV5640.c **** 	 * To test different night modes, uncomment the below statement and build the firmware
 248:../CX3RDKOV5640.c **** 	 */
 249:../CX3RDKOV5640.c ****     //TODO Change this Function to "Sensor Specific" Nightmode Function to enable the nightmode(If 
 250:../CX3RDKOV5640.c **** 	/*esOV5640_Nightmode(CyTrue,3);*/
 251:../CX3RDKOV5640.c **** 
 252:../CX3RDKOV5640.c **** 
 253:../CX3RDKOV5640.c ****     /* Resume the Fixed Function GPIF State machine */
 254:../CX3RDKOV5640.c ****     CyU3PGpifSMControl(CyFalse);
 478              		.loc 1 254 0
 479 00f0 0000A0E3 		mov	r0, #0
 480 00f4 FEFFFFEB 		bl	CyU3PGpifSMControl
 255:../CX3RDKOV5640.c **** 
 256:../CX3RDKOV5640.c ****     glActiveSocket = 0;
 481              		.loc 1 256 0
 482 00f8 6C309FE5 		ldr	r3, .L14+36
 483 00fc 0020A0E3 		mov	r2, #0
 484 0100 0020C3E5 		strb	r2, [r3]
 257:../CX3RDKOV5640.c ****     CyU3PGpifSMSwitch(ES_UVC_INVALID_GPIF_STATE, CX3_START_SCK0,
 485              		.loc 1 257 0
 486 0104 0230A0E3 		mov	r3, #2
 487 0108 00308DE5 		str	r3, [sp]
 488 010c 5C009FE5 		ldr	r0, .L14+40
 489 0110 0010A0E3 		mov	r1, #0
 490 0114 54209FE5 		ldr	r2, .L14+40
 491 0118 0030A0E3 		mov	r3, #0
 492 011c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 258:../CX3RDKOV5640.c ****     		ES_UVC_INVALID_GPIF_STATE, ALPHA_CX3_START_SCK0, ES_UVC_GPIF_SWITCH_TIMEOUT);
 259:../CX3RDKOV5640.c **** 
 260:../CX3RDKOV5640.c ****     CyU3PThreadSleep(10);
 493              		.loc 1 260 0
 494 0120 0A00A0E3 		mov	r0, #10
 495 0124 FEFFFFEB 		bl	_tx_thread_sleep
 261:../CX3RDKOV5640.c **** 
 262:../CX3RDKOV5640.c ****     /* Wake Mipi interface and Image Sensor */
 263:../CX3RDKOV5640.c ****     CyU3PMipicsiWakeup();
 496              		.loc 1 263 0
 497 0128 FEFFFFEB 		bl	CyU3PMipicsiWakeup
 264:../CX3RDKOV5640.c **** 
 265:../CX3RDKOV5640.c ****     //TODO Change this function with "Sensor Specific" PowerUp function to PowerUp the sensor
 266:../CX3RDKOV5640.c ****     //esCamera_Power_Up();  // remove the camera operations function for VIS mipi camera test -wche
 267:../CX3RDKOV5640.c **** 
 268:../CX3RDKOV5640.c ****     glMipiActive = CyTrue;
 498              		.loc 1 268 0
 499 012c 40309FE5 		ldr	r3, .L14+44
 500 0130 0120A0E3 		mov	r2, #1
 501 0134 002083E5 		str	r2, [r3]
 269:../CX3RDKOV5640.c **** 
 270:../CX3RDKOV5640.c ****     //TODO Change this Function with "Sensor Specific" AutoFocus Function to Set the AutoFocus of t
 271:../CX3RDKOV5640.c **** 	if(glStillCaptureStart!= CyTrue)
 272:../CX3RDKOV5640.c **** 	{
 273:../CX3RDKOV5640.c **** 		if(0&&g_IsAutoFocus)// disable the auto focus for VIS camera. -wcheng
 274:../CX3RDKOV5640.c **** 			;//esOV5640_SetAutofocus(g_IsAutoFocus);
 275:../CX3RDKOV5640.c **** 	}
 276:../CX3RDKOV5640.c ****     return CY_U3P_SUCCESS;
 502              		.loc 1 276 0
 503 0138 0030A0E3 		mov	r3, #0
 504              	.L12:
 277:../CX3RDKOV5640.c **** }
 505              		.loc 1 277 0
 506 013c 0300A0E1 		mov	r0, r3
 507 0140 04D04BE2 		sub	sp, fp, #4
 508              		@ sp needed
 509 0144 0088BDE8 		ldmfd	sp!, {fp, pc}
 510              	.L15:
 511              		.align	2
 512              	.L14:
 513 0148 00000000 		.word	glIsApplnActive
 514 014c 00000000 		.word	glDmaDone
 515 0150 00000000 		.word	glDMATxCount
 516 0154 00000000 		.word	glHitFV
 517 0158 00000000 		.word	doLpmDisable
 518 015c 00000000 		.word	UvcTimer
 519 0160 00000000 		.word	glChHandleUVCStream
 520 0164 00000000 		.word	.LC0
 521 0168 24000000 		.word	.LC1
 522 016c 00000000 		.word	glActiveSocket
 523 0170 01010000 		.word	257
 524 0174 00000000 		.word	glMipiActive
 525              		.cfi_endproc
 526              	.LFE3:
 528              		.section	.rodata
 529 0042 0000     		.align	2
 530              	.LC2:
 531 0044 0A0D4170 		.ascii	"\012\015AplnStop:ChannelReset Err = 0x%x\000"
 531      6C6E5374 
 531      6F703A43 
 531      68616E6E 
 531      656C5265 
 532              		.section	.text.esUVCUvcApplnStop,"ax",%progbits
 533              		.align	2
 534              		.global	esUVCUvcApplnStop
 536              	esUVCUvcApplnStop:
 537              	.LFB4:
 278:../CX3RDKOV5640.c **** 
 279:../CX3RDKOV5640.c **** /* This function stops the video streaming. It is called from the USB event
 280:../CX3RDKOV5640.c ****  * handler, when there is a reset / disconnect or SET_INTERFACE for alternate
 281:../CX3RDKOV5640.c ****  * interface 0 in case of ischronous implementation or when a Clear Feature (Halt)
 282:../CX3RDKOV5640.c ****  * request is received (in case of bulk only implementation).
 283:../CX3RDKOV5640.c ****  */
 284:../CX3RDKOV5640.c ****     void
 285:../CX3RDKOV5640.c **** esUVCUvcApplnStop(void)
 286:../CX3RDKOV5640.c **** {
 538              		.loc 1 286 0
 539              		.cfi_startproc
 540              		@ args = 0, pretend = 0, frame = 8
 541              		@ frame_needed = 1, uses_anonymous_args = 0
 542 0000 00482DE9 		stmfd	sp!, {fp, lr}
 543              	.LCFI8:
 544              		.cfi_def_cfa_offset 8
 545              		.cfi_offset 11, -8
 546              		.cfi_offset 14, -4
 547 0004 04B08DE2 		add	fp, sp, #4
 548              	.LCFI9:
 549              		.cfi_def_cfa 11, 4
 550 0008 08D04DE2 		sub	sp, sp, #8
 287:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 551              		.loc 1 287 0
 552 000c 0030A0E3 		mov	r3, #0
 553 0010 08300BE5 		str	r3, [fp, #-8]
 288:../CX3RDKOV5640.c **** 
 289:../CX3RDKOV5640.c ****     /* Update the flag so that the application thread is notified of this. */
 290:../CX3RDKOV5640.c ****     glIsApplnActive = CyFalse;
 554              		.loc 1 290 0
 555 0014 D8309FE5 		ldr	r3, .L19
 556 0018 0020A0E3 		mov	r2, #0
 557 001c 002083E5 		str	r2, [r3]
 291:../CX3RDKOV5640.c **** 
 292:../CX3RDKOV5640.c ****     /* Stop the image sensor and CX3 mipi interface */
 293:../CX3RDKOV5640.c ****     status = CyU3PMipicsiSleep();
 558              		.loc 1 293 0
 559 0020 FEFFFFEB 		bl	CyU3PMipicsiSleep
 560 0024 08000BE5 		str	r0, [fp, #-8]
 294:../CX3RDKOV5640.c **** 
 295:../CX3RDKOV5640.c ****     //TODO Change this function with "Sensor Specific" PowerDown function to PowerDown the sensor
 296:../CX3RDKOV5640.c ****     //esCamera_Power_Down();  // remove the camera operations function for VIS mipi camera test -wc
 297:../CX3RDKOV5640.c **** 
 298:../CX3RDKOV5640.c ****     glMipiActive = CyFalse;
 561              		.loc 1 298 0
 562 0028 C8309FE5 		ldr	r3, .L19+4
 563 002c 0020A0E3 		mov	r2, #0
 564 0030 002083E5 		str	r2, [r3]
 299:../CX3RDKOV5640.c **** 
 300:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
 301:../CX3RDKOV5640.c ****     CyU3PTimerStop (&UvcTimer);
 565              		.loc 1 301 0
 566 0034 C0009FE5 		ldr	r0, .L19+8
 567 0038 FEFFFFEB 		bl	_txe_timer_deactivate
 302:../CX3RDKOV5640.c **** #endif
 303:../CX3RDKOV5640.c **** 
 304:../CX3RDKOV5640.c ****     /* Pause the GPIF interface*/
 305:../CX3RDKOV5640.c ****     CyU3PGpifSMControl(CyTrue);
 568              		.loc 1 305 0
 569 003c 0100A0E3 		mov	r0, #1
 570 0040 FEFFFFEB 		bl	CyU3PGpifSMControl
 306:../CX3RDKOV5640.c **** 
 307:../CX3RDKOV5640.c ****     CyU3PUsbSetEpNak (ES_UVC_EP_BULK_VIDEO, CyTrue);
 571              		.loc 1 307 0
 572 0044 8300A0E3 		mov	r0, #131
 573 0048 0110A0E3 		mov	r1, #1
 574 004c FEFFFFEB 		bl	CyU3PUsbSetEpNak
 308:../CX3RDKOV5640.c ****     CyU3PBusyWait (100);
 575              		.loc 1 308 0
 576 0050 6400A0E3 		mov	r0, #100
 577 0054 FEFFFFEB 		bl	CyFx3BusyWait
 309:../CX3RDKOV5640.c **** 
 310:../CX3RDKOV5640.c ****     /* Abort and destroy the video streaming channel */
 311:../CX3RDKOV5640.c ****     /* Reset the channel: Set to DSCR chain starting point in PORD/CONS SCKT; set DSCR_SIZE field i
 312:../CX3RDKOV5640.c ****     status = CyU3PDmaMultiChannelReset(&glChHandleUVCStream);
 578              		.loc 1 312 0
 579 0058 A0009FE5 		ldr	r0, .L19+12
 580 005c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 581 0060 08000BE5 		str	r0, [fp, #-8]
 313:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 582              		.loc 1 313 0
 583 0064 08301BE5 		ldr	r3, [fp, #-8]
 584 0068 000053E3 		cmp	r3, #0
 585 006c 0300000A 		beq	.L17
 314:../CX3RDKOV5640.c ****     {
 315:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4,"\n\rAplnStop:ChannelReset Err = 0x%x",status);
 586              		.loc 1 315 0
 587 0070 0400A0E3 		mov	r0, #4
 588 0074 88109FE5 		ldr	r1, .L19+16
 589 0078 08201BE5 		ldr	r2, [fp, #-8]
 590 007c FEFFFFEB 		bl	CyU3PDebugPrint
 591              	.L17:
 316:../CX3RDKOV5640.c ****     }
 317:../CX3RDKOV5640.c ****     CyU3PThreadSleep(25);
 592              		.loc 1 317 0
 593 0080 1900A0E3 		mov	r0, #25
 594 0084 FEFFFFEB 		bl	_tx_thread_sleep
 318:../CX3RDKOV5640.c **** 
 319:../CX3RDKOV5640.c ****     /* Flush the endpoint memory */
 320:../CX3RDKOV5640.c ****     CyU3PUsbFlushEp(ES_UVC_EP_BULK_VIDEO);
 595              		.loc 1 320 0
 596 0088 8300A0E3 		mov	r0, #131
 597 008c FEFFFFEB 		bl	CyU3PUsbFlushEp
 321:../CX3RDKOV5640.c ****     /* Clear the stall condition and sequence numbers if ClearFeature. */
 322:../CX3RDKOV5640.c ****     if (glIsClearFeature)
 598              		.loc 1 322 0
 599 0090 70309FE5 		ldr	r3, .L19+20
 600 0094 003093E5 		ldr	r3, [r3]
 601 0098 000053E3 		cmp	r3, #0
 602 009c 0600000A 		beq	.L18
 323:../CX3RDKOV5640.c ****     {
 324:../CX3RDKOV5640.c ****         CyU3PUsbStall (ES_UVC_EP_BULK_VIDEO, CyFalse, CyTrue);
 603              		.loc 1 324 0
 604 00a0 8300A0E3 		mov	r0, #131
 605 00a4 0010A0E3 		mov	r1, #0
 606 00a8 0120A0E3 		mov	r2, #1
 607 00ac FEFFFFEB 		bl	CyU3PUsbStall
 325:../CX3RDKOV5640.c ****         glIsClearFeature = CyFalse;
 608              		.loc 1 325 0
 609 00b0 50309FE5 		ldr	r3, .L19+20
 610 00b4 0020A0E3 		mov	r2, #0
 611 00b8 002083E5 		str	r2, [r3]
 612              	.L18:
 326:../CX3RDKOV5640.c ****     }
 327:../CX3RDKOV5640.c ****     CyU3PUsbSetEpNak (ES_UVC_EP_BULK_VIDEO, CyFalse);
 613              		.loc 1 327 0
 614 00bc 8300A0E3 		mov	r0, #131
 615 00c0 0010A0E3 		mov	r1, #0
 616 00c4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 328:../CX3RDKOV5640.c **** 	CyU3PBusyWait (200);
 617              		.loc 1 328 0
 618 00c8 C800A0E3 		mov	r0, #200
 619 00cc FEFFFFEB 		bl	CyFx3BusyWait
 329:../CX3RDKOV5640.c **** 
 330:../CX3RDKOV5640.c ****     glDMATxCount = 0;
 620              		.loc 1 330 0
 621 00d0 34309FE5 		ldr	r3, .L19+24
 622 00d4 0020A0E3 		mov	r2, #0
 623 00d8 002083E5 		str	r2, [r3]
 331:../CX3RDKOV5640.c ****     glDmaDone = 0;
 624              		.loc 1 331 0
 625 00dc 2C309FE5 		ldr	r3, .L19+28
 626 00e0 0020A0E3 		mov	r2, #0
 627 00e4 002083E5 		str	r2, [r3]
 332:../CX3RDKOV5640.c **** 
 333:../CX3RDKOV5640.c ****     /* Enable USB 3.0 LPM */
 334:../CX3RDKOV5640.c ****     CyU3PUsbLPMEnable ();
 628              		.loc 1 334 0
 629 00e8 FEFFFFEB 		bl	CyU3PUsbLPMEnable
 335:../CX3RDKOV5640.c **** }
 630              		.loc 1 335 0
 631 00ec 04D04BE2 		sub	sp, fp, #4
 632              		@ sp needed
 633 00f0 0088BDE8 		ldmfd	sp!, {fp, pc}
 634              	.L20:
 635              		.align	2
 636              	.L19:
 637 00f4 00000000 		.word	glIsApplnActive
 638 00f8 00000000 		.word	glMipiActive
 639 00fc 00000000 		.word	UvcTimer
 640 0100 00000000 		.word	glChHandleUVCStream
 641 0104 44000000 		.word	.LC2
 642 0108 00000000 		.word	glIsClearFeature
 643 010c 00000000 		.word	glDMATxCount
 644 0110 00000000 		.word	glDmaDone
 645              		.cfi_endproc
 646              	.LFE4:
 648              		.section	.rodata
 649 0067 00       		.align	2
 650              	.LC3:
 651 0068 0A0D4770 		.ascii	"\012\015GpifCB:WrapUp SCK0 Err = 0x%x\000"
 651      69664342 
 651      3A577261 
 651      70557020 
 651      53434B30 
 652              		.align	2
 653              	.LC4:
 654 0088 0A0D4770 		.ascii	"\012\015GpifCB:WrapUp SCK1 Err = 0x%x\000"
 654      69664342 
 654      3A577261 
 654      70557020 
 654      53434B31 
 655              		.section	.text.esUVCGpifCB,"ax",%progbits
 656              		.align	2
 657              		.global	esUVCGpifCB
 659              	esUVCGpifCB:
 660              	.LFB5:
 336:../CX3RDKOV5640.c **** 
 337:../CX3RDKOV5640.c **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
 338:../CX3RDKOV5640.c ****     void
 339:../CX3RDKOV5640.c **** esUVCGpifCB (
 340:../CX3RDKOV5640.c ****         CyU3PGpifEventType event,
 341:../CX3RDKOV5640.c ****         uint8_t currentState
 342:../CX3RDKOV5640.c ****         )
 343:../CX3RDKOV5640.c **** {
 661              		.loc 1 343 0
 662              		.cfi_startproc
 663              		@ args = 0, pretend = 0, frame = 16
 664              		@ frame_needed = 1, uses_anonymous_args = 0
 665 0000 00482DE9 		stmfd	sp!, {fp, lr}
 666              	.LCFI10:
 667              		.cfi_def_cfa_offset 8
 668              		.cfi_offset 11, -8
 669              		.cfi_offset 14, -4
 670 0004 04B08DE2 		add	fp, sp, #4
 671              	.LCFI11:
 672              		.cfi_def_cfa 11, 4
 673 0008 10D04DE2 		sub	sp, sp, #16
 674 000c 0020A0E1 		mov	r2, r0
 675 0010 0130A0E1 		mov	r3, r1
 676 0014 0D204BE5 		strb	r2, [fp, #-13]
 677 0018 0E304BE5 		strb	r3, [fp, #-14]
 344:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 678              		.loc 1 344 0
 679 001c 0030A0E3 		mov	r3, #0
 680 0020 08300BE5 		str	r3, [fp, #-8]
 345:../CX3RDKOV5640.c ****     /* Handle interrupt from the State Machine */
 346:../CX3RDKOV5640.c ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 681              		.loc 1 346 0
 682 0024 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 683 0028 010053E3 		cmp	r3, #1
 684 002c 1C00001A 		bne	.L21
 347:../CX3RDKOV5640.c ****     {
 348:../CX3RDKOV5640.c ****         /* Wrapup Socket 0*/
 349:../CX3RDKOV5640.c ****         if(currentState == CX3_PARTIAL_BUFFER_IN_SCK0)
 685              		.loc 1 349 0
 686 0030 0E305BE5 		ldrb	r3, [fp, #-14]	@ zero_extendqisi2
 687 0034 090053E3 		cmp	r3, #9
 688 0038 0B00001A 		bne	.L23
 350:../CX3RDKOV5640.c ****         {
 351:../CX3RDKOV5640.c ****             status = CyU3PDmaMultiChannelSetWrapUp(&glChHandleUVCStream,0);
 689              		.loc 1 351 0
 690 003c 68009FE5 		ldr	r0, .L25
 691 0040 0010A0E3 		mov	r1, #0
 692 0044 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 693 0048 08000BE5 		str	r0, [fp, #-8]
 352:../CX3RDKOV5640.c ****             if (status != CY_U3P_SUCCESS)
 694              		.loc 1 352 0
 695 004c 08301BE5 		ldr	r3, [fp, #-8]
 696 0050 000053E3 		cmp	r3, #0
 697 0054 1200000A 		beq	.L21
 353:../CX3RDKOV5640.c ****             {
 354:../CX3RDKOV5640.c ****                 CyU3PDebugPrint (4, "\n\rGpifCB:WrapUp SCK0 Err = 0x%x",status);
 698              		.loc 1 354 0
 699 0058 0400A0E3 		mov	r0, #4
 700 005c 4C109FE5 		ldr	r1, .L25+4
 701 0060 08201BE5 		ldr	r2, [fp, #-8]
 702 0064 FEFFFFEB 		bl	CyU3PDebugPrint
 703 0068 0D0000EA 		b	.L21
 704              	.L23:
 355:../CX3RDKOV5640.c ****             }
 356:../CX3RDKOV5640.c ****         }
 357:../CX3RDKOV5640.c ****         /* Wrapup Socket 1 */
 358:../CX3RDKOV5640.c ****         else if(currentState == CX3_PARTIAL_BUFFER_IN_SCK1)
 705              		.loc 1 358 0
 706 006c 0E305BE5 		ldrb	r3, [fp, #-14]	@ zero_extendqisi2
 707 0070 0A0053E3 		cmp	r3, #10
 708 0074 0A00001A 		bne	.L21
 359:../CX3RDKOV5640.c ****         {
 360:../CX3RDKOV5640.c ****             status = CyU3PDmaMultiChannelSetWrapUp(&glChHandleUVCStream,1);
 709              		.loc 1 360 0
 710 0078 2C009FE5 		ldr	r0, .L25
 711 007c 0110A0E3 		mov	r1, #1
 712 0080 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 713 0084 08000BE5 		str	r0, [fp, #-8]
 361:../CX3RDKOV5640.c ****             if (status != CY_U3P_SUCCESS)
 714              		.loc 1 361 0
 715 0088 08301BE5 		ldr	r3, [fp, #-8]
 716 008c 000053E3 		cmp	r3, #0
 717 0090 0300000A 		beq	.L21
 362:../CX3RDKOV5640.c ****             {
 363:../CX3RDKOV5640.c ****                 CyU3PDebugPrint (4, "\n\rGpifCB:WrapUp SCK1 Err = 0x%x",status);
 718              		.loc 1 363 0
 719 0094 0400A0E3 		mov	r0, #4
 720 0098 14109FE5 		ldr	r1, .L25+8
 721 009c 08201BE5 		ldr	r2, [fp, #-8]
 722 00a0 FEFFFFEB 		bl	CyU3PDebugPrint
 723              	.L21:
 364:../CX3RDKOV5640.c ****             }
 365:../CX3RDKOV5640.c ****         }
 366:../CX3RDKOV5640.c ****     }
 367:../CX3RDKOV5640.c **** #ifdef VISDebug
 368:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rJump into GPIFCB: event %d currentState %d", event, currentState);
 369:../CX3RDKOV5640.c **** #endif
 370:../CX3RDKOV5640.c **** }
 724              		.loc 1 370 0
 725 00a4 04D04BE2 		sub	sp, fp, #4
 726              		@ sp needed
 727 00a8 0088BDE8 		ldmfd	sp!, {fp, pc}
 728              	.L26:
 729              		.align	2
 730              	.L25:
 731 00ac 00000000 		.word	glChHandleUVCStream
 732 00b0 68000000 		.word	.LC3
 733 00b4 88000000 		.word	.LC4
 734              		.cfi_endproc
 735              	.LFE5:
 737              		.section	.text.esUVCUvcAppDmaCallback,"ax",%progbits
 738              		.align	2
 739              		.global	esUVCUvcAppDmaCallback
 741              	esUVCUvcAppDmaCallback:
 742              	.LFB6:
 371:../CX3RDKOV5640.c **** 
 372:../CX3RDKOV5640.c **** 
 373:../CX3RDKOV5640.c **** /* DMA callback function to handle the produce and consume events. */
 374:../CX3RDKOV5640.c ****     void
 375:../CX3RDKOV5640.c **** esUVCUvcAppDmaCallback (
 376:../CX3RDKOV5640.c ****         CyU3PDmaMultiChannel   *chHandle,
 377:../CX3RDKOV5640.c ****         CyU3PDmaCbType_t  type,
 378:../CX3RDKOV5640.c ****         CyU3PDmaCBInput_t *input
 379:../CX3RDKOV5640.c ****         )
 380:../CX3RDKOV5640.c **** {
 743              		.loc 1 380 0
 744              		.cfi_startproc
 745              		@ args = 0, pretend = 0, frame = 32
 746              		@ frame_needed = 1, uses_anonymous_args = 0
 747 0000 00482DE9 		stmfd	sp!, {fp, lr}
 748              	.LCFI12:
 749              		.cfi_def_cfa_offset 8
 750              		.cfi_offset 11, -8
 751              		.cfi_offset 14, -4
 752 0004 04B08DE2 		add	fp, sp, #4
 753              	.LCFI13:
 754              		.cfi_def_cfa 11, 4
 755 0008 28D04DE2 		sub	sp, sp, #40
 756 000c 18000BE5 		str	r0, [fp, #-24]
 757 0010 0130A0E1 		mov	r3, r1
 758 0014 20200BE5 		str	r2, [fp, #-32]
 759 0018 BA314BE1 		strh	r3, [fp, #-26]	@ movhi
 381:../CX3RDKOV5640.c ****     CyU3PDmaBuffer_t DmaBuffer;
 382:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 760              		.loc 1 382 0
 761 001c 0030A0E3 		mov	r3, #0
 762 0020 08300BE5 		str	r3, [fp, #-8]
 383:../CX3RDKOV5640.c **** 
 384:../CX3RDKOV5640.c ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 763              		.loc 1 384 0
 764 0024 BA315BE1 		ldrh	r3, [fp, #-26]
 765 0028 080053E3 		cmp	r3, #8
 766 002c 5800001A 		bne	.L28
 385:../CX3RDKOV5640.c ****     {
 386:../CX3RDKOV5640.c ****         /* This is a produce event notification to the CPU. This notification is
 387:../CX3RDKOV5640.c ****          * received upon reception of every buffer. The buffer will not be sent
 388:../CX3RDKOV5640.c ****          * out unless it is explicitly committed. The call shall fail if there
 389:../CX3RDKOV5640.c ****          * is a bus reset / usb disconnect or if there is any application error. */
 390:../CX3RDKOV5640.c **** 
 391:../CX3RDKOV5640.c ****         /* Disable USB 3.0 LPM while Buffer is being transmitted out*/
 392:../CX3RDKOV5640.c ****         if ((CyU3PUsbGetSpeed () == CY_U3P_SUPER_SPEED) && (doLpmDisable))
 767              		.loc 1 392 0
 768 0030 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 769 0034 0030A0E1 		mov	r3, r0
 770 0038 030053E3 		cmp	r3, #3
 771 003c 0B00001A 		bne	.L29
 772              		.loc 1 392 0 is_stmt 0 discriminator 1
 773 0040 18339FE5 		ldr	r3, .L42
 774 0044 003093E5 		ldr	r3, [r3]
 775 0048 000053E3 		cmp	r3, #0
 776 004c 0700000A 		beq	.L29
 393:../CX3RDKOV5640.c ****         {
 394:../CX3RDKOV5640.c ****             CyU3PUsbLPMDisable ();
 777              		.loc 1 394 0 is_stmt 1
 778 0050 FEFFFFEB 		bl	CyU3PUsbLPMDisable
 395:../CX3RDKOV5640.c ****             CyU3PUsbSetLinkPowerState (CyU3PUsbLPM_U0);
 779              		.loc 1 395 0
 780 0054 0000A0E3 		mov	r0, #0
 781 0058 FEFFFFEB 		bl	CyU3PUsbSetLinkPowerState
 396:../CX3RDKOV5640.c ****             CyU3PBusyWait (200);
 782              		.loc 1 396 0
 783 005c C800A0E3 		mov	r0, #200
 784 0060 FEFFFFEB 		bl	CyFx3BusyWait
 397:../CX3RDKOV5640.c **** 
 398:../CX3RDKOV5640.c ****             doLpmDisable = CyFalse;
 785              		.loc 1 398 0
 786 0064 F4329FE5 		ldr	r3, .L42
 787 0068 0020A0E3 		mov	r2, #0
 788 006c 002083E5 		str	r2, [r3]
 789              	.L29:
 399:../CX3RDKOV5640.c ****         }
 400:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
 401:../CX3RDKOV5640.c ****             CyU3PTimerStart (&UvcTimer);
 790              		.loc 1 401 0
 791 0070 EC029FE5 		ldr	r0, .L42+4
 792 0074 FEFFFFEB 		bl	_txe_timer_activate
 402:../CX3RDKOV5640.c **** #endif
 403:../CX3RDKOV5640.c **** 
 404:../CX3RDKOV5640.c ****         status = CyU3PDmaMultiChannelGetBuffer(chHandle, &DmaBuffer, CYU3P_NO_WAIT);
 793              		.loc 1 404 0
 794 0078 14304BE2 		sub	r3, fp, #20
 795 007c 18001BE5 		ldr	r0, [fp, #-24]
 796 0080 0310A0E1 		mov	r1, r3
 797 0084 0020A0E3 		mov	r2, #0
 798 0088 FEFFFFEB 		bl	CyU3PDmaMultiChannelGetBuffer
 799 008c 08000BE5 		str	r0, [fp, #-8]
 405:../CX3RDKOV5640.c **** #ifdef VISDebug
 406:../CX3RDKOV5640.c **** //    CyU3PDebugPrint (4, "\n\rAppDmaCallback:CY_U3P_DMA_CB_PROD_EVENT CyU3PDmaMultiChannelGetBuffe
 407:../CX3RDKOV5640.c **** #endif
 408:../CX3RDKOV5640.c ****         while (status == CY_U3P_SUCCESS)
 800              		.loc 1 408 0
 801 0090 3B0000EA 		b	.L30
 802              	.L35:
 409:../CX3RDKOV5640.c ****         {
 410:../CX3RDKOV5640.c ****             /* Add Headers*/
 411:../CX3RDKOV5640.c ****             if(DmaBuffer.count < ES_UVC_DATA_BUF_SIZE)
 803              		.loc 1 411 0
 804 0094 B0215BE1 		ldrh	r2, [fp, #-16]
 805 0098 C8329FE5 		ldr	r3, .L42+8
 806 009c B030D3E1 		ldrh	r3, [r3]
 807 00a0 030052E1 		cmp	r2, r3
 808 00a4 0800002A 		bcs	.L31
 412:../CX3RDKOV5640.c ****             {
 413:../CX3RDKOV5640.c ****                 esUVCUvcAddHeader ((DmaBuffer.buffer - ES_UVC_PROD_HEADER), ES_UVC_HEADER_EOF);
 809              		.loc 1 413 0
 810 00a8 14301BE5 		ldr	r3, [fp, #-20]
 811 00ac 0C3043E2 		sub	r3, r3, #12
 812 00b0 0300A0E1 		mov	r0, r3
 813 00b4 0210A0E3 		mov	r1, #2
 814 00b8 FEFFFFEB 		bl	esUVCUvcAddHeader
 414:../CX3RDKOV5640.c ****                 glHitFV = CyTrue;
 815              		.loc 1 414 0
 816 00bc A8329FE5 		ldr	r3, .L42+12
 817 00c0 0120A0E3 		mov	r2, #1
 818 00c4 002083E5 		str	r2, [r3]
 819 00c8 040000EA 		b	.L32
 820              	.L31:
 415:../CX3RDKOV5640.c **** #ifdef VISDebug
 416:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppDmaCallback:CY_U3P_DMA_CB_PROD_EVENT count %x glDMATxCount++ %x", D
 417:../CX3RDKOV5640.c **** #endif
 418:../CX3RDKOV5640.c **** 
 419:../CX3RDKOV5640.c ****             }
 420:../CX3RDKOV5640.c ****             else
 421:../CX3RDKOV5640.c ****             {
 422:../CX3RDKOV5640.c ****                 esUVCUvcAddHeader ((DmaBuffer.buffer - ES_UVC_PROD_HEADER), ES_UVC_HEADER_FRAME);
 821              		.loc 1 422 0
 822 00cc 14301BE5 		ldr	r3, [fp, #-20]
 823 00d0 0C3043E2 		sub	r3, r3, #12
 824 00d4 0300A0E1 		mov	r0, r3
 825 00d8 0010A0E3 		mov	r1, #0
 826 00dc FEFFFFEB 		bl	esUVCUvcAddHeader
 827              	.L32:
 423:../CX3RDKOV5640.c ****             }
 424:../CX3RDKOV5640.c **** 
 425:../CX3RDKOV5640.c ****             /* Commit Buffer to USB*/
 426:../CX3RDKOV5640.c ****             status = CyU3PDmaMultiChannelCommitBuffer (chHandle, (DmaBuffer.count + 12), 0);
 828              		.loc 1 426 0
 829 00e0 B0315BE1 		ldrh	r3, [fp, #-16]
 830 00e4 0C3083E2 		add	r3, r3, #12
 831 00e8 0338A0E1 		mov	r3, r3, asl #16
 832 00ec 2338A0E1 		mov	r3, r3, lsr #16
 833 00f0 18001BE5 		ldr	r0, [fp, #-24]
 834 00f4 0310A0E1 		mov	r1, r3
 835 00f8 0020A0E3 		mov	r2, #0
 836 00fc FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 837 0100 08000BE5 		str	r0, [fp, #-8]
 427:../CX3RDKOV5640.c ****             if (status != CY_U3P_SUCCESS)
 838              		.loc 1 427 0
 839 0104 08301BE5 		ldr	r3, [fp, #-8]
 840 0108 000053E3 		cmp	r3, #0
 841 010c 0500000A 		beq	.L33
 428:../CX3RDKOV5640.c ****             {
 429:../CX3RDKOV5640.c ****                    CyU3PEventSet(&glTimerEvent, ES_TIMER_RESET_EVENT,CYU3P_EVENT_OR);
 842              		.loc 1 429 0
 843 0110 58029FE5 		ldr	r0, .L42+16
 844 0114 1010A0E3 		mov	r1, #16
 845 0118 0020A0E3 		mov	r2, #0
 846 011c FEFFFFEB 		bl	_txe_event_flags_set
 430:../CX3RDKOV5640.c ****                    break;
 847              		.loc 1 430 0
 848 0120 0000A0E1 		mov	r0, r0	@ nop
 849 0124 8B0000EA 		b	.L27
 850              	.L33:
 431:../CX3RDKOV5640.c ****             }
 432:../CX3RDKOV5640.c ****             else
 433:../CX3RDKOV5640.c ****             {
 434:../CX3RDKOV5640.c ****                 glDMATxCount++;
 851              		.loc 1 434 0
 852 0128 44329FE5 		ldr	r3, .L42+20
 853 012c 003093E5 		ldr	r3, [r3]
 854 0130 012083E2 		add	r2, r3, #1
 855 0134 38329FE5 		ldr	r3, .L42+20
 856 0138 002083E5 		str	r2, [r3]
 435:../CX3RDKOV5640.c ****                 glDmaDone++;
 857              		.loc 1 435 0
 858 013c 34329FE5 		ldr	r3, .L42+24
 859 0140 003093E5 		ldr	r3, [r3]
 860 0144 012083E2 		add	r2, r3, #1
 861 0148 28329FE5 		ldr	r3, .L42+24
 862 014c 002083E5 		str	r2, [r3]
 436:../CX3RDKOV5640.c ****             }
 437:../CX3RDKOV5640.c **** 
 438:../CX3RDKOV5640.c ****             glActiveSocket ^= 1; /* Toggle the Active Socket */
 863              		.loc 1 438 0
 864 0150 24329FE5 		ldr	r3, .L42+28
 865 0154 0030D3E5 		ldrb	r3, [r3]
 866 0158 FF3003E2 		and	r3, r3, #255
 867 015c 013023E2 		eor	r3, r3, #1
 868 0160 FF2003E2 		and	r2, r3, #255
 869 0164 10329FE5 		ldr	r3, .L42+28
 870 0168 0020C3E5 		strb	r2, [r3]
 439:../CX3RDKOV5640.c ****             status = CyU3PDmaMultiChannelGetBuffer(chHandle, &DmaBuffer, CYU3P_NO_WAIT);
 871              		.loc 1 439 0
 872 016c 14304BE2 		sub	r3, fp, #20
 873 0170 18001BE5 		ldr	r0, [fp, #-24]
 874 0174 0310A0E1 		mov	r1, r3
 875 0178 0020A0E3 		mov	r2, #0
 876 017c FEFFFFEB 		bl	CyU3PDmaMultiChannelGetBuffer
 877 0180 08000BE5 		str	r0, [fp, #-8]
 878              	.L30:
 408:../CX3RDKOV5640.c ****         {
 879              		.loc 1 408 0 discriminator 1
 880 0184 08301BE5 		ldr	r3, [fp, #-8]
 881 0188 000053E3 		cmp	r3, #0
 882 018c C0FFFF0A 		beq	.L35
 883 0190 700000EA 		b	.L27
 884              	.L28:
 440:../CX3RDKOV5640.c ****         }
 441:../CX3RDKOV5640.c ****     }
 442:../CX3RDKOV5640.c ****     else if(type == CY_U3P_DMA_CB_CONS_EVENT)
 885              		.loc 1 442 0
 886 0194 BA315BE1 		ldrh	r3, [fp, #-26]
 887 0198 100053E3 		cmp	r3, #16
 888 019c 6D00001A 		bne	.L27
 443:../CX3RDKOV5640.c ****     {
 444:../CX3RDKOV5640.c ****         glDmaDone--;
 889              		.loc 1 444 0
 890 01a0 D0319FE5 		ldr	r3, .L42+24
 891 01a4 003093E5 		ldr	r3, [r3]
 892 01a8 012043E2 		sub	r2, r3, #1
 893 01ac C4319FE5 		ldr	r3, .L42+24
 894 01b0 002083E5 		str	r2, [r3]
 445:../CX3RDKOV5640.c **** 
 446:../CX3RDKOV5640.c ****         /* Check if Frame is completely transferred */
 447:../CX3RDKOV5640.c ****         glIsStreamingStarted = CyTrue;
 895              		.loc 1 447 0
 896 01b4 C4319FE5 		ldr	r3, .L42+32
 897 01b8 0120A0E3 		mov	r2, #1
 898 01bc 002083E5 		str	r2, [r3]
 448:../CX3RDKOV5640.c **** 
 449:../CX3RDKOV5640.c ****         if((glHitFV == CyTrue) && (glDmaDone == 0))
 899              		.loc 1 449 0
 900 01c0 A4319FE5 		ldr	r3, .L42+12
 901 01c4 003093E5 		ldr	r3, [r3]
 902 01c8 010053E3 		cmp	r3, #1
 903 01cc 6100001A 		bne	.L27
 904              		.loc 1 449 0 is_stmt 0 discriminator 1
 905 01d0 A0319FE5 		ldr	r3, .L42+24
 906 01d4 003093E5 		ldr	r3, [r3]
 907 01d8 000053E3 		cmp	r3, #0
 908 01dc 5D00001A 		bne	.L27
 450:../CX3RDKOV5640.c ****         {
 451:../CX3RDKOV5640.c ****             glHitFV = CyFalse;
 909              		.loc 1 451 0 is_stmt 1
 910 01e0 84319FE5 		ldr	r3, .L42+12
 911 01e4 0020A0E3 		mov	r2, #0
 912 01e8 002083E5 		str	r2, [r3]
 452:../CX3RDKOV5640.c ****             glDMATxCount=0;
 913              		.loc 1 452 0
 914 01ec 80319FE5 		ldr	r3, .L42+20
 915 01f0 0020A0E3 		mov	r2, #0
 916 01f4 002083E5 		str	r2, [r3]
 453:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
 454:../CX3RDKOV5640.c ****             CyU3PTimerStop (&UvcTimer);
 917              		.loc 1 454 0
 918 01f8 64019FE5 		ldr	r0, .L42+4
 919 01fc FEFFFFEB 		bl	_txe_timer_deactivate
 455:../CX3RDKOV5640.c **** #endif
 456:../CX3RDKOV5640.c **** 
 457:../CX3RDKOV5640.c ****             if (glActiveSocket)
 920              		.loc 1 457 0
 921 0200 74319FE5 		ldr	r3, .L42+28
 922 0204 0030D3E5 		ldrb	r3, [r3]
 923 0208 FF3003E2 		and	r3, r3, #255
 924 020c 000053E3 		cmp	r3, #0
 925 0210 0700000A 		beq	.L37
 458:../CX3RDKOV5640.c ****                 CyU3PGpifSMSwitch(ES_UVC_INVALID_GPIF_STATE, CX3_START_SCK1,
 926              		.loc 1 458 0
 927 0214 0230A0E3 		mov	r3, #2
 928 0218 00308DE5 		str	r3, [sp]
 929 021c 60019FE5 		ldr	r0, .L42+36
 930 0220 0D10A0E3 		mov	r1, #13
 931 0224 58219FE5 		ldr	r2, .L42+36
 932 0228 0030A0E3 		mov	r3, #0
 933 022c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 934 0230 060000EA 		b	.L38
 935              	.L37:
 459:../CX3RDKOV5640.c ****                 		ES_UVC_INVALID_GPIF_STATE, ALPHA_CX3_START_SCK1, ES_UVC_GPIF_SWITCH_TIMEOUT);
 460:../CX3RDKOV5640.c ****             else
 461:../CX3RDKOV5640.c ****                 CyU3PGpifSMSwitch(ES_UVC_INVALID_GPIF_STATE, CX3_START_SCK0,
 936              		.loc 1 461 0
 937 0234 0230A0E3 		mov	r3, #2
 938 0238 00308DE5 		str	r3, [sp]
 939 023c 40019FE5 		ldr	r0, .L42+36
 940 0240 0010A0E3 		mov	r1, #0
 941 0244 38219FE5 		ldr	r2, .L42+36
 942 0248 0030A0E3 		mov	r3, #0
 943 024c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 944              	.L38:
 462:../CX3RDKOV5640.c ****                 		ES_UVC_INVALID_GPIF_STATE, ALPHA_CX3_START_SCK0, ES_UVC_GPIF_SWITCH_TIMEOUT);
 463:../CX3RDKOV5640.c **** #ifdef VISDebug
 464:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppDmaCallback:CY_U3P_DMA_CB_CONS_EVENT glActiveSocket  %x", glActiveS
 465:../CX3RDKOV5640.c **** #endif
 466:../CX3RDKOV5640.c ****             CyU3PUsbLPMEnable ();
 945              		.loc 1 466 0
 946 0250 FEFFFFEB 		bl	CyU3PUsbLPMEnable
 467:../CX3RDKOV5640.c ****             doLpmDisable = CyTrue;
 947              		.loc 1 467 0
 948 0254 04319FE5 		ldr	r3, .L42
 949 0258 0120A0E3 		mov	r2, #1
 950 025c 002083E5 		str	r2, [r3]
 468:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
 469:../CX3RDKOV5640.c ****             CyU3PTimerModify (&UvcTimer, TIMER_PERIOD, 0);
 951              		.loc 1 469 0
 952 0260 FC009FE5 		ldr	r0, .L42+4
 953 0264 7D1FA0E3 		mov	r1, #500
 954 0268 0020A0E3 		mov	r2, #0
 955 026c FEFFFFEB 		bl	_txe_timer_change
 470:../CX3RDKOV5640.c **** #endif
 471:../CX3RDKOV5640.c **** 
 472:../CX3RDKOV5640.c ****             if(glStillCaptured == CyTrue)
 956              		.loc 1 472 0
 957 0270 10319FE5 		ldr	r3, .L42+40
 958 0274 003093E5 		ldr	r3, [r3]
 959 0278 010053E3 		cmp	r3, #1
 960 027c 0C00001A 		bne	.L39
 473:../CX3RDKOV5640.c ****             {
 474:../CX3RDKOV5640.c ****             	glStillCaptured = CyFalse;
 961              		.loc 1 474 0
 962 0280 00319FE5 		ldr	r3, .L42+40
 963 0284 0020A0E3 		mov	r2, #0
 964 0288 002083E5 		str	r2, [r3]
 475:../CX3RDKOV5640.c ****             	glUVCHeader[1]^=ES_UVC_HEADER_STILL_IMAGE;
 965              		.loc 1 475 0
 966 028c F8309FE5 		ldr	r3, .L42+44
 967 0290 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 968 0294 203023E2 		eor	r3, r3, #32
 969 0298 FF2003E2 		and	r2, r3, #255
 970 029c E8309FE5 		ldr	r3, .L42+44
 971 02a0 0120C3E5 		strb	r2, [r3, #1]
 476:../CX3RDKOV5640.c ****             	glFrameIndexToSet = glCurrentFrameIndex;  //for still test
 972              		.loc 1 476 0
 973 02a4 E4309FE5 		ldr	r3, .L42+48
 974 02a8 0020D3E5 		ldrb	r2, [r3]	@ zero_extendqisi2
 975 02ac E0309FE5 		ldr	r3, .L42+52
 976 02b0 0020C3E5 		strb	r2, [r3]
 977              	.L39:
 477:../CX3RDKOV5640.c ****             	//CyU3PEventSet(&glTimerEvent, ES_TIMER_RESET_EVENT,CYU3P_EVENT_OR);
 478:../CX3RDKOV5640.c ****             }
 479:../CX3RDKOV5640.c ****             if(glStillCaptureStart == CyTrue)
 978              		.loc 1 479 0
 979 02b4 DC309FE5 		ldr	r3, .L42+56
 980 02b8 003093E5 		ldr	r3, [r3]
 981 02bc 010053E3 		cmp	r3, #1
 982 02c0 2400001A 		bne	.L27
 480:../CX3RDKOV5640.c ****             {
 481:../CX3RDKOV5640.c ****             	if(glStillSkip >= 3)
 983              		.loc 1 481 0
 984 02c4 D0309FE5 		ldr	r3, .L42+60
 985 02c8 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 986 02cc 020053E3 		cmp	r3, #2
 987 02d0 0900009A 		bls	.L40
 482:../CX3RDKOV5640.c **** 				{
 483:../CX3RDKOV5640.c ****             		glStillSkip--;
 988              		.loc 1 483 0
 989 02d4 C0309FE5 		ldr	r3, .L42+60
 990 02d8 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 991 02dc 013043E2 		sub	r3, r3, #1
 992 02e0 FF2003E2 		and	r2, r3, #255
 993 02e4 B0309FE5 		ldr	r3, .L42+60
 994 02e8 0020C3E5 		strb	r2, [r3]
 484:../CX3RDKOV5640.c ****             		glFrameIndexToSet = 4;
 995              		.loc 1 484 0
 996 02ec A0309FE5 		ldr	r3, .L42+52
 997 02f0 0420A0E3 		mov	r2, #4
 998 02f4 0020C3E5 		strb	r2, [r3]
 999 02f8 160000EA 		b	.L27
 1000              	.L40:
 485:../CX3RDKOV5640.c **** 					//CyU3PEventSet(&glTimerEvent, ES_TIMER_RESET_EVENT,CYU3P_EVENT_OR);
 486:../CX3RDKOV5640.c **** 					//CyU3PDebugPrint (4, "\n\rCY_U3P_USB_EVENT_SETINTF: glstillSkip 3");
 487:../CX3RDKOV5640.c **** 				}
 488:../CX3RDKOV5640.c ****             	else if(glStillSkip <= 0)
 1001              		.loc 1 488 0
 1002 02fc 98309FE5 		ldr	r3, .L42+60
 1003 0300 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1004 0304 000053E3 		cmp	r3, #0
 1005 0308 0C00001A 		bne	.L41
 489:../CX3RDKOV5640.c ****             	{
 490:../CX3RDKOV5640.c ****             		glStillCaptureStart = CyFalse;
 1006              		.loc 1 490 0
 1007 030c 84309FE5 		ldr	r3, .L42+56
 1008 0310 0020A0E3 		mov	r2, #0
 1009 0314 002083E5 		str	r2, [r3]
 491:../CX3RDKOV5640.c **** 					glStillCaptured = CyTrue;
 1010              		.loc 1 491 0
 1011 0318 68309FE5 		ldr	r3, .L42+40
 1012 031c 0120A0E3 		mov	r2, #1
 1013 0320 002083E5 		str	r2, [r3]
 492:../CX3RDKOV5640.c **** 					glUVCHeader[1]^=ES_UVC_HEADER_STILL_IMAGE; //end still flag at still end
 1014              		.loc 1 492 0
 1015 0324 60309FE5 		ldr	r3, .L42+44
 1016 0328 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1017 032c 203023E2 		eor	r3, r3, #32
 1018 0330 FF2003E2 		and	r2, r3, #255
 1019 0334 50309FE5 		ldr	r3, .L42+44
 1020 0338 0120C3E5 		strb	r2, [r3, #1]
 1021 033c 050000EA 		b	.L27
 1022              	.L41:
 493:../CX3RDKOV5640.c **** 					//CyU3PDebugPrint (4, "\n\rset UVC__STILL_IMAGE: glstillSkip 0");
 494:../CX3RDKOV5640.c ****             	}
 495:../CX3RDKOV5640.c ****             	else
 496:../CX3RDKOV5640.c ****             		glStillSkip--;
 1023              		.loc 1 496 0
 1024 0340 54309FE5 		ldr	r3, .L42+60
 1025 0344 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1026 0348 013043E2 		sub	r3, r3, #1
 1027 034c FF2003E2 		and	r2, r3, #255
 1028 0350 44309FE5 		ldr	r3, .L42+60
 1029 0354 0020C3E5 		strb	r2, [r3]
 1030              	.L27:
 497:../CX3RDKOV5640.c ****             }
 498:../CX3RDKOV5640.c ****         }
 499:../CX3RDKOV5640.c ****     }
 500:../CX3RDKOV5640.c **** }
 1031              		.loc 1 500 0
 1032 0358 04D04BE2 		sub	sp, fp, #4
 1033              		@ sp needed
 1034 035c 0088BDE8 		ldmfd	sp!, {fp, pc}
 1035              	.L43:
 1036              		.align	2
 1037              	.L42:
 1038 0360 00000000 		.word	doLpmDisable
 1039 0364 00000000 		.word	UvcTimer
 1040 0368 00000000 		.word	ES_UVC_DATA_BUF_SIZE
 1041 036c 00000000 		.word	glHitFV
 1042 0370 00000000 		.word	glTimerEvent
 1043 0374 00000000 		.word	glDMATxCount
 1044 0378 00000000 		.word	glDmaDone
 1045 037c 00000000 		.word	glActiveSocket
 1046 0380 00000000 		.word	glIsStreamingStarted
 1047 0384 01010000 		.word	257
 1048 0388 00000000 		.word	glStillCaptured
 1049 038c 00000000 		.word	glUVCHeader
 1050 0390 00000000 		.word	glCurrentFrameIndex
 1051 0394 00000000 		.word	glFrameIndexToSet
 1052 0398 00000000 		.word	glStillCaptureStart
 1053 039c 00000000 		.word	glStillSkip
 1054              		.cfi_endproc
 1055              	.LFE6:
 1057              		.section	.text.esUVCUvcApplnUSBEventCB,"ax",%progbits
 1058              		.align	2
 1060              	esUVCUvcApplnUSBEventCB:
 1061              	.LFB7:
 501:../CX3RDKOV5640.c **** 
 502:../CX3RDKOV5640.c **** /* This is the Callback function to handle the USB Events */
 503:../CX3RDKOV5640.c ****     static void
 504:../CX3RDKOV5640.c **** esUVCUvcApplnUSBEventCB (
 505:../CX3RDKOV5640.c ****         CyU3PUsbEventType_t evtype,     /* Event type */
 506:../CX3RDKOV5640.c ****         uint16_t            evdata      /* Event data */
 507:../CX3RDKOV5640.c ****         )
 508:../CX3RDKOV5640.c **** {
 1062              		.loc 1 508 0
 1063              		.cfi_startproc
 1064              		@ args = 0, pretend = 0, frame = 16
 1065              		@ frame_needed = 1, uses_anonymous_args = 0
 1066 0000 00482DE9 		stmfd	sp!, {fp, lr}
 1067              	.LCFI14:
 1068              		.cfi_def_cfa_offset 8
 1069              		.cfi_offset 11, -8
 1070              		.cfi_offset 14, -4
 1071 0004 04B08DE2 		add	fp, sp, #4
 1072              	.LCFI15:
 1073              		.cfi_def_cfa 11, 4
 1074 0008 10D04DE2 		sub	sp, sp, #16
 1075 000c 0020A0E1 		mov	r2, r0
 1076 0010 0130A0E1 		mov	r3, r1
 1077 0014 0D204BE5 		strb	r2, [fp, #-13]
 1078 0018 B0314BE1 		strh	r3, [fp, #-16]	@ movhi
 509:../CX3RDKOV5640.c ****     uint8_t interface = 0, altSetting = 0;
 1079              		.loc 1 509 0
 1080 001c 0030A0E3 		mov	r3, #0
 1081 0020 05304BE5 		strb	r3, [fp, #-5]
 1082 0024 0030A0E3 		mov	r3, #0
 1083 0028 06304BE5 		strb	r3, [fp, #-6]
 510:../CX3RDKOV5640.c **** 
 511:../CX3RDKOV5640.c ****     switch (evtype)
 1084              		.loc 1 511 0
 1085 002c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1086 0030 070053E3 		cmp	r3, #7
 1087 0034 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1088 0038 530000EA 		b	.L57
 1089              	.L47:
 1090 003c 2C010000 		.word	.L46
 1091 0040 2C010000 		.word	.L46
 1092 0044 5C000000 		.word	.L48
 1093 0048 8C010000 		.word	.L57
 1094 004c 2C010000 		.word	.L46
 1095 0050 2C010000 		.word	.L46
 1096 0054 8C010000 		.word	.L57
 1097 0058 7C000000 		.word	.L49
 1098              	.L48:
 512:../CX3RDKOV5640.c ****     {
 513:../CX3RDKOV5640.c ****         case CY_U3P_USB_EVENT_SUSPEND:
 514:../CX3RDKOV5640.c ****             /* Suspend the device with Wake On Bus Activity set */
 515:../CX3RDKOV5640.c ****             glIsStreamingStarted = CyFalse;
 1099              		.loc 1 515 0
 1100 005c 34319FE5 		ldr	r3, .L58
 1101 0060 0020A0E3 		mov	r2, #0
 1102 0064 002083E5 		str	r2, [r3]
 516:../CX3RDKOV5640.c ****             CyU3PEventSet (&glTimerEvent, ES_USB_SUSP_EVENT_FLAG, CYU3P_EVENT_OR);
 1103              		.loc 1 516 0
 1104 0068 2C019FE5 		ldr	r0, .L58+4
 1105 006c 2010A0E3 		mov	r1, #32
 1106 0070 0020A0E3 		mov	r2, #0
 1107 0074 FEFFFFEB 		bl	_txe_event_flags_set
 517:../CX3RDKOV5640.c ****             break;
 1108              		.loc 1 517 0
 1109 0078 440000EA 		b	.L44
 1110              	.L49:
 518:../CX3RDKOV5640.c ****         case CY_U3P_USB_EVENT_SETINTF:
 519:../CX3RDKOV5640.c ****             /* Start the video streamer application if the
 520:../CX3RDKOV5640.c ****              * interface requested was 1. If not, stop the
 521:../CX3RDKOV5640.c ****              * streamer. */
 522:../CX3RDKOV5640.c ****             interface = CY_U3P_GET_MSB(evdata);
 1111              		.loc 1 522 0
 1112 007c B0315BE1 		ldrh	r3, [fp, #-16]
 1113 0080 2334A0E1 		mov	r3, r3, lsr #8
 1114 0084 0338A0E1 		mov	r3, r3, asl #16
 1115 0088 2338A0E1 		mov	r3, r3, lsr #16
 1116 008c 05304BE5 		strb	r3, [fp, #-5]
 523:../CX3RDKOV5640.c ****             altSetting = CY_U3P_GET_LSB(evdata);
 1117              		.loc 1 523 0
 1118 0090 B0315BE1 		ldrh	r3, [fp, #-16]	@ movhi
 1119 0094 06304BE5 		strb	r3, [fp, #-6]
 524:../CX3RDKOV5640.c **** 
 525:../CX3RDKOV5640.c ****             glIsStreamingStarted = CyFalse;
 1120              		.loc 1 525 0
 1121 0098 F8309FE5 		ldr	r3, .L58
 1122 009c 0020A0E3 		mov	r2, #0
 1123 00a0 002083E5 		str	r2, [r3]
 526:../CX3RDKOV5640.c **** 
 527:../CX3RDKOV5640.c ****             if ((altSetting == ES_UVC_STREAM_INTERFACE) && (interface == 1))
 1124              		.loc 1 527 0
 1125 00a4 06305BE5 		ldrb	r3, [fp, #-6]	@ zero_extendqisi2
 1126 00a8 010053E3 		cmp	r3, #1
 1127 00ac 0C00001A 		bne	.L51
 1128              		.loc 1 527 0 is_stmt 0 discriminator 1
 1129 00b0 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1130 00b4 010053E3 		cmp	r3, #1
 1131 00b8 0900001A 		bne	.L51
 528:../CX3RDKOV5640.c ****             {
 529:../CX3RDKOV5640.c ****                 /* Stop the application before re-starting. */
 530:../CX3RDKOV5640.c ****                 if (glIsApplnActive)
 1132              		.loc 1 530 0 is_stmt 1
 1133 00bc DC309FE5 		ldr	r3, .L58+8
 1134 00c0 003093E5 		ldr	r3, [r3]
 1135 00c4 000053E3 		cmp	r3, #0
 1136 00c8 0300000A 		beq	.L52
 531:../CX3RDKOV5640.c ****                 {
 532:../CX3RDKOV5640.c ****                 	glIsClearFeature = CyTrue;
 1137              		.loc 1 532 0
 1138 00cc D0309FE5 		ldr	r3, .L58+12
 1139 00d0 0120A0E3 		mov	r2, #1
 1140 00d4 002083E5 		str	r2, [r3]
 533:../CX3RDKOV5640.c ****                     esUVCUvcApplnStop ();
 1141              		.loc 1 533 0
 1142 00d8 FEFFFFEB 		bl	esUVCUvcApplnStop
 1143              	.L52:
 534:../CX3RDKOV5640.c **** #ifdef VISDebug
 535:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rCY_U3P_USB_EVENT_SETINTF&ES_UVC_STREAM_INTERFACE: esUVCUvcApplnStop");
 536:../CX3RDKOV5640.c **** #endif
 537:../CX3RDKOV5640.c ****                 }
 538:../CX3RDKOV5640.c ****                 esUVCUvcApplnStart ();
 1144              		.loc 1 538 0
 1145 00dc FEFFFFEB 		bl	esUVCUvcApplnStart
 1146 00e0 100000EA 		b	.L53
 1147              	.L51:
 539:../CX3RDKOV5640.c **** #ifdef VISDebug
 540:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rCY_U3P_USB_EVENT_SETINTF&ES_UVC_STREAM_INTERFACE: esUVCUvcApplnStart")
 541:../CX3RDKOV5640.c **** #endif
 542:../CX3RDKOV5640.c **** 
 543:../CX3RDKOV5640.c ****             }
 544:../CX3RDKOV5640.c ****             else if ((altSetting == 0x00) && (interface == 1))
 1148              		.loc 1 544 0
 1149 00e4 06305BE5 		ldrb	r3, [fp, #-6]	@ zero_extendqisi2
 1150 00e8 000053E3 		cmp	r3, #0
 1151 00ec 0D00001A 		bne	.L53
 1152              		.loc 1 544 0 is_stmt 0 discriminator 1
 1153 00f0 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1154 00f4 010053E3 		cmp	r3, #1
 1155 00f8 0A00001A 		bne	.L53
 545:../CX3RDKOV5640.c ****             {
 546:../CX3RDKOV5640.c ****             	glPreviewStarted = CyFalse;
 1156              		.loc 1 546 0 is_stmt 1
 1157 00fc A4309FE5 		ldr	r3, .L58+16
 1158 0100 0020A0E3 		mov	r2, #0
 1159 0104 002083E5 		str	r2, [r3]
 547:../CX3RDKOV5640.c ****             	/* Stop the application before re-starting. */
 548:../CX3RDKOV5640.c ****             	glIsClearFeature = CyTrue;
 1160              		.loc 1 548 0
 1161 0108 94309FE5 		ldr	r3, .L58+12
 1162 010c 0120A0E3 		mov	r2, #1
 1163 0110 002083E5 		str	r2, [r3]
 549:../CX3RDKOV5640.c **** 				esUVCUvcApplnStop ();
 1164              		.loc 1 549 0
 1165 0114 FEFFFFEB 		bl	esUVCUvcApplnStop
 550:../CX3RDKOV5640.c **** 
 551:../CX3RDKOV5640.c **** 				glcommitcount = 0;
 1166              		.loc 1 551 0
 1167 0118 8C309FE5 		ldr	r3, .L58+20
 1168 011c 0020A0E3 		mov	r2, #0
 1169 0120 0020C3E5 		strb	r2, [r3]
 552:../CX3RDKOV5640.c **** #ifdef VISDebug
 553:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rCY_U3P_USB_EVENT_SETINTF: esUVCUvcApplnStop");
 554:../CX3RDKOV5640.c **** #endif
 555:../CX3RDKOV5640.c ****             }
 556:../CX3RDKOV5640.c ****             break;
 1170              		.loc 1 556 0
 1171 0124 190000EA 		b	.L44
 1172              	.L53:
 1173 0128 180000EA 		b	.L44
 1174              	.L46:
 557:../CX3RDKOV5640.c **** 
 558:../CX3RDKOV5640.c ****             /* Fall-through. */
 559:../CX3RDKOV5640.c **** 
 560:../CX3RDKOV5640.c ****         case CY_U3P_USB_EVENT_SETCONF:
 561:../CX3RDKOV5640.c ****         case CY_U3P_USB_EVENT_RESET:
 562:../CX3RDKOV5640.c ****         case CY_U3P_USB_EVENT_DISCONNECT:
 563:../CX3RDKOV5640.c ****         case CY_U3P_USB_EVENT_CONNECT:
 564:../CX3RDKOV5640.c ****             glIsStreamingStarted = CyFalse;
 1175              		.loc 1 564 0
 1176 012c 64309FE5 		ldr	r3, .L58
 1177 0130 0020A0E3 		mov	r2, #0
 1178 0134 002083E5 		str	r2, [r3]
 565:../CX3RDKOV5640.c ****             if (evtype == CY_U3P_USB_EVENT_SETCONF)
 1179              		.loc 1 565 0
 1180 0138 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1181 013c 050053E3 		cmp	r3, #5
 1182 0140 0300001A 		bne	.L54
 566:../CX3RDKOV5640.c ****                 glIsConfigured = CyTrue;
 1183              		.loc 1 566 0
 1184 0144 64309FE5 		ldr	r3, .L58+24
 1185 0148 0120A0E3 		mov	r2, #1
 1186 014c 002083E5 		str	r2, [r3]
 1187 0150 020000EA 		b	.L55
 1188              	.L54:
 567:../CX3RDKOV5640.c ****             else
 568:../CX3RDKOV5640.c ****                 glIsConfigured = CyFalse;
 1189              		.loc 1 568 0
 1190 0154 54309FE5 		ldr	r3, .L58+24
 1191 0158 0020A0E3 		mov	r2, #0
 1192 015c 002083E5 		str	r2, [r3]
 1193              	.L55:
 569:../CX3RDKOV5640.c **** 
 570:../CX3RDKOV5640.c ****             /* Stop the video streamer application and enable LPM. */
 571:../CX3RDKOV5640.c ****             CyU3PUsbLPMEnable ();
 1194              		.loc 1 571 0
 1195 0160 FEFFFFEB 		bl	CyU3PUsbLPMEnable
 572:../CX3RDKOV5640.c ****             if (glIsApplnActive)
 1196              		.loc 1 572 0
 1197 0164 34309FE5 		ldr	r3, .L58+8
 1198 0168 003093E5 		ldr	r3, [r3]
 1199 016c 000053E3 		cmp	r3, #0
 1200 0170 0400000A 		beq	.L56
 573:../CX3RDKOV5640.c ****             {
 574:../CX3RDKOV5640.c ****             	glIsClearFeature = CyTrue;
 1201              		.loc 1 574 0
 1202 0174 28309FE5 		ldr	r3, .L58+12
 1203 0178 0120A0E3 		mov	r2, #1
 1204 017c 002083E5 		str	r2, [r3]
 575:../CX3RDKOV5640.c ****                 esUVCUvcApplnStop ();
 1205              		.loc 1 575 0
 1206 0180 FEFFFFEB 		bl	esUVCUvcApplnStop
 576:../CX3RDKOV5640.c **** #ifdef VISDebug
 577:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rEvent %x: esUVCUvcApplnStop", evtype);
 578:../CX3RDKOV5640.c **** #endif
 579:../CX3RDKOV5640.c ****             }
 580:../CX3RDKOV5640.c ****             break;
 1207              		.loc 1 580 0
 1208 0184 010000EA 		b	.L44
 1209              	.L56:
 1210 0188 000000EA 		b	.L44
 1211              	.L57:
 581:../CX3RDKOV5640.c ****         default:
 582:../CX3RDKOV5640.c ****             break;
 1212              		.loc 1 582 0
 1213 018c 0000A0E1 		mov	r0, r0	@ nop
 1214              	.L44:
 583:../CX3RDKOV5640.c ****     }
 584:../CX3RDKOV5640.c **** }
 1215              		.loc 1 584 0
 1216 0190 04D04BE2 		sub	sp, fp, #4
 1217              		@ sp needed
 1218 0194 0088BDE8 		ldmfd	sp!, {fp, pc}
 1219              	.L59:
 1220              		.align	2
 1221              	.L58:
 1222 0198 00000000 		.word	glIsStreamingStarted
 1223 019c 00000000 		.word	glTimerEvent
 1224 01a0 00000000 		.word	glIsApplnActive
 1225 01a4 00000000 		.word	glIsClearFeature
 1226 01a8 00000000 		.word	glPreviewStarted
 1227 01ac 00000000 		.word	glcommitcount
 1228 01b0 00000000 		.word	glIsConfigured
 1229              		.cfi_endproc
 1230              	.LFE7:
 1232              		.section	.text.esUVCApplnLPMRqtCB,"ax",%progbits
 1233              		.align	2
 1235              	esUVCApplnLPMRqtCB:
 1236              	.LFB8:
 585:../CX3RDKOV5640.c **** 
 586:../CX3RDKOV5640.c **** /* Callback for LPM requests. Always return true to allow host to transition device
 587:../CX3RDKOV5640.c ****  * into required LPM state U1/U2/U3. When data transmission is active LPM management
 588:../CX3RDKOV5640.c ****  * is explicitly disabled to prevent data transmission errors.
 589:../CX3RDKOV5640.c ****  */
 590:../CX3RDKOV5640.c **** static CyBool_t esUVCApplnLPMRqtCB (
 591:../CX3RDKOV5640.c ****         CyU3PUsbLinkPowerMode link_mode         /*USB 3.0 linkmode requested by Host */
 592:../CX3RDKOV5640.c ****         )
 593:../CX3RDKOV5640.c **** {
 1237              		.loc 1 593 0
 1238              		.cfi_startproc
 1239              		@ args = 0, pretend = 0, frame = 8
 1240              		@ frame_needed = 1, uses_anonymous_args = 0
 1241              		@ link register save eliminated.
 1242 0000 04B02DE5 		str	fp, [sp, #-4]!
 1243              	.LCFI16:
 1244              		.cfi_def_cfa_offset 4
 1245              		.cfi_offset 11, -4
 1246 0004 00B08DE2 		add	fp, sp, #0
 1247              	.LCFI17:
 1248              		.cfi_def_cfa_register 11
 1249 0008 0CD04DE2 		sub	sp, sp, #12
 1250 000c 0030A0E1 		mov	r3, r0
 1251 0010 05304BE5 		strb	r3, [fp, #-5]
 594:../CX3RDKOV5640.c ****     return CyTrue;
 1252              		.loc 1 594 0
 1253 0014 0130A0E3 		mov	r3, #1
 595:../CX3RDKOV5640.c **** }
 1254              		.loc 1 595 0
 1255 0018 0300A0E1 		mov	r0, r3
 1256 001c 00D04BE2 		sub	sp, fp, #0
 1257              		@ sp needed
 1258 0020 04B09DE4 		ldr	fp, [sp], #4
 1259 0024 1EFF2FE1 		bx	lr
 1260              		.cfi_endproc
 1261              	.LFE8:
 1263              		.section	.rodata
 1264              		.align	2
 1265              	.LC5:
 1266 00a8 0A0D6573 		.ascii	"\012\015esSetCameraResolution %d\000"
 1266      53657443 
 1266      616D6572 
 1266      61526573 
 1266      6F6C7574 
 1267 00c3 00       		.align	2
 1268              	.LC6:
 1269 00c4 0A0D5553 		.ascii	"\012\015USBStpCB:SetIntfParams SS1 Err = 0x%x\000"
 1269      42537470 
 1269      43423A53 
 1269      6574496E 
 1269      74665061 
 1270              		.align	2
 1271              	.LC7:
 1272 00ec 0A0D5553 		.ascii	"\012\015USBStpCB:SetIntfParams FS Err = 0x%x\000"
 1272      42537470 
 1272      43423A53 
 1272      6574496E 
 1272      74665061 
 1273 0113 00       		.align	2
 1274              	.LC8:
 1275 0114 0A0D5553 		.ascii	"\012\015USBStpCB:SetIntfParams SS2 Err = 0x%x\000"
 1275      42537470 
 1275      43423A53 
 1275      6574496E 
 1275      74665061 
 1276              		.align	2
 1277              	.LC9:
 1278 013c 0A0D5553 		.ascii	"\012\015USBStpCB:SetIntfParams HS Err = 0x%x\000"
 1278      42537470 
 1278      43423A53 
 1278      6574496E 
 1278      74665061 
 1279              		.section	.text.esSetCameraResolution,"ax",%progbits
 1280              		.align	2
 1281              		.global	esSetCameraResolution
 1283              	esSetCameraResolution:
 1284              	.LFB9:
 596:../CX3RDKOV5640.c **** 
 597:../CX3RDKOV5640.c **** //TODO Change this function with "Sensor Specific" function to write the sensor settings & configur
 598:../CX3RDKOV5640.c **** void esSetCameraResolution(uint8_t FrameIndex)
 599:../CX3RDKOV5640.c **** {
 1285              		.loc 1 599 0
 1286              		.cfi_startproc
 1287              		@ args = 0, pretend = 0, frame = 16
 1288              		@ frame_needed = 1, uses_anonymous_args = 0
 1289 0000 00482DE9 		stmfd	sp!, {fp, lr}
 1290              	.LCFI18:
 1291              		.cfi_def_cfa_offset 8
 1292              		.cfi_offset 11, -8
 1293              		.cfi_offset 14, -4
 1294 0004 04B08DE2 		add	fp, sp, #4
 1295              	.LCFI19:
 1296              		.cfi_def_cfa 11, 4
 1297 0008 10D04DE2 		sub	sp, sp, #16
 1298 000c 0030A0E1 		mov	r3, r0
 1299 0010 0D304BE5 		strb	r3, [fp, #-13]
 600:../CX3RDKOV5640.c **** 	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 1300              		.loc 1 600 0
 1301 0014 0030A0E3 		mov	r3, #0
 1302 0018 08300BE5 		str	r3, [fp, #-8]
 601:../CX3RDKOV5640.c **** 	CyU3PDebugPrint (4, "\n\resSetCameraResolution %d", FrameIndex);
 1303              		.loc 1 601 0
 1304 001c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1305 0020 0400A0E3 		mov	r0, #4
 1306 0024 80119FE5 		ldr	r1, .L74
 1307 0028 0320A0E1 		mov	r2, r3
 1308 002c FEFFFFEB 		bl	CyU3PDebugPrint
 602:../CX3RDKOV5640.c **** 	FrameIndex = 0x03; //force to set VGA 30fps -debug
 1309              		.loc 1 602 0
 1310 0030 0330A0E3 		mov	r3, #3
 1311 0034 0D304BE5 		strb	r3, [fp, #-13]
 603:../CX3RDKOV5640.c **** 	/* Super Speed USB Streams*/
 604:../CX3RDKOV5640.c **** 	if (CyU3PUsbGetSpeed () == CY_U3P_SUPER_SPEED)
 1312              		.loc 1 604 0
 1313 0038 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1314 003c 0030A0E1 		mov	r3, r0
 1315 0040 030053E3 		cmp	r3, #3
 1316 0044 3B00001A 		bne	.L63
 605:../CX3RDKOV5640.c **** 	{
 606:../CX3RDKOV5640.c **** 		if(FrameIndex == 0x01)
 1317              		.loc 1 606 0
 1318 0048 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1319 004c 010053E3 		cmp	r3, #1
 1320 0050 0B00001A 		bne	.L64
 607:../CX3RDKOV5640.c **** 		{
 608:../CX3RDKOV5640.c **** 			/* Write 1080pSettings */
 609:../CX3RDKOV5640.c **** 			status = CyU3PMipicsiSetIntfParams (&cfgUvc1080p30NoMclk, CyTrue/*CyFalse*/);
 1321              		.loc 1 609 0
 1322 0054 54019FE5 		ldr	r0, .L74+4
 1323 0058 0110A0E3 		mov	r1, #1
 1324 005c FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 1325 0060 08000BE5 		str	r0, [fp, #-8]
 610:../CX3RDKOV5640.c **** 			if (status != CY_U3P_SUCCESS)
 1326              		.loc 1 610 0
 1327 0064 08301BE5 		ldr	r3, [fp, #-8]
 1328 0068 000053E3 		cmp	r3, #0
 1329 006c 4C00000A 		beq	.L62
 611:../CX3RDKOV5640.c **** 			{
 612:../CX3RDKOV5640.c **** 				CyU3PDebugPrint (4, "\n\rUSBStpCB:SetIntfParams SS1 Err = 0x%x", status);
 1330              		.loc 1 612 0
 1331 0070 0400A0E3 		mov	r0, #4
 1332 0074 38119FE5 		ldr	r1, .L74+8
 1333 0078 08201BE5 		ldr	r2, [fp, #-8]
 1334 007c FEFFFFEB 		bl	CyU3PDebugPrint
 1335 0080 470000EA 		b	.L62
 1336              	.L64:
 613:../CX3RDKOV5640.c **** 			}
 614:../CX3RDKOV5640.c **** 			//esOV5640_1080P_config();
 615:../CX3RDKOV5640.c **** 		}
 616:../CX3RDKOV5640.c **** 		else if(FrameIndex == 0x02)
 1337              		.loc 1 616 0
 1338 0084 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1339 0088 020053E3 		cmp	r3, #2
 1340 008c 0B00001A 		bne	.L67
 617:../CX3RDKOV5640.c **** 		{
 618:../CX3RDKOV5640.c **** 			/* Write VGA Settings */
 619:../CX3RDKOV5640.c **** 			status = CyU3PMipicsiSetIntfParams (&cfgUvcVga30NoMclk, CyTrue/*CyFalse*/);
 1341              		.loc 1 619 0
 1342 0090 20019FE5 		ldr	r0, .L74+12
 1343 0094 0110A0E3 		mov	r1, #1
 1344 0098 FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 1345 009c 08000BE5 		str	r0, [fp, #-8]
 620:../CX3RDKOV5640.c **** 			if (status != CY_U3P_SUCCESS)
 1346              		.loc 1 620 0
 1347 00a0 08301BE5 		ldr	r3, [fp, #-8]
 1348 00a4 000053E3 		cmp	r3, #0
 1349 00a8 3D00000A 		beq	.L62
 621:../CX3RDKOV5640.c **** 			{
 622:../CX3RDKOV5640.c **** 				CyU3PDebugPrint (4, "\n\rUSBStpCB:SetIntfParams FS Err = 0x%x", status);
 1350              		.loc 1 622 0
 1351 00ac 0400A0E3 		mov	r0, #4
 1352 00b0 04119FE5 		ldr	r1, .L74+16
 1353 00b4 08201BE5 		ldr	r2, [fp, #-8]
 1354 00b8 FEFFFFEB 		bl	CyU3PDebugPrint
 1355 00bc 380000EA 		b	.L62
 1356              	.L67:
 623:../CX3RDKOV5640.c **** 			}
 624:../CX3RDKOV5640.c **** 			//esOV5640_VGA_config(); //for experiment
 625:../CX3RDKOV5640.c **** 		}
 626:../CX3RDKOV5640.c **** 		else if(FrameIndex == 0x03)
 1357              		.loc 1 626 0
 1358 00c0 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1359 00c4 030053E3 		cmp	r3, #3
 1360 00c8 0B00001A 		bne	.L69
 627:../CX3RDKOV5640.c **** 		{
 628:../CX3RDKOV5640.c **** 			/* Write 720pSettings */
 629:../CX3RDKOV5640.c **** 			status = CyU3PMipicsiSetIntfParams (&cfgUvc720p60NoMclk, CyFalse);
 1361              		.loc 1 629 0
 1362 00cc EC009FE5 		ldr	r0, .L74+20
 1363 00d0 0010A0E3 		mov	r1, #0
 1364 00d4 FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 1365 00d8 08000BE5 		str	r0, [fp, #-8]
 630:../CX3RDKOV5640.c **** 			if (status != CY_U3P_SUCCESS)
 1366              		.loc 1 630 0
 1367 00dc 08301BE5 		ldr	r3, [fp, #-8]
 1368 00e0 000053E3 		cmp	r3, #0
 1369 00e4 2E00000A 		beq	.L62
 631:../CX3RDKOV5640.c **** 			{
 632:../CX3RDKOV5640.c **** 				CyU3PDebugPrint (4, "\n\rUSBStpCB:SetIntfParams SS2 Err = 0x%x", status);
 1370              		.loc 1 632 0
 1371 00e8 0400A0E3 		mov	r0, #4
 1372 00ec D0109FE5 		ldr	r1, .L74+24
 1373 00f0 08201BE5 		ldr	r2, [fp, #-8]
 1374 00f4 FEFFFFEB 		bl	CyU3PDebugPrint
 1375 00f8 290000EA 		b	.L62
 1376              	.L69:
 633:../CX3RDKOV5640.c **** 			}
 634:../CX3RDKOV5640.c **** 			//esOV5640_VGA_config();//esOV5640_720P_config(); //for experiment
 635:../CX3RDKOV5640.c **** 			//CyU3PThreadSleep(1000);
 636:../CX3RDKOV5640.c **** 			//SensorGetControl(0x02, 0x30);
 637:../CX3RDKOV5640.c **** 		}
 638:../CX3RDKOV5640.c **** 		else if(FrameIndex == 0x04)
 1377              		.loc 1 638 0
 1378 00fc 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1379 0100 040053E3 		cmp	r3, #4
 1380 0104 2600001A 		bne	.L62
 639:../CX3RDKOV5640.c **** 		{
 640:../CX3RDKOV5640.c **** 			status = CyU3PMipicsiSetIntfParams (&cfgUvc5Mp15NoMclk, CyTrue/*CyFalse*/);
 1381              		.loc 1 640 0
 1382 0108 B8009FE5 		ldr	r0, .L74+28
 1383 010c 0110A0E3 		mov	r1, #1
 1384 0110 FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 1385 0114 08000BE5 		str	r0, [fp, #-8]
 641:../CX3RDKOV5640.c **** 			if (status != CY_U3P_SUCCESS)
 1386              		.loc 1 641 0
 1387 0118 08301BE5 		ldr	r3, [fp, #-8]
 1388 011c 000053E3 		cmp	r3, #0
 1389 0120 1F00000A 		beq	.L62
 642:../CX3RDKOV5640.c **** 			{
 643:../CX3RDKOV5640.c **** 				CyU3PDebugPrint (4, "\n\rUSBStpCB:SetIntfParams SS2 Err = 0x%x", status);
 1390              		.loc 1 643 0
 1391 0124 0400A0E3 		mov	r0, #4
 1392 0128 94109FE5 		ldr	r1, .L74+24
 1393 012c 08201BE5 		ldr	r2, [fp, #-8]
 1394 0130 FEFFFFEB 		bl	CyU3PDebugPrint
 1395 0134 1A0000EA 		b	.L62
 1396              	.L63:
 644:../CX3RDKOV5640.c **** 			}
 645:../CX3RDKOV5640.c **** 			//esOV5640_5MP_config();
 646:../CX3RDKOV5640.c **** 		}
 647:../CX3RDKOV5640.c **** 	}
 648:../CX3RDKOV5640.c **** 	/* High Speed USB Streams*/
 649:../CX3RDKOV5640.c **** 	else if (CyU3PUsbGetSpeed () == CY_U3P_HIGH_SPEED)
 1397              		.loc 1 649 0
 1398 0138 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1399 013c 0030A0E1 		mov	r3, r0
 1400 0140 020053E3 		cmp	r3, #2
 1401 0144 0B00001A 		bne	.L72
 650:../CX3RDKOV5640.c **** 	{
 651:../CX3RDKOV5640.c **** 		/* Write VGA Settings */
 652:../CX3RDKOV5640.c **** 		status = CyU3PMipicsiSetIntfParams (&cfgUvcVga30NoMclk, CyFalse);
 1402              		.loc 1 652 0
 1403 0148 68009FE5 		ldr	r0, .L74+12
 1404 014c 0010A0E3 		mov	r1, #0
 1405 0150 FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 1406 0154 08000BE5 		str	r0, [fp, #-8]
 653:../CX3RDKOV5640.c **** 		if (status != CY_U3P_SUCCESS)
 1407              		.loc 1 653 0
 1408 0158 08301BE5 		ldr	r3, [fp, #-8]
 1409 015c 000053E3 		cmp	r3, #0
 1410 0160 0F00000A 		beq	.L62
 654:../CX3RDKOV5640.c **** 		{
 655:../CX3RDKOV5640.c **** 			CyU3PDebugPrint (4, "\n\rUSBStpCB:SetIntfParams HS Err = 0x%x", status);
 1411              		.loc 1 655 0
 1412 0164 0400A0E3 		mov	r0, #4
 1413 0168 5C109FE5 		ldr	r1, .L74+32
 1414 016c 08201BE5 		ldr	r2, [fp, #-8]
 1415 0170 FEFFFFEB 		bl	CyU3PDebugPrint
 1416 0174 0A0000EA 		b	.L62
 1417              	.L72:
 656:../CX3RDKOV5640.c **** 		}
 657:../CX3RDKOV5640.c **** 		//esOV5640_VGA_config();
 658:../CX3RDKOV5640.c **** 		//esOV5640_VGA_HS_config();
 659:../CX3RDKOV5640.c **** 	}
 660:../CX3RDKOV5640.c **** 	/* Full Speed USB Streams*/
 661:../CX3RDKOV5640.c **** 	else
 662:../CX3RDKOV5640.c **** 	{
 663:../CX3RDKOV5640.c **** 		/* Write VGA Settings */
 664:../CX3RDKOV5640.c **** 		//esOV5640_VGA_config();
 665:../CX3RDKOV5640.c **** 		status = CyU3PMipicsiSetIntfParams (&cfgUvcVga30NoMclk, CyFalse);
 1418              		.loc 1 665 0
 1419 0178 38009FE5 		ldr	r0, .L74+12
 1420 017c 0010A0E3 		mov	r1, #0
 1421 0180 FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 1422 0184 08000BE5 		str	r0, [fp, #-8]
 666:../CX3RDKOV5640.c **** 		if (status != CY_U3P_SUCCESS)
 1423              		.loc 1 666 0
 1424 0188 08301BE5 		ldr	r3, [fp, #-8]
 1425 018c 000053E3 		cmp	r3, #0
 1426 0190 0300000A 		beq	.L62
 667:../CX3RDKOV5640.c **** 		{
 668:../CX3RDKOV5640.c **** 			CyU3PDebugPrint (4, "\n\rUSBStpCB:SetIntfParams FS Err = 0x%x", status);
 1427              		.loc 1 668 0
 1428 0194 0400A0E3 		mov	r0, #4
 1429 0198 1C109FE5 		ldr	r1, .L74+16
 1430 019c 08201BE5 		ldr	r2, [fp, #-8]
 1431 01a0 FEFFFFEB 		bl	CyU3PDebugPrint
 1432              	.L62:
 669:../CX3RDKOV5640.c **** 		}
 670:../CX3RDKOV5640.c **** 	}
 671:../CX3RDKOV5640.c **** }
 1433              		.loc 1 671 0
 1434 01a4 04D04BE2 		sub	sp, fp, #4
 1435              		@ sp needed
 1436 01a8 0088BDE8 		ldmfd	sp!, {fp, pc}
 1437              	.L75:
 1438              		.align	2
 1439              	.L74:
 1440 01ac A8000000 		.word	.LC5
 1441 01b0 00000000 		.word	cfgUvc1080p30NoMclk
 1442 01b4 C4000000 		.word	.LC6
 1443 01b8 00000000 		.word	cfgUvcVga30NoMclk
 1444 01bc EC000000 		.word	.LC7
 1445 01c0 00000000 		.word	cfgUvc720p60NoMclk
 1446 01c4 14010000 		.word	.LC8
 1447 01c8 00000000 		.word	cfgUvc5Mp15NoMclk
 1448 01cc 3C010000 		.word	.LC9
 1449              		.cfi_endproc
 1450              	.LFE9:
 1452              		.section	.rodata
 1453 0163 00       		.align	2
 1454              	.LC10:
 1455 0164 0A0D6252 		.ascii	"\012\015bRType = 0x%x, bRequest = 0x%x, wValue = 0x"
 1455      54797065 
 1455      203D2030 
 1455      7825782C 
 1455      20625265 
 1456 0191 25782C20 		.ascii	"%x, wIndex = 0x%x, wLength= 0x%x\000"
 1456      77496E64 
 1456      6578203D 
 1456      20307825 
 1456      782C2077 
 1457 01b2 0000     		.align	2
 1458              	.LC11:
 1459 01b4 0A0D4675 		.ascii	"\012\015Full Speed Not Supported!\000"
 1459      6C6C2053 
 1459      70656564 
 1459      204E6F74 
 1459      20537570 
 1460              		.align	2
 1461              	.LC12:
 1462 01d0 0A0D5553 		.ascii	"\012\015USBStpCB:GET_CUR:SendEP0Data Err = 0x%x\000"
 1462      42537470 
 1462      43423A47 
 1462      45545F43 
 1462      55523A53 
 1463 01fa 0000     		.align	2
 1464              	.LC13:
 1465 01fc 0A0D5553 		.ascii	"\012\015USBStpCB:SET_CUR:GetEP0Data Err = 0x%x.\000"
 1465      42537470 
 1465      43423A53 
 1465      45545F43 
 1465      55523A47 
 1466 0226 0000     		.align	2
 1467              	.LC14:
 1468 0228 0A0D5553 		.ascii	"\012\015USBStpCB:Invalid SET_CUR Rqt Len.\000"
 1468      42537470 
 1468      43423A49 
 1468      6E76616C 
 1468      69642053 
 1469              		.align	2
 1470              	.LC15:
 1471 024c 0A0D5553 		.ascii	"\012\015USBStpCB:SET_CUR:still = 0x%x.\000"
 1471      42537470 
 1471      43423A53 
 1471      45545F43 
 1471      55523A73 
 1472 026d 000000   		.align	2
 1473              	.LC16:
 1474 0270 0A0D2025 		.ascii	"\012\015 %d %d %d %d %d %d %d %d %d %d %d\015\012\000"
 1474      64202564 
 1474      20256420 
 1474      25642025 
 1474      64202564 
 1475 0296 0000     		.align	2
 1476              	.LC17:
 1477 0298 0A0D5553 		.ascii	"\012\015USBStpCB:control interface wIndex = 0x%x wV"
 1477      42537470 
 1477      43423A63 
 1477      6F6E7472 
 1477      6F6C2069 
 1478 02c5 616C7565 		.ascii	"alue = 0x%x bRequest = 0x%x\000"
 1478      203D2030 
 1478      78257820 
 1478      62526571 
 1478      75657374 
 1479              		.section	.text.esUVCUvcApplnUSBSetupCB,"ax",%progbits
 1480              		.align	2
 1482              	esUVCUvcApplnUSBSetupCB:
 1483              	.LFB10:
 672:../CX3RDKOV5640.c **** 
 673:../CX3RDKOV5640.c **** /* Callback to handle the USB Setup Requests and UVC Class events */
 674:../CX3RDKOV5640.c ****     static CyBool_t
 675:../CX3RDKOV5640.c **** esUVCUvcApplnUSBSetupCB (
 676:../CX3RDKOV5640.c ****         uint32_t setupdat0,     /* SETUP Data 0 */
 677:../CX3RDKOV5640.c ****         uint32_t setupdat1      /* SETUP Data 1 */
 678:../CX3RDKOV5640.c ****         )
 679:../CX3RDKOV5640.c **** {
 1484              		.loc 1 679 0
 1485              		.cfi_startproc
 1486              		@ args = 0, pretend = 0, frame = 32
 1487              		@ frame_needed = 1, uses_anonymous_args = 0
 1488 0000 F0492DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, fp, lr}
 1489              	.LCFI20:
 1490              		.cfi_def_cfa_offset 28
 1491              		.cfi_offset 4, -28
 1492              		.cfi_offset 5, -24
 1493              		.cfi_offset 6, -20
 1494              		.cfi_offset 7, -16
 1495              		.cfi_offset 8, -12
 1496              		.cfi_offset 11, -8
 1497              		.cfi_offset 14, -4
 1498 0004 18B08DE2 		add	fp, sp, #24
 1499              	.LCFI21:
 1500              		.cfi_def_cfa 11, 4
 1501 0008 4CD04DE2 		sub	sp, sp, #76
 1502 000c 38000BE5 		str	r0, [fp, #-56]
 1503 0010 3C100BE5 		str	r1, [fp, #-60]
 680:../CX3RDKOV5640.c ****     uint8_t  bRequest, bType,bRType, bTarget;
 681:../CX3RDKOV5640.c ****     uint16_t wValue, wIndex, wLength;
 682:../CX3RDKOV5640.c ****     uint16_t readCount = 0;
 1504              		.loc 1 682 0
 1505 0014 0030A0E3 		mov	r3, #0
 1506 0018 B2334BE1 		strh	r3, [fp, #-50]	@ movhi
 683:../CX3RDKOV5640.c ****     uint8_t  ep0Buf[2];
 684:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 1507              		.loc 1 684 0
 1508 001c 0030A0E3 		mov	r3, #0
 1509 0020 24300BE5 		str	r3, [fp, #-36]
 685:../CX3RDKOV5640.c ****     uint8_t temp = 0;
 1510              		.loc 1 685 0
 1511 0024 0030A0E3 		mov	r3, #0
 1512 0028 25304BE5 		strb	r3, [fp, #-37]
 686:../CX3RDKOV5640.c ****     CyBool_t isHandled = CyFalse;
 1513              		.loc 1 686 0
 1514 002c 0030A0E3 		mov	r3, #0
 1515 0030 20300BE5 		str	r3, [fp, #-32]
 687:../CX3RDKOV5640.c ****     uint8_t RequestOption = 0;
 1516              		.loc 1 687 0
 1517 0034 0030A0E3 		mov	r3, #0
 1518 0038 26304BE5 		strb	r3, [fp, #-38]
 688:../CX3RDKOV5640.c **** 
 689:../CX3RDKOV5640.c ****     /* Decode the fields from the setup request. */
 690:../CX3RDKOV5640.c ****     bRType = (setupdat0 & CY_U3P_USB_REQUEST_TYPE_MASK);
 1519              		.loc 1 690 0
 1520 003c 38301BE5 		ldr	r3, [fp, #-56]
 1521 0040 27304BE5 		strb	r3, [fp, #-39]
 691:../CX3RDKOV5640.c ****     bType    = (bRType & CY_U3P_USB_TYPE_MASK);
 1522              		.loc 1 691 0
 1523 0044 27305BE5 		ldrb	r3, [fp, #-39]
 1524 0048 603003E2 		and	r3, r3, #96
 1525 004c 28304BE5 		strb	r3, [fp, #-40]
 692:../CX3RDKOV5640.c ****     bTarget  = (bRType & CY_U3P_USB_TARGET_MASK);
 1526              		.loc 1 692 0
 1527 0050 27305BE5 		ldrb	r3, [fp, #-39]
 1528 0054 033003E2 		and	r3, r3, #3
 1529 0058 29304BE5 		strb	r3, [fp, #-41]
 693:../CX3RDKOV5640.c ****     bRequest = ((setupdat0 & CY_U3P_USB_REQUEST_MASK) >> CY_U3P_USB_REQUEST_POS);
 1530              		.loc 1 693 0
 1531 005c 38301BE5 		ldr	r3, [fp, #-56]
 1532 0060 FF3C03E2 		and	r3, r3, #65280
 1533 0064 2334A0E1 		mov	r3, r3, lsr #8
 1534 0068 2A304BE5 		strb	r3, [fp, #-42]
 694:../CX3RDKOV5640.c ****     wValue   = ((setupdat0 & CY_U3P_USB_VALUE_MASK)   >> CY_U3P_USB_VALUE_POS);
 1535              		.loc 1 694 0
 1536 006c 38301BE5 		ldr	r3, [fp, #-56]
 1537 0070 2338A0E1 		mov	r3, r3, lsr #16
 1538 0074 BC324BE1 		strh	r3, [fp, #-44]	@ movhi
 695:../CX3RDKOV5640.c ****     wIndex   = ((setupdat1 & CY_U3P_USB_INDEX_MASK)   >> CY_U3P_USB_INDEX_POS);
 1539              		.loc 1 695 0
 1540 0078 3C301BE5 		ldr	r3, [fp, #-60]
 1541 007c BE324BE1 		strh	r3, [fp, #-46]	@ movhi
 696:../CX3RDKOV5640.c ****     wLength  = ((setupdat1 & CY_U3P_USB_LENGTH_MASK)  >> CY_U3P_USB_LENGTH_POS);
 1542              		.loc 1 696 0
 1543 0080 3C301BE5 		ldr	r3, [fp, #-60]
 1544 0084 2338A0E1 		mov	r3, r3, lsr #16
 1545 0088 B0334BE1 		strh	r3, [fp, #-48]	@ movhi
 697:../CX3RDKOV5640.c **** 
 698:../CX3RDKOV5640.c **** #if 1
 699:../CX3RDKOV5640.c ****    	CyU3PDebugPrint(4, "\n\rbRType = 0x%x, bRequest = 0x%x, wValue = 0x%x, wIndex = 0x%x, wLength= 
 1546              		.loc 1 699 0
 1547 008c 27205BE5 		ldrb	r2, [fp, #-39]	@ zero_extendqisi2
 1548 0090 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1549 0094 BCC25BE1 		ldrh	ip, [fp, #-44]
 1550 0098 BE025BE1 		ldrh	r0, [fp, #-46]
 1551 009c B0135BE1 		ldrh	r1, [fp, #-48]
 1552 00a0 00C08DE5 		str	ip, [sp]
 1553 00a4 04008DE5 		str	r0, [sp, #4]
 1554 00a8 08108DE5 		str	r1, [sp, #8]
 1555 00ac 0400A0E3 		mov	r0, #4
 1556 00b0 70179FE5 		ldr	r1, .L132
 1557 00b4 FEFFFFEB 		bl	CyU3PDebugPrint
 700:../CX3RDKOV5640.c **** #endif
 701:../CX3RDKOV5640.c **** 
 702:../CX3RDKOV5640.c ****     /* ClearFeature(Endpoint_Halt) received on the Streaming Endpoint. Stop Streaming */
 703:../CX3RDKOV5640.c ****     if((bTarget == CY_U3P_USB_TARGET_ENDPT) && (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 1558              		.loc 1 703 0
 1559 00b8 29305BE5 		ldrb	r3, [fp, #-41]	@ zero_extendqisi2
 1560 00bc 020053E3 		cmp	r3, #2
 1561 00c0 1C00001A 		bne	.L77
 1562              		.loc 1 703 0 is_stmt 0 discriminator 1
 1563 00c4 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1564 00c8 010053E3 		cmp	r3, #1
 1565 00cc 1900001A 		bne	.L77
 704:../CX3RDKOV5640.c ****             && (wIndex == ES_UVC_EP_BULK_VIDEO) && (wValue == CY_U3P_USBX_FS_EP_HALT))
 1566              		.loc 1 704 0 is_stmt 1
 1567 00d0 BE325BE1 		ldrh	r3, [fp, #-46]
 1568 00d4 830053E3 		cmp	r3, #131
 1569 00d8 1600001A 		bne	.L77
 1570              		.loc 1 704 0 is_stmt 0 discriminator 1
 1571 00dc BC325BE1 		ldrh	r3, [fp, #-44]
 1572 00e0 000053E3 		cmp	r3, #0
 1573 00e4 1300001A 		bne	.L77
 705:../CX3RDKOV5640.c ****     {
 706:../CX3RDKOV5640.c ****         if ((glIsApplnActive) && (glIsStreamingStarted))
 1574              		.loc 1 706 0 is_stmt 1
 1575 00e8 3C379FE5 		ldr	r3, .L132+4
 1576 00ec 003093E5 		ldr	r3, [r3]
 1577 00f0 000053E3 		cmp	r3, #0
 1578 00f4 0D00000A 		beq	.L78
 1579              		.loc 1 706 0 is_stmt 0 discriminator 1
 1580 00f8 30379FE5 		ldr	r3, .L132+8
 1581 00fc 003093E5 		ldr	r3, [r3]
 1582 0100 000053E3 		cmp	r3, #0
 1583 0104 0900000A 		beq	.L78
 707:../CX3RDKOV5640.c ****         {
 708:../CX3RDKOV5640.c ****         	glPreviewStarted = CyFalse;
 1584              		.loc 1 708 0 is_stmt 1
 1585 0108 24379FE5 		ldr	r3, .L132+12
 1586 010c 0020A0E3 		mov	r2, #0
 1587 0110 002083E5 		str	r2, [r3]
 709:../CX3RDKOV5640.c ****             glIsClearFeature = CyTrue;
 1588              		.loc 1 709 0
 1589 0114 1C379FE5 		ldr	r3, .L132+16
 1590 0118 0120A0E3 		mov	r2, #1
 1591 011c 002083E5 		str	r2, [r3]
 710:../CX3RDKOV5640.c ****             esUVCUvcApplnStop();
 1592              		.loc 1 710 0
 1593 0120 FEFFFFEB 		bl	esUVCUvcApplnStop
 711:../CX3RDKOV5640.c ****             glcommitcount = 0;
 1594              		.loc 1 711 0
 1595 0124 10379FE5 		ldr	r3, .L132+20
 1596 0128 0020A0E3 		mov	r2, #0
 1597 012c 0020C3E5 		strb	r2, [r3]
 1598              	.L78:
 712:../CX3RDKOV5640.c **** #ifdef VISDebug
 713:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rApplnUSBSetupCB: esUVCUvcApplnStop");
 714:../CX3RDKOV5640.c **** #endif
 715:../CX3RDKOV5640.c ****         }
 716:../CX3RDKOV5640.c ****         return CyFalse;
 1599              		.loc 1 716 0
 1600 0130 0030A0E3 		mov	r3, #0
 1601 0134 B80100EA 		b	.L130
 1602              	.L77:
 717:../CX3RDKOV5640.c ****     }
 718:../CX3RDKOV5640.c **** 
 719:../CX3RDKOV5640.c ****     if( bRType == CY_U3P_USB_GS_DEVICE)
 1603              		.loc 1 719 0
 1604 0138 27305BE5 		ldrb	r3, [fp, #-39]	@ zero_extendqisi2
 1605 013c 800053E3 		cmp	r3, #128
 1606 0140 0500001A 		bne	.L80
 720:../CX3RDKOV5640.c ****     {
 721:../CX3RDKOV5640.c ****         /* Make sure that we bring the link back to U0, so that the ERDY can be sent. */
 722:../CX3RDKOV5640.c ****         if (CyU3PUsbGetSpeed () == CY_U3P_SUPER_SPEED)
 1607              		.loc 1 722 0
 1608 0144 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1609 0148 0030A0E1 		mov	r3, r0
 1610 014c 030053E3 		cmp	r3, #3
 1611 0150 0100001A 		bne	.L80
 723:../CX3RDKOV5640.c ****             CyU3PUsbSetLinkPowerState (CyU3PUsbLPM_U0);
 1612              		.loc 1 723 0
 1613 0154 0000A0E3 		mov	r0, #0
 1614 0158 FEFFFFEB 		bl	CyU3PUsbSetLinkPowerState
 1615              	.L80:
 724:../CX3RDKOV5640.c ****     }
 725:../CX3RDKOV5640.c **** 
 726:../CX3RDKOV5640.c ****     if ((bTarget == CY_U3P_USB_TARGET_INTF) && ((bRequest == CY_U3P_USB_SC_SET_FEATURE)
 1616              		.loc 1 726 0
 1617 015c 29305BE5 		ldrb	r3, [fp, #-41]	@ zero_extendqisi2
 1618 0160 010053E3 		cmp	r3, #1
 1619 0164 1400001A 		bne	.L81
 1620              		.loc 1 726 0 is_stmt 0 discriminator 1
 1621 0168 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1622 016c 030053E3 		cmp	r3, #3
 1623 0170 0200000A 		beq	.L82
 727:../CX3RDKOV5640.c ****                 || (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)) && (wValue == 0))
 1624              		.loc 1 727 0 is_stmt 1
 1625 0174 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1626 0178 010053E3 		cmp	r3, #1
 1627 017c 0E00001A 		bne	.L81
 1628              	.L82:
 1629              		.loc 1 727 0 is_stmt 0 discriminator 1
 1630 0180 BC325BE1 		ldrh	r3, [fp, #-44]
 1631 0184 000053E3 		cmp	r3, #0
 1632 0188 0B00001A 		bne	.L81
 728:../CX3RDKOV5640.c ****     {
 729:../CX3RDKOV5640.c ****         if (glIsConfigured)
 1633              		.loc 1 729 0 is_stmt 1
 1634 018c AC369FE5 		ldr	r3, .L132+24
 1635 0190 003093E5 		ldr	r3, [r3]
 1636 0194 000053E3 		cmp	r3, #0
 1637 0198 0100000A 		beq	.L83
 730:../CX3RDKOV5640.c ****         {
 731:../CX3RDKOV5640.c ****             CyU3PUsbAckSetup ();
 1638              		.loc 1 731 0
 1639 019c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1640 01a0 030000EA 		b	.L84
 1641              	.L83:
 732:../CX3RDKOV5640.c ****         }
 733:../CX3RDKOV5640.c ****         else
 734:../CX3RDKOV5640.c ****         {
 735:../CX3RDKOV5640.c ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 1642              		.loc 1 735 0
 1643 01a4 0000A0E3 		mov	r0, #0
 1644 01a8 0110A0E3 		mov	r1, #1
 1645 01ac 0020A0E3 		mov	r2, #0
 1646 01b0 FEFFFFEB 		bl	CyU3PUsbStall
 1647              	.L84:
 736:../CX3RDKOV5640.c ****         }
 737:../CX3RDKOV5640.c ****         return CyTrue;
 1648              		.loc 1 737 0
 1649 01b4 0130A0E3 		mov	r3, #1
 1650 01b8 970100EA 		b	.L130
 1651              	.L81:
 738:../CX3RDKOV5640.c ****     }
 739:../CX3RDKOV5640.c **** 
 740:../CX3RDKOV5640.c ****     if ((bRequest == CY_U3P_USB_SC_GET_STATUS) &&
 1652              		.loc 1 740 0
 1653 01bc 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1654 01c0 000053E3 		cmp	r3, #0
 1655 01c4 1400001A 		bne	.L85
 1656              		.loc 1 740 0 is_stmt 0 discriminator 1
 1657 01c8 29305BE5 		ldrb	r3, [fp, #-41]	@ zero_extendqisi2
 1658 01cc 010053E3 		cmp	r3, #1
 1659 01d0 1100001A 		bne	.L85
 741:../CX3RDKOV5640.c ****             (bTarget == CY_U3P_USB_TARGET_INTF))
 742:../CX3RDKOV5640.c ****     {
 743:../CX3RDKOV5640.c ****         /* We support only interface 0. */
 744:../CX3RDKOV5640.c ****         if (wIndex == 0)
 1660              		.loc 1 744 0 is_stmt 1
 1661 01d4 BE325BE1 		ldrh	r3, [fp, #-46]
 1662 01d8 000053E3 		cmp	r3, #0
 1663 01dc 0800001A 		bne	.L86
 745:../CX3RDKOV5640.c ****         {
 746:../CX3RDKOV5640.c ****             ep0Buf[0] = 0;
 1664              		.loc 1 746 0
 1665 01e0 0030A0E3 		mov	r3, #0
 1666 01e4 34304BE5 		strb	r3, [fp, #-52]
 747:../CX3RDKOV5640.c ****             ep0Buf[1] = 0;
 1667              		.loc 1 747 0
 1668 01e8 0030A0E3 		mov	r3, #0
 1669 01ec 33304BE5 		strb	r3, [fp, #-51]
 748:../CX3RDKOV5640.c ****             CyU3PUsbSendEP0Data (0x02, ep0Buf);
 1670              		.loc 1 748 0
 1671 01f0 34304BE2 		sub	r3, fp, #52
 1672 01f4 0200A0E3 		mov	r0, #2
 1673 01f8 0310A0E1 		mov	r1, r3
 1674 01fc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1675 0200 030000EA 		b	.L87
 1676              	.L86:
 749:../CX3RDKOV5640.c ****         }
 750:../CX3RDKOV5640.c ****         else
 751:../CX3RDKOV5640.c ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 1677              		.loc 1 751 0
 1678 0204 0000A0E3 		mov	r0, #0
 1679 0208 0110A0E3 		mov	r1, #1
 1680 020c 0020A0E3 		mov	r2, #0
 1681 0210 FEFFFFEB 		bl	CyU3PUsbStall
 1682              	.L87:
 752:../CX3RDKOV5640.c ****         return CyTrue;
 1683              		.loc 1 752 0
 1684 0214 0130A0E3 		mov	r3, #1
 1685 0218 7F0100EA 		b	.L130
 1686              	.L85:
 753:../CX3RDKOV5640.c ****     }
 754:../CX3RDKOV5640.c **** 
 755:../CX3RDKOV5640.c ****     /* Check for UVC Class Requests */
 756:../CX3RDKOV5640.c ****     if (bType == CY_U3P_USB_CLASS_RQT)
 1687              		.loc 1 756 0
 1688 021c 28305BE5 		ldrb	r3, [fp, #-40]	@ zero_extendqisi2
 1689 0220 200053E3 		cmp	r3, #32
 1690 0224 7B01001A 		bne	.L88
 757:../CX3RDKOV5640.c ****     {
 758:../CX3RDKOV5640.c **** 
 759:../CX3RDKOV5640.c ****         /* UVC Class Requests */
 760:../CX3RDKOV5640.c ****         /* Requests to the Video Streaming Interface (IF 1) */
 761:../CX3RDKOV5640.c ****         if((wIndex & 0x00FF) == ES_UVC_STREAM_INTERFACE)
 1691              		.loc 1 761 0
 1692 0228 BE325BE1 		ldrh	r3, [fp, #-46]
 1693 022c FF3003E2 		and	r3, r3, #255
 1694 0230 010053E3 		cmp	r3, #1
 1695 0234 5001001A 		bne	.L89
 762:../CX3RDKOV5640.c ****         {
 763:../CX3RDKOV5640.c ****             /* GET_CUR Request Handling Probe/Commit Controls*/
 764:../CX3RDKOV5640.c ****             if ((bRequest == ES_UVC_USB_GET_CUR_REQ)||(bRequest == ES_UVC_USB_GET_MIN_REQ) || (bReq
 1696              		.loc 1 764 0
 1697 0238 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1698 023c 810053E3 		cmp	r3, #129
 1699 0240 0800000A 		beq	.L90
 1700              		.loc 1 764 0 is_stmt 0 discriminator 1
 1701 0244 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1702 0248 820053E3 		cmp	r3, #130
 1703 024c 0500000A 		beq	.L90
 1704 0250 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1705 0254 830053E3 		cmp	r3, #131
 1706 0258 0200000A 		beq	.L90
 1707 025c 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1708 0260 870053E3 		cmp	r3, #135
 1709 0264 5F00001A 		bne	.L91
 1710              	.L90:
 765:../CX3RDKOV5640.c ****             {
 766:../CX3RDKOV5640.c ****                 isHandled = CyTrue;
 1711              		.loc 1 766 0 is_stmt 1
 1712 0268 0130A0E3 		mov	r3, #1
 1713 026c 20300BE5 		str	r3, [fp, #-32]
 767:../CX3RDKOV5640.c ****                 if((wValue == ES_UVC_VS_PROBE_CONTROL) || (wValue == ES_UVC_VS_COMMIT_CONTROL))
 1714              		.loc 1 767 0
 1715 0270 BC325BE1 		ldrh	r3, [fp, #-44]
 1716 0274 010C53E3 		cmp	r3, #256
 1717 0278 0200000A 		beq	.L92
 1718              		.loc 1 767 0 is_stmt 0 discriminator 1
 1719 027c BC325BE1 		ldrh	r3, [fp, #-44]
 1720 0280 020C53E3 		cmp	r3, #512
 1721 0284 4000001A 		bne	.L93
 1722              	.L92:
 768:../CX3RDKOV5640.c ****                 {
 769:../CX3RDKOV5640.c ****                 	//TODO Modify this "glProbeCtrl" according to the Supported Preview Resolutions th
 770:../CX3RDKOV5640.c **** 
 771:../CX3RDKOV5640.c **** 					/* Host requests for probe data of 34 bytes (UVC 1.1) or 26 Bytes (UVC1.0). Send it over EP0. 
 772:../CX3RDKOV5640.c **** 					if (CyU3PUsbGetSpeed () == CY_U3P_SUPER_SPEED)
 1723              		.loc 1 772 0 is_stmt 1
 1724 0288 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1725 028c 0030A0E1 		mov	r3, r0
 1726 0290 030053E3 		cmp	r3, #3
 1727 0294 2300001A 		bne	.L94
 773:../CX3RDKOV5640.c **** 					{
 774:../CX3RDKOV5640.c **** 						if(glCurrentFrameIndex == 4)
 1728              		.loc 1 774 0
 1729 0298 A4359FE5 		ldr	r3, .L132+28
 1730 029c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1731 02a0 040053E3 		cmp	r3, #4
 1732 02a4 0400001A 		bne	.L95
 775:../CX3RDKOV5640.c **** 						{
 776:../CX3RDKOV5640.c **** 							CyU3PMemCopy(glProbeCtrl, (uint8_t *)gl5MpProbeCtrl, ES_UVC_MAX_PROBE_SETTING);
 1733              		.loc 1 776 0
 1734 02a8 98059FE5 		ldr	r0, .L132+32
 1735 02ac 98159FE5 		ldr	r1, .L132+36
 1736 02b0 1A20A0E3 		mov	r2, #26
 1737 02b4 FEFFFFEB 		bl	CyU3PMemCopy
 1738 02b8 260000EA 		b	.L99
 1739              	.L95:
 777:../CX3RDKOV5640.c **** 						}
 778:../CX3RDKOV5640.c **** 						/* Probe Control for 1280x720 stream*/
 779:../CX3RDKOV5640.c **** 						else if(glCurrentFrameIndex == 3)
 1740              		.loc 1 779 0
 1741 02bc 80359FE5 		ldr	r3, .L132+28
 1742 02c0 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1743 02c4 030053E3 		cmp	r3, #3
 1744 02c8 0400001A 		bne	.L97
 780:../CX3RDKOV5640.c **** 						{
 781:../CX3RDKOV5640.c **** 							CyU3PMemCopy(glProbeCtrl, (uint8_t *)gl720pProbeCtrl, ES_UVC_MAX_PROBE_SETTING);
 1745              		.loc 1 781 0
 1746 02cc 74059FE5 		ldr	r0, .L132+32
 1747 02d0 78159FE5 		ldr	r1, .L132+40
 1748 02d4 1A20A0E3 		mov	r2, #26
 1749 02d8 FEFFFFEB 		bl	CyU3PMemCopy
 1750 02dc 1D0000EA 		b	.L99
 1751              	.L97:
 782:../CX3RDKOV5640.c **** 						}
 783:../CX3RDKOV5640.c **** 						/* Probe Control for 640x480 stream*/
 784:../CX3RDKOV5640.c **** 						else  if(glCurrentFrameIndex == 2)
 1752              		.loc 1 784 0
 1753 02e0 5C359FE5 		ldr	r3, .L132+28
 1754 02e4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1755 02e8 020053E3 		cmp	r3, #2
 1756 02ec 0400001A 		bne	.L98
 785:../CX3RDKOV5640.c **** 						{
 786:../CX3RDKOV5640.c **** 							CyU3PMemCopy(glProbeCtrl, (uint8_t *)glVga60ProbeCtrl, ES_UVC_MAX_PROBE_SETTING);
 1757              		.loc 1 786 0
 1758 02f0 50059FE5 		ldr	r0, .L132+32
 1759 02f4 58159FE5 		ldr	r1, .L132+44
 1760 02f8 1A20A0E3 		mov	r2, #26
 1761 02fc FEFFFFEB 		bl	CyU3PMemCopy
 1762 0300 140000EA 		b	.L99
 1763              	.L98:
 787:../CX3RDKOV5640.c **** 						}
 788:../CX3RDKOV5640.c **** 						/* Probe Control for 1920x1080 stream*/
 789:../CX3RDKOV5640.c **** 						else  if(glCurrentFrameIndex == 1)
 1764              		.loc 1 789 0
 1765 0304 38359FE5 		ldr	r3, .L132+28
 1766 0308 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1767 030c 010053E3 		cmp	r3, #1
 1768 0310 1000001A 		bne	.L99
 790:../CX3RDKOV5640.c **** 						{
 791:../CX3RDKOV5640.c **** 							CyU3PMemCopy(glProbeCtrl, (uint8_t *)gl1080pProbeCtrl, ES_UVC_MAX_PROBE_SETTING);
 1769              		.loc 1 791 0
 1770 0314 2C059FE5 		ldr	r0, .L132+32
 1771 0318 38159FE5 		ldr	r1, .L132+48
 1772 031c 1A20A0E3 		mov	r2, #26
 1773 0320 FEFFFFEB 		bl	CyU3PMemCopy
 1774 0324 0B0000EA 		b	.L99
 1775              	.L94:
 792:../CX3RDKOV5640.c **** 						}
 793:../CX3RDKOV5640.c **** 
 794:../CX3RDKOV5640.c **** 					}
 795:../CX3RDKOV5640.c **** 					else if (CyU3PUsbGetSpeed () == CY_U3P_HIGH_SPEED)
 1776              		.loc 1 795 0
 1777 0328 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1778 032c 0030A0E1 		mov	r3, r0
 1779 0330 020053E3 		cmp	r3, #2
 1780 0334 0400001A 		bne	.L100
 796:../CX3RDKOV5640.c **** 					{
 797:../CX3RDKOV5640.c **** 						/* Probe Control for 640x480 stream*/
 798:../CX3RDKOV5640.c **** 						CyU3PMemCopy(glProbeCtrl, (uint8_t *)glVga30ProbeCtrl, ES_UVC_MAX_PROBE_SETTING);
 1781              		.loc 1 798 0
 1782 0338 08059FE5 		ldr	r0, .L132+32
 1783 033c 18159FE5 		ldr	r1, .L132+52
 1784 0340 1A20A0E3 		mov	r2, #26
 1785 0344 FEFFFFEB 		bl	CyU3PMemCopy
 1786 0348 020000EA 		b	.L99
 1787              	.L100:
 799:../CX3RDKOV5640.c **** 					}
 800:../CX3RDKOV5640.c **** 					else /* FULL-Speed*/
 801:../CX3RDKOV5640.c **** 					{
 802:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rFull Speed Not Supported!");
 1788              		.loc 1 802 0
 1789 034c 0400A0E3 		mov	r0, #4
 1790 0350 08159FE5 		ldr	r1, .L132+56
 1791 0354 FEFFFFEB 		bl	CyU3PDebugPrint
 1792              	.L99:
 803:../CX3RDKOV5640.c **** 					}
 804:../CX3RDKOV5640.c **** 
 805:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(ES_UVC_MAX_PROBE_SETTING, glProbeCtrl);
 1793              		.loc 1 805 0
 1794 0358 1A00A0E3 		mov	r0, #26
 1795 035c E4149FE5 		ldr	r1, .L132+32
 1796 0360 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1797 0364 24000BE5 		str	r0, [fp, #-36]
 806:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 1798              		.loc 1 806 0
 1799 0368 24301BE5 		ldr	r3, [fp, #-36]
 1800 036c 000053E3 		cmp	r3, #0
 1801 0370 0400000A 		beq	.L101
 807:../CX3RDKOV5640.c **** 					{
 808:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:GET_CUR:SendEP0Data Err = 0x%x", status);
 1802              		.loc 1 808 0
 1803 0374 0400A0E3 		mov	r0, #4
 1804 0378 E4149FE5 		ldr	r1, .L132+60
 1805 037c 24201BE5 		ldr	r2, [fp, #-36]
 1806 0380 FEFFFFEB 		bl	CyU3PDebugPrint
 806:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 1807              		.loc 1 806 0
 1808 0384 160000EA 		b	.L102
 1809              	.L101:
 806:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 1810              		.loc 1 806 0 is_stmt 0 discriminator 1
 1811 0388 150000EA 		b	.L102
 1812              	.L93:
 809:../CX3RDKOV5640.c **** 					}
 810:../CX3RDKOV5640.c ****                 }
 811:../CX3RDKOV5640.c ****                 else if((wValue == ES_UVC_STILL_PROBE_CONTROL) || (wValue == ES_UVC_STILL_COMMIT_CO
 1813              		.loc 1 811 0 is_stmt 1
 1814 038c BC325BE1 		ldrh	r3, [fp, #-44]
 1815 0390 030C53E3 		cmp	r3, #768
 1816 0394 0200000A 		beq	.L103
 1817              		.loc 1 811 0 is_stmt 0 discriminator 1
 1818 0398 BC325BE1 		ldrh	r3, [fp, #-44]
 1819 039c 010B53E3 		cmp	r3, #1024
 1820 03a0 0F00001A 		bne	.L102
 1821              	.L103:
 812:../CX3RDKOV5640.c ****                 {
 813:../CX3RDKOV5640.c ****                 	if (CyU3PUsbGetSpeed () == CY_U3P_SUPER_SPEED)
 1822              		.loc 1 813 0 is_stmt 1
 1823 03a4 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1824 03a8 0030A0E1 		mov	r3, r0
 1825 03ac 030053E3 		cmp	r3, #3
 1826 03b0 0B00001A 		bne	.L102
 814:../CX3RDKOV5640.c ****                 	{
 815:../CX3RDKOV5640.c **** 						status = CyU3PUsbSendEP0Data(ES_UVC_MAX_STILL_PROBE_SETTING, glStillProbeCtrl);
 1827              		.loc 1 815 0
 1828 03b4 0B00A0E3 		mov	r0, #11
 1829 03b8 A8149FE5 		ldr	r1, .L132+64
 1830 03bc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1831 03c0 24000BE5 		str	r0, [fp, #-36]
 816:../CX3RDKOV5640.c **** 						if (status != CY_U3P_SUCCESS)
 1832              		.loc 1 816 0
 1833 03c4 24301BE5 		ldr	r3, [fp, #-36]
 1834 03c8 000053E3 		cmp	r3, #0
 1835 03cc 0400000A 		beq	.L102
 817:../CX3RDKOV5640.c **** 						{
 818:../CX3RDKOV5640.c **** 							CyU3PDebugPrint (4, "\n\rUSBStpCB:GET_CUR:SendEP0Data Err = 0x%x", status);
 1836              		.loc 1 818 0
 1837 03d0 0400A0E3 		mov	r0, #4
 1838 03d4 88149FE5 		ldr	r1, .L132+60
 1839 03d8 24201BE5 		ldr	r2, [fp, #-36]
 1840 03dc FEFFFFEB 		bl	CyU3PDebugPrint
 767:../CX3RDKOV5640.c ****                 {
 1841              		.loc 1 767 0
 1842 03e0 E40000EA 		b	.L104
 1843              	.L102:
 1844 03e4 E30000EA 		b	.L104
 1845              	.L91:
 819:../CX3RDKOV5640.c **** 						}
 820:../CX3RDKOV5640.c ****                 	}
 821:../CX3RDKOV5640.c ****                 }
 822:../CX3RDKOV5640.c ****             }
 823:../CX3RDKOV5640.c ****             /* SET_CUR request handling Probe/Commit controls */
 824:../CX3RDKOV5640.c ****             else if (bRequest == ES_UVC_USB_SET_CUR_REQ)
 1846              		.loc 1 824 0
 1847 03e8 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 1848 03ec 010053E3 		cmp	r3, #1
 1849 03f0 DD00001A 		bne	.L105
 825:../CX3RDKOV5640.c ****             {
 826:../CX3RDKOV5640.c ****                 isHandled = CyTrue;
 1850              		.loc 1 826 0
 1851 03f4 0130A0E3 		mov	r3, #1
 1852 03f8 20300BE5 		str	r3, [fp, #-32]
 827:../CX3RDKOV5640.c ****                 if((wValue == ES_UVC_VS_PROBE_CONTROL) || (wValue == ES_UVC_VS_COMMIT_CONTROL))
 1853              		.loc 1 827 0
 1854 03fc BC325BE1 		ldrh	r3, [fp, #-44]
 1855 0400 010C53E3 		cmp	r3, #256
 1856 0404 0200000A 		beq	.L106
 1857              		.loc 1 827 0 is_stmt 0 discriminator 1
 1858 0408 BC325BE1 		ldrh	r3, [fp, #-44]
 1859 040c 020C53E3 		cmp	r3, #512
 1860 0410 5700001A 		bne	.L107
 1861              	.L106:
 828:../CX3RDKOV5640.c ****                 {
 829:../CX3RDKOV5640.c **** 					/* Get the UVC probe/commit control data from EP0 */
 830:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(ES_UVC_MAX_PROBE_SETTING_ALIGNED,
 1862              		.loc 1 830 0 is_stmt 1
 1863 0414 32304BE2 		sub	r3, fp, #50
 1864 0418 2000A0E3 		mov	r0, #32
 1865 041c 48149FE5 		ldr	r1, .L132+68
 1866 0420 0320A0E1 		mov	r2, r3
 1867 0424 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1868 0428 24000BE5 		str	r0, [fp, #-36]
 831:../CX3RDKOV5640.c **** 							glCommitCtrl, &readCount);
 832:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 1869              		.loc 1 832 0
 1870 042c 24301BE5 		ldr	r3, [fp, #-36]
 1871 0430 000053E3 		cmp	r3, #0
 1872 0434 0300000A 		beq	.L108
 833:../CX3RDKOV5640.c **** 					{
 834:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:SET_CUR:GetEP0Data Err = 0x%x.", status);
 1873              		.loc 1 834 0
 1874 0438 0400A0E3 		mov	r0, #4
 1875 043c 2C149FE5 		ldr	r1, .L132+72
 1876 0440 24201BE5 		ldr	r2, [fp, #-36]
 1877 0444 FEFFFFEB 		bl	CyU3PDebugPrint
 1878              	.L108:
 835:../CX3RDKOV5640.c **** 					}
 836:../CX3RDKOV5640.c **** 					/* Check the read count. Expecting a count of CX3_UVC_MAX_PROBE_SETTING bytes. */
 837:../CX3RDKOV5640.c **** 					if (readCount > (uint16_t)ES_UVC_MAX_PROBE_SETTING)
 1879              		.loc 1 837 0
 1880 0448 B2335BE1 		ldrh	r3, [fp, #-50]
 1881 044c 1A0053E3 		cmp	r3, #26
 1882 0450 0300009A 		bls	.L109
 838:../CX3RDKOV5640.c **** 					{
 839:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:Invalid SET_CUR Rqt Len.");
 1883              		.loc 1 839 0
 1884 0454 0400A0E3 		mov	r0, #4
 1885 0458 14149FE5 		ldr	r1, .L132+76
 1886 045c FEFFFFEB 		bl	CyU3PDebugPrint
 1887 0460 420000EA 		b	.L110
 1888              	.L109:
 840:../CX3RDKOV5640.c **** 					}
 841:../CX3RDKOV5640.c **** 					else
 842:../CX3RDKOV5640.c **** 					{
 843:../CX3RDKOV5640.c **** 						/* Set Probe Control */
 844:../CX3RDKOV5640.c **** 						if(wValue == ES_UVC_VS_PROBE_CONTROL)
 1889              		.loc 1 844 0
 1890 0464 BC325BE1 		ldrh	r3, [fp, #-44]
 1891 0468 010C53E3 		cmp	r3, #256
 1892 046c 0400001A 		bne	.L111
 845:../CX3RDKOV5640.c **** 						{
 846:../CX3RDKOV5640.c **** 							glCurrentFrameIndex = glCommitCtrl[3];
 1893              		.loc 1 846 0
 1894 0470 F4339FE5 		ldr	r3, .L132+68
 1895 0474 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 1896 0478 C4339FE5 		ldr	r3, .L132+28
 1897 047c 0020C3E5 		strb	r2, [r3]
 1898 0480 3A0000EA 		b	.L110
 1899              	.L111:
 847:../CX3RDKOV5640.c **** 						}
 848:../CX3RDKOV5640.c **** 						/* Set Commit Control and Start Streaming*/
 849:../CX3RDKOV5640.c **** 						else if(wValue == ES_UVC_VS_COMMIT_CONTROL)
 1900              		.loc 1 849 0
 1901 0484 BC325BE1 		ldrh	r3, [fp, #-44]
 1902 0488 020C53E3 		cmp	r3, #512
 1903 048c 3700001A 		bne	.L110
 850:../CX3RDKOV5640.c **** 						{
 851:../CX3RDKOV5640.c **** 
 852:../CX3RDKOV5640.c **** 							if((glcommitcount==0)||(glcheckframe!=glCommitCtrl[3]))
 1904              		.loc 1 852 0
 1905 0490 A4339FE5 		ldr	r3, .L132+20
 1906 0494 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1907 0498 000053E3 		cmp	r3, #0
 1908 049c 0500000A 		beq	.L112
 1909              		.loc 1 852 0 is_stmt 0 discriminator 1
 1910 04a0 C4339FE5 		ldr	r3, .L132+68
 1911 04a4 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 1912 04a8 C8339FE5 		ldr	r3, .L132+80
 1913 04ac 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1914 04b0 030052E1 		cmp	r2, r3
 1915 04b4 2900000A 		beq	.L113
 1916              	.L112:
 853:../CX3RDKOV5640.c **** 							{
 854:../CX3RDKOV5640.c **** 								glcommitcount++;
 1917              		.loc 1 854 0 is_stmt 1
 1918 04b8 7C339FE5 		ldr	r3, .L132+20
 1919 04bc 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1920 04c0 013083E2 		add	r3, r3, #1
 1921 04c4 FF2003E2 		and	r2, r3, #255
 1922 04c8 6C339FE5 		ldr	r3, .L132+20
 1923 04cc 0020C3E5 		strb	r2, [r3]
 855:../CX3RDKOV5640.c **** 								glcheckframe=glCommitCtrl[3];
 1924              		.loc 1 855 0
 1925 04d0 94339FE5 		ldr	r3, .L132+68
 1926 04d4 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 1927 04d8 98339FE5 		ldr	r3, .L132+80
 1928 04dc 0020C3E5 		strb	r2, [r3]
 856:../CX3RDKOV5640.c **** 							glCurrentFrameIndex = glCommitCtrl[3];
 1929              		.loc 1 856 0
 1930 04e0 84339FE5 		ldr	r3, .L132+68
 1931 04e4 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 1932 04e8 54339FE5 		ldr	r3, .L132+28
 1933 04ec 0020C3E5 		strb	r2, [r3]
 857:../CX3RDKOV5640.c **** 							glFrameIndexToSet = glCurrentFrameIndex;
 1934              		.loc 1 857 0
 1935 04f0 4C339FE5 		ldr	r3, .L132+28
 1936 04f4 0020D3E5 		ldrb	r2, [r3]	@ zero_extendqisi2
 1937 04f8 7C339FE5 		ldr	r3, .L132+84
 1938 04fc 0020C3E5 		strb	r2, [r3]
 858:../CX3RDKOV5640.c **** 							glPreviewStarted = CyTrue;
 1939              		.loc 1 858 0
 1940 0500 2C339FE5 		ldr	r3, .L132+12
 1941 0504 0120A0E3 		mov	r2, #1
 1942 0508 002083E5 		str	r2, [r3]
 859:../CX3RDKOV5640.c **** 
 860:../CX3RDKOV5640.c **** 							//TODO Change this function with "Sensor Specific" function to write the sensor settings & c
 861:../CX3RDKOV5640.c **** 						//	esSetCameraResolution(glCurrentFrameIndex);
 862:../CX3RDKOV5640.c **** 							esSetCameraResolution(glCommitCtrl[3]);
 1943              		.loc 1 862 0
 1944 050c 58339FE5 		ldr	r3, .L132+68
 1945 0510 0330D3E5 		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 1946 0514 0300A0E1 		mov	r0, r3
 1947 0518 FEFFFFEB 		bl	esSetCameraResolution
 863:../CX3RDKOV5640.c **** 
 864:../CX3RDKOV5640.c **** 							if (glIsApplnActive)
 1948              		.loc 1 864 0
 1949 051c 08339FE5 		ldr	r3, .L132+4
 1950 0520 003093E5 		ldr	r3, [r3]
 1951 0524 000053E3 		cmp	r3, #0
 1952 0528 0B00000A 		beq	.L114
 865:../CX3RDKOV5640.c **** 							{
 866:../CX3RDKOV5640.c **** 								if(glcommitcount)
 1953              		.loc 1 866 0
 1954 052c 08339FE5 		ldr	r3, .L132+20
 1955 0530 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1956 0534 000053E3 		cmp	r3, #0
 1957 0538 0300000A 		beq	.L115
 867:../CX3RDKOV5640.c **** 									glIsClearFeature = CyFalse;
 1958              		.loc 1 867 0
 1959 053c F4329FE5 		ldr	r3, .L132+16
 1960 0540 0020A0E3 		mov	r2, #0
 1961 0544 002083E5 		str	r2, [r3]
 1962 0548 020000EA 		b	.L116
 1963              	.L115:
 868:../CX3RDKOV5640.c **** 								else
 869:../CX3RDKOV5640.c **** 									glIsClearFeature = CyTrue;
 1964              		.loc 1 869 0
 1965 054c E4329FE5 		ldr	r3, .L132+16
 1966 0550 0120A0E3 		mov	r2, #1
 1967 0554 002083E5 		str	r2, [r3]
 1968              	.L116:
 870:../CX3RDKOV5640.c **** 
 871:../CX3RDKOV5640.c **** 								esUVCUvcApplnStop();
 1969              		.loc 1 871 0
 1970 0558 FEFFFFEB 		bl	esUVCUvcApplnStop
 1971              	.L114:
 872:../CX3RDKOV5640.c **** #ifdef VISDebug
 873:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rApplnUSBSetupCB:ES_UVC_VS_COMMIT_CONTROL esUVCUvcApplnStop");
 874:../CX3RDKOV5640.c **** #endif
 875:../CX3RDKOV5640.c **** 							}
 876:../CX3RDKOV5640.c **** 							esUVCUvcApplnStart();
 1972              		.loc 1 876 0
 1973 055c FEFFFFEB 		bl	esUVCUvcApplnStart
 1974              	.L113:
 877:../CX3RDKOV5640.c **** #ifdef VISDebug
 878:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rApplnUSBSetupCB:ES_UVC_VS_COMMIT_CONTROL esUVCUvcApplnStart");
 879:../CX3RDKOV5640.c **** #endif
 880:../CX3RDKOV5640.c **** 							}
 881:../CX3RDKOV5640.c **** 							//CyU3PThreadSleep(1000);
 882:../CX3RDKOV5640.c **** 							SensorGetControl(0x02, 0x30); //the start up mechanism is in the microcode.
 1975              		.loc 1 882 0
 1976 0560 0200A0E3 		mov	r0, #2
 1977 0564 3010A0E3 		mov	r1, #48
 1978 0568 FEFFFFEB 		bl	SensorGetControl
 837:../CX3RDKOV5640.c **** 					{
 1979              		.loc 1 837 0
 1980 056c 7D0000EA 		b	.L117
 1981              	.L110:
 1982 0570 7C0000EA 		b	.L117
 1983              	.L107:
 883:../CX3RDKOV5640.c **** 						}
 884:../CX3RDKOV5640.c **** 					}
 885:../CX3RDKOV5640.c ****                 }
 886:../CX3RDKOV5640.c ****                 else if((wValue == ES_UVC_STILL_PROBE_CONTROL) || (wValue == ES_UVC_STILL_COMMIT_CO
 1984              		.loc 1 886 0
 1985 0574 BC325BE1 		ldrh	r3, [fp, #-44]
 1986 0578 030C53E3 		cmp	r3, #768
 1987 057c 0200000A 		beq	.L118
 1988              		.loc 1 886 0 is_stmt 0 discriminator 1
 1989 0580 BC325BE1 		ldrh	r3, [fp, #-44]
 1990 0584 010B53E3 		cmp	r3, #1024
 1991 0588 5400001A 		bne	.L119
 1992              	.L118:
 887:../CX3RDKOV5640.c ****                 {
 888:../CX3RDKOV5640.c ****                 	/* Get the UVC STILL probe/commit control data from EP0 */
 889:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(ES_UVC_MAX_STILL_PROBE_SETTING_ALIGNED,glStillCommitCtrl, &readCou
 1993              		.loc 1 889 0 is_stmt 1
 1994 058c 32304BE2 		sub	r3, fp, #50
 1995 0590 2000A0E3 		mov	r0, #32
 1996 0594 E4129FE5 		ldr	r1, .L132+88
 1997 0598 0320A0E1 		mov	r2, r3
 1998 059c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1999 05a0 24000BE5 		str	r0, [fp, #-36]
 890:../CX3RDKOV5640.c **** 					CyU3PDebugPrint (4, "\n\rUSBStpCB:SET_CUR:still = 0x%x.", wValue);
 2000              		.loc 1 890 0
 2001 05a4 BC325BE1 		ldrh	r3, [fp, #-44]
 2002 05a8 0400A0E3 		mov	r0, #4
 2003 05ac D0129FE5 		ldr	r1, .L132+92
 2004 05b0 0320A0E1 		mov	r2, r3
 2005 05b4 FEFFFFEB 		bl	CyU3PDebugPrint
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 892:../CX3RDKOV5640.c ****                     		glStillCommitCtrl[0], glStillCommitCtrl[1],  glStillCommitCtrl[2], glStillCom
 2006              		.loc 1 892 0
 2007 05b8 C0329FE5 		ldr	r3, .L132+88
 2008 05bc 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2009              		.loc 1 891 0
 2010 05c0 0320A0E1 		mov	r2, r3
 2011              		.loc 1 892 0
 2012 05c4 B4329FE5 		ldr	r3, .L132+88
 2013 05c8 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2014 05cc AC129FE5 		ldr	r1, .L132+88
 2015 05d0 0210D1E5 		ldrb	r1, [r1, #2]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2016              		.loc 1 891 0
 2017 05d4 0180A0E1 		mov	r8, r1
 2018              		.loc 1 892 0
 2019 05d8 A0129FE5 		ldr	r1, .L132+88
 2020 05dc 0310D1E5 		ldrb	r1, [r1, #3]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2021              		.loc 1 891 0
 2022 05e0 0170A0E1 		mov	r7, r1
 893:../CX3RDKOV5640.c ****                     		glStillCommitCtrl[4], glStillCommitCtrl[5],  glStillCommitCtrl[6], glStillCom
 2023              		.loc 1 893 0
 2024 05e4 94129FE5 		ldr	r1, .L132+88
 2025 05e8 0410D1E5 		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2026              		.loc 1 891 0
 2027 05ec 0160A0E1 		mov	r6, r1
 2028              		.loc 1 893 0
 2029 05f0 88129FE5 		ldr	r1, .L132+88
 2030 05f4 0510D1E5 		ldrb	r1, [r1, #5]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2031              		.loc 1 891 0
 2032 05f8 0150A0E1 		mov	r5, r1
 2033              		.loc 1 893 0
 2034 05fc 7C129FE5 		ldr	r1, .L132+88
 2035 0600 0610D1E5 		ldrb	r1, [r1, #6]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2036              		.loc 1 891 0
 2037 0604 0140A0E1 		mov	r4, r1
 2038              		.loc 1 893 0
 2039 0608 70129FE5 		ldr	r1, .L132+88
 2040 060c 0710D1E5 		ldrb	r1, [r1, #7]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2041              		.loc 1 891 0
 2042 0610 01E0A0E1 		mov	lr, r1
 894:../CX3RDKOV5640.c ****                     		glStillCommitCtrl[8], glStillCommitCtrl[9], glStillCommitCtrl[10]);
 2043              		.loc 1 894 0
 2044 0614 64129FE5 		ldr	r1, .L132+88
 2045 0618 0810D1E5 		ldrb	r1, [r1, #8]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2046              		.loc 1 891 0
 2047 061c 01C0A0E1 		mov	ip, r1
 2048              		.loc 1 894 0
 2049 0620 58129FE5 		ldr	r1, .L132+88
 2050 0624 0910D1E5 		ldrb	r1, [r1, #9]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2051              		.loc 1 891 0
 2052 0628 0100A0E1 		mov	r0, r1
 2053              		.loc 1 894 0
 2054 062c 4C129FE5 		ldr	r1, .L132+88
 2055 0630 0A10D1E5 		ldrb	r1, [r1, #10]	@ zero_extendqisi2
 891:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\r %d %d %d %d %d %d %d %d %d %d %d\r\n",
 2056              		.loc 1 891 0
 2057 0634 00808DE5 		str	r8, [sp]
 2058 0638 04708DE5 		str	r7, [sp, #4]
 2059 063c 08608DE5 		str	r6, [sp, #8]
 2060 0640 0C508DE5 		str	r5, [sp, #12]
 2061 0644 10408DE5 		str	r4, [sp, #16]
 2062 0648 14E08DE5 		str	lr, [sp, #20]
 2063 064c 18C08DE5 		str	ip, [sp, #24]
 2064 0650 1C008DE5 		str	r0, [sp, #28]
 2065 0654 20108DE5 		str	r1, [sp, #32]
 2066 0658 0400A0E3 		mov	r0, #4
 2067 065c 24129FE5 		ldr	r1, .L132+96
 2068 0660 FEFFFFEB 		bl	CyU3PDebugPrint
 895:../CX3RDKOV5640.c **** 
 896:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 2069              		.loc 1 896 0
 2070 0664 24301BE5 		ldr	r3, [fp, #-36]
 2071 0668 000053E3 		cmp	r3, #0
 2072 066c 0300000A 		beq	.L120
 897:../CX3RDKOV5640.c **** 					{
 898:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:SET_CUR:GetEP0Data Err = 0x%x.", status);
 2073              		.loc 1 898 0
 2074 0670 0400A0E3 		mov	r0, #4
 2075 0674 F4119FE5 		ldr	r1, .L132+72
 2076 0678 24201BE5 		ldr	r2, [fp, #-36]
 2077 067c FEFFFFEB 		bl	CyU3PDebugPrint
 2078              	.L120:
 899:../CX3RDKOV5640.c **** 					}
 900:../CX3RDKOV5640.c **** 					/* Check the read count. Expecting a count of CX3_UVC_MAX_PROBE_SETTING bytes. */
 901:../CX3RDKOV5640.c **** 					if (readCount > (uint16_t)ES_UVC_MAX_STILL_PROBE_SETTING)
 2079              		.loc 1 901 0
 2080 0680 B2335BE1 		ldrh	r3, [fp, #-50]
 2081 0684 0B0053E3 		cmp	r3, #11
 2082 0688 0300009A 		bls	.L121
 902:../CX3RDKOV5640.c **** 					{
 903:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:Invalid SET_CUR Rqt Len.");
 2083              		.loc 1 903 0
 2084 068c 0400A0E3 		mov	r0, #4
 2085 0690 DC119FE5 		ldr	r1, .L132+76
 2086 0694 FEFFFFEB 		bl	CyU3PDebugPrint
 2087 0698 0F0000EA 		b	.L122
 2088              	.L121:
 904:../CX3RDKOV5640.c **** 					}
 905:../CX3RDKOV5640.c **** 					else
 906:../CX3RDKOV5640.c **** 					{
 907:../CX3RDKOV5640.c **** 						/* Set Probe Control */
 908:../CX3RDKOV5640.c **** 						if(wValue == ES_UVC_STILL_PROBE_CONTROL)
 2089              		.loc 1 908 0
 2090 069c BC325BE1 		ldrh	r3, [fp, #-44]
 2091 06a0 030C53E3 		cmp	r3, #768
 2092 06a4 0400001A 		bne	.L123
 909:../CX3RDKOV5640.c **** 						{
 910:../CX3RDKOV5640.c **** 							glCurrentStillFrameIndex = glStillCommitCtrl[1];
 2093              		.loc 1 910 0
 2094 06a8 D0319FE5 		ldr	r3, .L132+88
 2095 06ac 0120D3E5 		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 2096 06b0 D4319FE5 		ldr	r3, .L132+100
 2097 06b4 0020C3E5 		strb	r2, [r3]
 2098 06b8 070000EA 		b	.L122
 2099              	.L123:
 911:../CX3RDKOV5640.c **** 						}
 912:../CX3RDKOV5640.c **** 						/* Set Commit Control and Start Streaming*/
 913:../CX3RDKOV5640.c **** 						else if(wValue == ES_UVC_STILL_COMMIT_CONTROL)
 2100              		.loc 1 913 0
 2101 06bc BC325BE1 		ldrh	r3, [fp, #-44]
 2102 06c0 010B53E3 		cmp	r3, #1024
 2103 06c4 0400001A 		bne	.L122
 914:../CX3RDKOV5640.c **** 						{
 915:../CX3RDKOV5640.c **** 							glCurrentStillFrameIndex = glStillCommitCtrl[1];
 2104              		.loc 1 915 0
 2105 06c8 B0319FE5 		ldr	r3, .L132+88
 2106 06cc 0120D3E5 		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 2107 06d0 B4319FE5 		ldr	r3, .L132+100
 2108 06d4 0020C3E5 		strb	r2, [r3]
 901:../CX3RDKOV5640.c **** 					{
 2109              		.loc 1 901 0
 2110 06d8 220000EA 		b	.L117
 2111              	.L122:
 2112 06dc 210000EA 		b	.L117
 2113              	.L119:
 916:../CX3RDKOV5640.c **** 						}
 917:../CX3RDKOV5640.c **** 					}
 918:../CX3RDKOV5640.c **** 
 919:../CX3RDKOV5640.c ****                 }
 920:../CX3RDKOV5640.c ****                 else if(wValue == ES_UVC_STILL_TRIGGER)
 2114              		.loc 1 920 0
 2115 06e0 BC325BE1 		ldrh	r3, [fp, #-44]
 2116 06e4 050C53E3 		cmp	r3, #1280
 2117 06e8 4A00001A 		bne	.L88
 921:../CX3RDKOV5640.c ****                 {
 922:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(ES_UVC_STILL_TRIGGER_ALIGNED,&glStillTriggerCtrl, &readCount);
 2118              		.loc 1 922 0
 2119 06ec 32304BE2 		sub	r3, fp, #50
 2120 06f0 1000A0E3 		mov	r0, #16
 2121 06f4 94119FE5 		ldr	r1, .L132+104
 2122 06f8 0320A0E1 		mov	r2, r3
 2123 06fc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2124 0700 24000BE5 		str	r0, [fp, #-36]
 923:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 2125              		.loc 1 923 0
 2126 0704 24301BE5 		ldr	r3, [fp, #-36]
 2127 0708 000053E3 		cmp	r3, #0
 2128 070c 0300000A 		beq	.L124
 924:../CX3RDKOV5640.c **** 					{
 925:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:SET_CUR:GetEP0Data Err = 0x%x.", status);
 2129              		.loc 1 925 0
 2130 0710 0400A0E3 		mov	r0, #4
 2131 0714 54119FE5 		ldr	r1, .L132+72
 2132 0718 24201BE5 		ldr	r2, [fp, #-36]
 2133 071c FEFFFFEB 		bl	CyU3PDebugPrint
 2134              	.L124:
 926:../CX3RDKOV5640.c **** 					}
 927:../CX3RDKOV5640.c **** 					/* Check the read count. Expecting a count of CX3_UVC_MAX_PROBE_SETTING bytes. */
 928:../CX3RDKOV5640.c **** 					if (readCount > (uint16_t)ES_UVC_STILL_TRIGGER_COUNT)
 2135              		.loc 1 928 0
 2136 0720 B2335BE1 		ldrh	r3, [fp, #-50]
 2137 0724 010053E3 		cmp	r3, #1
 2138 0728 0300009A 		bls	.L125
 929:../CX3RDKOV5640.c **** 					{
 930:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:Invalid SET_CUR Rqt Len.");
 2139              		.loc 1 930 0
 2140 072c 0400A0E3 		mov	r0, #4
 2141 0730 3C119FE5 		ldr	r1, .L132+76
 2142 0734 FEFFFFEB 		bl	CyU3PDebugPrint
 2143 0738 360000EA 		b	.L88
 2144              	.L125:
 931:../CX3RDKOV5640.c **** 					}
 932:../CX3RDKOV5640.c **** 					else
 933:../CX3RDKOV5640.c **** 					{
 934:../CX3RDKOV5640.c **** 						if(glStillTriggerCtrl == 0x01)
 2145              		.loc 1 934 0
 2146 073c 4C319FE5 		ldr	r3, .L132+104
 2147 0740 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2148 0744 010053E3 		cmp	r3, #1
 2149 0748 3200001A 		bne	.L88
 935:../CX3RDKOV5640.c **** 						{
 936:../CX3RDKOV5640.c **** 							glStillSkip = 3; //for still test 0;//
 2150              		.loc 1 936 0
 2151 074c 40319FE5 		ldr	r3, .L132+108
 2152 0750 0320A0E3 		mov	r2, #3
 2153 0754 0020C3E5 		strb	r2, [r3]
 937:../CX3RDKOV5640.c **** 							glStillCaptureStart = CyTrue;
 2154              		.loc 1 937 0
 2155 0758 38319FE5 		ldr	r3, .L132+112
 2156 075c 0120A0E3 		mov	r2, #1
 2157 0760 002083E5 		str	r2, [r3]
 2158 0764 2B0000EA 		b	.L88
 2159              	.L117:
 2160 0768 2A0000EA 		b	.L88
 2161              	.L105:
 938:../CX3RDKOV5640.c **** 						}
 939:../CX3RDKOV5640.c **** 					}
 940:../CX3RDKOV5640.c ****                 }
 941:../CX3RDKOV5640.c ****             }
 942:../CX3RDKOV5640.c ****             else
 943:../CX3RDKOV5640.c ****             {
 944:../CX3RDKOV5640.c ****                 /* Mark with error. */
 945:../CX3RDKOV5640.c ****                 status = CY_U3P_ERROR_FAILURE;
 2162              		.loc 1 945 0
 2163 076c 4A30A0E3 		mov	r3, #74
 2164 0770 24300BE5 		str	r3, [fp, #-36]
 2165 0774 270000EA 		b	.L88
 2166              	.L104:
 2167 0778 260000EA 		b	.L88
 2168              	.L89:
 946:../CX3RDKOV5640.c ****             }
 947:../CX3RDKOV5640.c ****         }
 948:../CX3RDKOV5640.c ****         else if((wIndex & 0x00FF) == ES_UVC_CONTROL_INTERFACE) /* Video Control Interface */
 2169              		.loc 1 948 0
 2170 077c BE325BE1 		ldrh	r3, [fp, #-46]
 2171 0780 FF3003E2 		and	r3, r3, #255
 2172 0784 000053E3 		cmp	r3, #0
 2173 0788 2200001A 		bne	.L88
 949:../CX3RDKOV5640.c ****         {
 950:../CX3RDKOV5640.c ****             isHandled = CyTrue;
 2174              		.loc 1 950 0
 2175 078c 0130A0E3 		mov	r3, #1
 2176 0790 20300BE5 		str	r3, [fp, #-32]
 951:../CX3RDKOV5640.c ****             /* Respond to VC_REQUEST_ERROR_CODE_CONTROL and stall every other request as this examp
 952:../CX3RDKOV5640.c ****                any of the Video Control features */
 953:../CX3RDKOV5640.c **** #if 0 /* the two controls handler test */
 954:../CX3RDKOV5640.c ****             if((wIndex == 0x200) && (wValue == 0x200))/*Brightness*/
 955:../CX3RDKOV5640.c ****             {
 956:../CX3RDKOV5640.c ****             	switch(bRequest)
 957:../CX3RDKOV5640.c ****             	{
 958:../CX3RDKOV5640.c ****             	case ES_UVC_USB_GET_INFO_REQ:
 959:../CX3RDKOV5640.c ****             		glGet_Info=0x03;
 960:../CX3RDKOV5640.c ****             		status = CyU3PUsbSendEP0Data(1,&glGet_Info);
 961:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 962:../CX3RDKOV5640.c **** 					{
 963:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
 964:../CX3RDKOV5640.c **** 					}
 965:../CX3RDKOV5640.c **** 					break;
 966:../CX3RDKOV5640.c ****             	case ES_UVC_USB_GET_MIN_REQ:
 967:../CX3RDKOV5640.c **** 					glGet_Info=0x00;
 968:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,&glGet_Info);
 969:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 970:../CX3RDKOV5640.c **** 					{
 971:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
 972:../CX3RDKOV5640.c **** 					}
 973:../CX3RDKOV5640.c **** 					break;
 974:../CX3RDKOV5640.c ****             	case ES_UVC_USB_GET_MAX_REQ:
 975:../CX3RDKOV5640.c **** 					glGet_Info=0xFF;
 976:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,&glGet_Info);
 977:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 978:../CX3RDKOV5640.c **** 					{
 979:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
 980:../CX3RDKOV5640.c **** 					}
 981:../CX3RDKOV5640.c **** 					break;
 982:../CX3RDKOV5640.c ****             	case ES_UVC_USB_GET_RES_REQ:
 983:../CX3RDKOV5640.c **** 					glGet_Info=0x01;
 984:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,&glGet_Info);
 985:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 986:../CX3RDKOV5640.c **** 					{
 987:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
 988:../CX3RDKOV5640.c **** 					}
 989:../CX3RDKOV5640.c **** 					break;
 990:../CX3RDKOV5640.c ****             	case ES_UVC_USB_GET_CUR_REQ:
 991:../CX3RDKOV5640.c ****             	case ES_UVC_USB_GET_DEF_REQ:
 992:../CX3RDKOV5640.c ****             		RequestOption = (bRequest & 0x0F);
 993:../CX3RDKOV5640.c **** 
 994:../CX3RDKOV5640.c ****             		//TODO Change this function with the "Sensor specific" function to Service all the GE
 995:../CX3RDKOV5640.c ****             		gl16GetControl = SensorGetControl(AExReferleveReg0, I2C_EAGLESDP_ADDR);//esOV5640_Get
 996:../CX3RDKOV5640.c ****             		status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
 997:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
 998:../CX3RDKOV5640.c **** 					{
 999:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1000:../CX3RDKOV5640.c **** 					}
1001:../CX3RDKOV5640.c ****             		break;
1002:../CX3RDKOV5640.c ****             	case ES_UVC_USB_SET_CUR_REQ:
1003:../CX3RDKOV5640.c ****             		status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1004:../CX3RDKOV5640.c ****             		if (status != CY_U3P_SUCCESS)
1005:../CX3RDKOV5640.c **** 					{
1006:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1007:../CX3RDKOV5640.c **** 					}
1008:../CX3RDKOV5640.c ****             		//TODO Change this function with the "Sensor specific" function to Service the SET re
1009:../CX3RDKOV5640.c ****             		SensorSetControl(AExReferleveReg0, I2C_EAGLESDP_ADDR, (int8_t)gl16SetControl);//esOV5
1010:../CX3RDKOV5640.c **** 					break;
1011:../CX3RDKOV5640.c ****             	}
1012:../CX3RDKOV5640.c ****             }
1013:../CX3RDKOV5640.c ****             else if((wIndex == 0x100) && (wValue == 0x200))/*Auto Exposure*/
1014:../CX3RDKOV5640.c **** 			{
1015:../CX3RDKOV5640.c ****             //	CyU3PDebugPrint (4, "\n\rAuto Exposure");
1016:../CX3RDKOV5640.c **** 				switch(bRequest)
1017:../CX3RDKOV5640.c **** 				{
1018:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1019:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1020:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1021:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1022:../CX3RDKOV5640.c **** 					{
1023:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1024:../CX3RDKOV5640.c **** 					}
1025:../CX3RDKOV5640.c **** 					break;
1026:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1027:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1028:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1029:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1030:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1031:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1032:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1033:../CX3RDKOV5640.c **** 					gl8GetControl = SensorGetControl(AExModeReg, I2C_EAGLESDP_ADDR);//esOV5640_GetAutoExposure(Req
1034:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,(uint8_t*)&gl8GetControl);
1035:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1036:../CX3RDKOV5640.c **** 					{
1037:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1038:../CX3RDKOV5640.c **** 					}
1039:../CX3RDKOV5640.c **** 					break;
1040:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1041:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl8SetControl,&readCount);
1042:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1043:../CX3RDKOV5640.c **** 					{
1044:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1045:../CX3RDKOV5640.c **** 					}
1046:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1047:../CX3RDKOV5640.c **** 				//	CyU3PDebugPrint (4, "\n\rAuto Exposure= %d",gl8SetControl);
1048:../CX3RDKOV5640.c **** 					SensorSetControl(AExModeReg, I2C_EAGLESDP_ADDR, (int8_t)gl16SetControl);//esOV5640_SetAutoExpo
1049:../CX3RDKOV5640.c **** 					break;
1050:../CX3RDKOV5640.c **** 				}
1051:../CX3RDKOV5640.c **** 			}
1052:../CX3RDKOV5640.c ****             else if((wIndex == 0x300) && (wValue == 0x300))/*Mirror (Contrast)*/
1053:../CX3RDKOV5640.c ****             {
1054:../CX3RDKOV5640.c ****             	switch(bRequest)
1055:../CX3RDKOV5640.c **** 				{
1056:../CX3RDKOV5640.c ****             	case CY_FX_USB_UVC_GET_LEN_REQ:
1057:../CX3RDKOV5640.c **** 					glGet_Info=0x02;
1058:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2, &glGet_Info);
1059:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1060:../CX3RDKOV5640.c **** 					{
1061:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1062:../CX3RDKOV5640.c **** 					}
1063:../CX3RDKOV5640.c **** 					CyU3PDebugPrint (4, "\n\rUSB_Ext: Mirror SendEP0Data = %d data %d", status, glGet_Info);
1064:../CX3RDKOV5640.c **** 					break;
1065:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1066:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1067:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1068:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1069:../CX3RDKOV5640.c **** 					{
1070:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1071:../CX3RDKOV5640.c **** 					}
1072:../CX3RDKOV5640.c **** 					break;
1073:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1074:../CX3RDKOV5640.c **** 					glGet_Info=0x00;
1075:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,&glGet_Info);
1076:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1077:../CX3RDKOV5640.c **** 					{
1078:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1079:../CX3RDKOV5640.c **** 					}
1080:../CX3RDKOV5640.c **** 					break;
1081:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1082:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1083:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,&glGet_Info);
1084:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1085:../CX3RDKOV5640.c **** 					{
1086:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1087:../CX3RDKOV5640.c **** 					}
1088:../CX3RDKOV5640.c **** 					break;
1089:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1090:../CX3RDKOV5640.c **** 					glGet_Info=0x01;
1091:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,&glGet_Info);
1092:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1093:../CX3RDKOV5640.c **** 					{
1094:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1095:../CX3RDKOV5640.c **** 					}
1096:../CX3RDKOV5640.c **** 					break;
1097:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1098:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1099:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1100:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1101:../CX3RDKOV5640.c **** 					gl16GetControl = SensorGetControl(MirrModeReg, I2C_EAGLESDP_ADDR);//esOV5640_GetContrast(Reque
1102:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
1103:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1104:../CX3RDKOV5640.c **** 					{
1105:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1106:../CX3RDKOV5640.c **** 					}
1107:../CX3RDKOV5640.c **** 					break;
1108:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1109:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1110:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1111:../CX3RDKOV5640.c **** 					{
1112:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1113:../CX3RDKOV5640.c **** 					}
1114:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1115:../CX3RDKOV5640.c **** 					SensorSetControl(MirrModeReg, I2C_EAGLESDP_ADDR, (int8_t)gl16SetControl);//esOV5640_SetContras
1116:../CX3RDKOV5640.c **** 					break;
1117:../CX3RDKOV5640.c **** 				}
1118:../CX3RDKOV5640.c ****             }
1119:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x100) && (wValue == 0x400))/*Manual Exposure*/
1120:../CX3RDKOV5640.c **** 			{
1121:../CX3RDKOV5640.c ****             	//CyU3PDebugPrint (4, "\n\rManual Exposure ");
1122:../CX3RDKOV5640.c **** 				switch(bRequest)
1123:../CX3RDKOV5640.c **** 				{
1124:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1125:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1126:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1127:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1128:../CX3RDKOV5640.c **** 					{
1129:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1130:../CX3RDKOV5640.c **** 					}
1131:../CX3RDKOV5640.c **** 					break;
1132:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1133:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1134:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1135:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1136:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1137:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1138:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1139:../CX3RDKOV5640.c **** 					gl32GetControl = esOV5640_GetExposure(RequestOption);
1140:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(4,(uint8_t*)&gl32GetControl);
1141:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1142:../CX3RDKOV5640.c **** 					{
1143:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1144:../CX3RDKOV5640.c **** 					}
1145:../CX3RDKOV5640.c **** 					break;
1146:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1147:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl32SetControl,&readCount);
1148:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1149:../CX3RDKOV5640.c **** 					{
1150:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1151:../CX3RDKOV5640.c **** 					}
1152:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1153:../CX3RDKOV5640.c **** 				//	CyU3PDebugPrint (4, "\n\rManual Exposure = %d", gl32SetControl);
1154:../CX3RDKOV5640.c **** 					esOV5640_SetExposure(gl32SetControl);
1155:../CX3RDKOV5640.c **** 					break;
1156:../CX3RDKOV5640.c **** 				}
1157:../CX3RDKOV5640.c **** 			}
1158:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x200) && (wValue == 0x600))/*Hue*/
1159:../CX3RDKOV5640.c **** 			{
1160:../CX3RDKOV5640.c **** 				switch(bRequest)
1161:../CX3RDKOV5640.c **** 				{
1162:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1163:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1164:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1165:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1166:../CX3RDKOV5640.c **** 					{
1167:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1168:../CX3RDKOV5640.c **** 					}
1169:../CX3RDKOV5640.c **** 					break;
1170:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1171:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1172:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1173:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1174:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1175:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1176:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1177:../CX3RDKOV5640.c **** 					gl32GetControl = (int32_t)esOV5640_GetHue(RequestOption);
1178:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(4,(uint8_t*)&gl32GetControl);
1179:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1180:../CX3RDKOV5640.c **** 					{
1181:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1182:../CX3RDKOV5640.c **** 					}
1183:../CX3RDKOV5640.c **** 					break;
1184:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1185:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl32SetControl,&readCount);
1186:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1187:../CX3RDKOV5640.c **** 					{
1188:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1189:../CX3RDKOV5640.c **** 					}
1190:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1191:../CX3RDKOV5640.c **** 					esOV5640_SetHue((int8_t)gl32SetControl);
1192:../CX3RDKOV5640.c **** 					break;
1193:../CX3RDKOV5640.c **** 				}
1194:../CX3RDKOV5640.c **** 			}
1195:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x100) && (wValue == 0x600))/*Manual Focus*/
1196:../CX3RDKOV5640.c **** 			{
1197:../CX3RDKOV5640.c ****             	//CyU3PDebugPrint (4, "\n\rManual Focus ");
1198:../CX3RDKOV5640.c **** 				switch(bRequest)
1199:../CX3RDKOV5640.c **** 				{
1200:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1201:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1202:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1203:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1204:../CX3RDKOV5640.c **** 					{
1205:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1206:../CX3RDKOV5640.c **** 					}
1207:../CX3RDKOV5640.c **** 					break;
1208:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1209:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1210:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1211:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1212:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1213:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1214:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1215:../CX3RDKOV5640.c **** 					gl16GetControl = esOV5640_GetManualfocus(RequestOption);
1216:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
1217:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1218:../CX3RDKOV5640.c **** 					{
1219:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1220:../CX3RDKOV5640.c **** 					}
1221:../CX3RDKOV5640.c **** 					break;
1222:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1223:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1224:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1225:../CX3RDKOV5640.c **** 					{
1226:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1227:../CX3RDKOV5640.c **** 					}
1228:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1229:../CX3RDKOV5640.c **** 				//	CyU3PDebugPrint (4, "\n\rManual Focus= %d",gl16SetControl);
1230:../CX3RDKOV5640.c **** 					esOV5640_SetManualfocus((uint16_t)gl16SetControl);
1231:../CX3RDKOV5640.c **** 					g_IsAutoFocus = 0;
1232:../CX3RDKOV5640.c **** 					break;
1233:../CX3RDKOV5640.c **** 				}
1234:../CX3RDKOV5640.c **** 			}
1235:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x200) && (wValue == 0x700))/*Saturation*/
1236:../CX3RDKOV5640.c **** 			{
1237:../CX3RDKOV5640.c **** 				switch(bRequest)
1238:../CX3RDKOV5640.c **** 				{
1239:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1240:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1241:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1242:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1243:../CX3RDKOV5640.c **** 					{
1244:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1245:../CX3RDKOV5640.c **** 					}
1246:../CX3RDKOV5640.c **** 					break;
1247:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1248:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1249:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1250:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1251:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1252:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1253:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1254:../CX3RDKOV5640.c **** 					gl16GetControl = esOV5640_GetSaturation(RequestOption);
1255:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
1256:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1257:../CX3RDKOV5640.c **** 					{
1258:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1259:../CX3RDKOV5640.c **** 					}
1260:../CX3RDKOV5640.c **** 					break;
1261:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1262:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1263:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1264:../CX3RDKOV5640.c **** 					{
1265:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1266:../CX3RDKOV5640.c **** 					}
1267:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1268:../CX3RDKOV5640.c **** 					esOV5640_SetSaturation((uint32_t)gl16SetControl);
1269:../CX3RDKOV5640.c **** 					break;
1270:../CX3RDKOV5640.c **** 				}
1271:../CX3RDKOV5640.c **** 			}
1272:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x200) && (wValue == 0x800))/*Sharpness*/
1273:../CX3RDKOV5640.c **** 			{
1274:../CX3RDKOV5640.c **** 				switch(bRequest)
1275:../CX3RDKOV5640.c **** 				{
1276:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1277:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1278:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1279:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1280:../CX3RDKOV5640.c **** 					{
1281:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1282:../CX3RDKOV5640.c **** 					}
1283:../CX3RDKOV5640.c **** 					break;
1284:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1285:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1286:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1287:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1288:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1289:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1290:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1291:../CX3RDKOV5640.c **** 					gl16GetControl = esOV5640_GetSharpness(RequestOption);
1292:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
1293:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1294:../CX3RDKOV5640.c **** 					{
1295:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1296:../CX3RDKOV5640.c **** 					}
1297:../CX3RDKOV5640.c **** 					break;
1298:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1299:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1300:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1301:../CX3RDKOV5640.c **** 					{
1302:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1303:../CX3RDKOV5640.c **** 					}
1304:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1305:../CX3RDKOV5640.c **** 					esOV5640_SetSharpness((uint8_t)gl16SetControl);
1306:../CX3RDKOV5640.c **** 					break;
1307:../CX3RDKOV5640.c **** 				}
1308:../CX3RDKOV5640.c **** 			}
1309:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x100) && (wValue == 0x800))/*Auto Focus*/
1310:../CX3RDKOV5640.c **** 			{
1311:../CX3RDKOV5640.c ****             	CyU3PDebugPrint (4, "\n\rAuto Focus");
1312:../CX3RDKOV5640.c **** 				switch(bRequest)
1313:../CX3RDKOV5640.c **** 				{
1314:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1315:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1316:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1317:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1318:../CX3RDKOV5640.c **** 					{
1319:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1320:../CX3RDKOV5640.c **** 					}
1321:../CX3RDKOV5640.c **** 					break;
1322:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1323:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1324:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1325:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1326:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1327:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1328:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1329:../CX3RDKOV5640.c **** 					gl8GetControl = esOV5640_GetAutofocus(RequestOption);
1330:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl8GetControl);
1331:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1332:../CX3RDKOV5640.c **** 					{
1333:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1334:../CX3RDKOV5640.c **** 					}
1335:../CX3RDKOV5640.c **** 					break;
1336:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1337:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl8SetControl,&readCount);
1338:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1339:../CX3RDKOV5640.c **** 					{
1340:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1341:../CX3RDKOV5640.c **** 					}
1342:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1343:../CX3RDKOV5640.c **** 				//	CyU3PDebugPrint (4, "\n\rAuto Focus =%d",gl8SetControl);
1344:../CX3RDKOV5640.c **** 					esOV5640_SetAutofocus((uint8_t)gl8SetControl);
1345:../CX3RDKOV5640.c **** 					g_IsAutoFocus = 1;
1346:../CX3RDKOV5640.c **** 					break;
1347:../CX3RDKOV5640.c **** 				}
1348:../CX3RDKOV5640.c **** 			}
1349:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x200) && (wValue == 0xA00))/*White Balance manual*/
1350:../CX3RDKOV5640.c **** 			{
1351:../CX3RDKOV5640.c **** 				switch(bRequest)
1352:../CX3RDKOV5640.c **** 				{
1353:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1354:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1355:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1356:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1357:../CX3RDKOV5640.c **** 					{
1358:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1359:../CX3RDKOV5640.c **** 					}
1360:../CX3RDKOV5640.c **** 					break;
1361:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1362:../CX3RDKOV5640.c **** 					glGet_Info=0x00;
1363:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&glGet_Info);
1364:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1365:../CX3RDKOV5640.c **** 					{
1366:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1367:../CX3RDKOV5640.c **** 					}
1368:../CX3RDKOV5640.c **** 					break;
1369:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1370:../CX3RDKOV5640.c **** 					glGet_Info=0xFF;
1371:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&glGet_Info);
1372:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1373:../CX3RDKOV5640.c **** 					{
1374:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1375:../CX3RDKOV5640.c **** 					}
1376:../CX3RDKOV5640.c **** 					break;
1377:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1378:../CX3RDKOV5640.c **** 					glGet_Info=0x1;
1379:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&glGet_Info);
1380:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1381:../CX3RDKOV5640.c **** 					{
1382:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1383:../CX3RDKOV5640.c **** 					}
1384:../CX3RDKOV5640.c **** 					break;
1385:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1386:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1387:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1388:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1389:../CX3RDKOV5640.c **** 					gl16GetControl = esOV5640_GetWhiteBalance(RequestOption);
1390:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
1391:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1392:../CX3RDKOV5640.c **** 					{
1393:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1394:../CX3RDKOV5640.c **** 					}
1395:../CX3RDKOV5640.c **** 					break;
1396:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1397:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1398:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1399:../CX3RDKOV5640.c **** 					{
1400:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1401:../CX3RDKOV5640.c **** 					}
1402:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1403:../CX3RDKOV5640.c **** 					esOV5640_SetWhiteBalance((uint8_t)gl16SetControl);
1404:../CX3RDKOV5640.c **** 					break;
1405:../CX3RDKOV5640.c **** 				}
1406:../CX3RDKOV5640.c **** 			}
1407:../CX3RDKOV5640.c ****             else if(0&&(wIndex == 0x200) && (wValue == 0xB00))/*White Balance Auto*/
1408:../CX3RDKOV5640.c **** 			{
1409:../CX3RDKOV5640.c **** 				switch(bRequest)
1410:../CX3RDKOV5640.c **** 				{
1411:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_INFO_REQ:
1412:../CX3RDKOV5640.c **** 					glGet_Info=0x03;
1413:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(1,&glGet_Info);
1414:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1415:../CX3RDKOV5640.c **** 					{
1416:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1417:../CX3RDKOV5640.c **** 					}
1418:../CX3RDKOV5640.c **** 					break;
1419:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MIN_REQ:
1420:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_MAX_REQ:
1421:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_RES_REQ:
1422:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_CUR_REQ:
1423:../CX3RDKOV5640.c **** 				case ES_UVC_USB_GET_DEF_REQ:
1424:../CX3RDKOV5640.c **** 					RequestOption = (bRequest & 0x0F);
1425:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service all the GET request
1426:../CX3RDKOV5640.c **** 					gl16GetControl = esOV5640_GetAutoWhiteBalance(RequestOption);
1427:../CX3RDKOV5640.c **** 					status = CyU3PUsbSendEP0Data(2,(uint8_t*)&gl16GetControl);
1428:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1429:../CX3RDKOV5640.c **** 					{
1430:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1431:../CX3RDKOV5640.c **** 					}
1432:../CX3RDKOV5640.c **** 					break;
1433:../CX3RDKOV5640.c **** 				case ES_UVC_USB_SET_CUR_REQ:
1434:../CX3RDKOV5640.c **** 					status = CyU3PUsbGetEP0Data(16,(uint8_t*)&gl16SetControl,&readCount);
1435:../CX3RDKOV5640.c **** 					if (status != CY_U3P_SUCCESS)
1436:../CX3RDKOV5640.c **** 					{
1437:../CX3RDKOV5640.c **** 						CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1438:../CX3RDKOV5640.c **** 					}
1439:../CX3RDKOV5640.c **** 					//TODO Change this function with the "Sensor specific" function to Service the SET request for
1440:../CX3RDKOV5640.c **** 					esOV5640_SetAutoWhiteBalance((uint8_t)gl16SetControl);
1441:../CX3RDKOV5640.c **** 					break;
1442:../CX3RDKOV5640.c **** 				}
1443:../CX3RDKOV5640.c **** 			}
1444:../CX3RDKOV5640.c ****             else if((wValue == ES_UVC_VC_REQUEST_ERROR_CODE_CONTROL) && (wIndex == 0x00))
1445:../CX3RDKOV5640.c ****             {
1446:../CX3RDKOV5640.c ****                 temp = ES_UVC_ERROR_INVALID_CONTROL;
1447:../CX3RDKOV5640.c ****                 status = CyU3PUsbSendEP0Data(0x01, &temp);
1448:../CX3RDKOV5640.c ****                 if (status != CY_U3P_SUCCESS)
1449:../CX3RDKOV5640.c ****                 {
1450:../CX3RDKOV5640.c ****                     CyU3PDebugPrint (4, "\n\rUSBStpCB:VCI SendEP0Data = %d", status);
1451:../CX3RDKOV5640.c ****                 }
1452:../CX3RDKOV5640.c ****             }
1453:../CX3RDKOV5640.c ****             else
1454:../CX3RDKOV5640.c ****                 CyU3PUsbStall(0,CyTrue, CyTrue);
1455:../CX3RDKOV5640.c **** #else
1456:../CX3RDKOV5640.c ****             /* the new UVC control requests handler */
1457:../CX3RDKOV5640.c ****         	switch ((wIndex >> 8))
 2177              		.loc 1 1457 0
 2178 0794 BE325BE1 		ldrh	r3, [fp, #-46]
 2179 0798 2334A0E1 		mov	r3, r3, lsr #8
 2180 079c 0338A0E1 		mov	r3, r3, asl #16
 2181 07a0 2338A0E1 		mov	r3, r3, lsr #16
 2182 07a4 020053E3 		cmp	r3, #2
 2183 07a8 0200000A 		beq	.L127
 2184 07ac 030053E3 		cmp	r3, #3
 2185 07b0 0600000A 		beq	.L128
 2186 07b4 0B0000EA 		b	.L131
 2187              	.L127:
1458:../CX3RDKOV5640.c ****             {
1459:../CX3RDKOV5640.c **** 
1460:../CX3RDKOV5640.c ****                 case CY_FX_UVC_PROCESSING_UNIT_ID:
1461:../CX3RDKOV5640.c ****                     UVCHandleProcessingUnitRqts (wValue, bRequest);
 2188              		.loc 1 1461 0
 2189 07b8 BC225BE1 		ldrh	r2, [fp, #-44]
 2190 07bc 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 2191 07c0 0200A0E1 		mov	r0, r2
 2192 07c4 0310A0E1 		mov	r1, r3
 2193 07c8 FEFFFFEB 		bl	UVCHandleProcessingUnitRqts
1462:../CX3RDKOV5640.c ****                     break;
 2194              		.loc 1 1462 0
 2195 07cc 0A0000EA 		b	.L129
 2196              	.L128:
1463:../CX3RDKOV5640.c ****                 case CY_FX_UVC_EXTENSION_UNIT_ID:
1464:../CX3RDKOV5640.c ****                     UVCHandleExtensionUnitRqts (wValue, bRequest);
 2197              		.loc 1 1464 0
 2198 07d0 BC225BE1 		ldrh	r2, [fp, #-44]
 2199 07d4 2A305BE5 		ldrb	r3, [fp, #-42]	@ zero_extendqisi2
 2200 07d8 0200A0E1 		mov	r0, r2
 2201 07dc 0310A0E1 		mov	r1, r3
 2202 07e0 FEFFFFEB 		bl	UVCHandleExtensionUnitRqts
1465:../CX3RDKOV5640.c ****                     break;
 2203              		.loc 1 1465 0
 2204 07e4 040000EA 		b	.L129
 2205              	.L131:
1466:../CX3RDKOV5640.c ****                 case CY_FX_UVC_CAMERA_TERMINAL_ID:
1467:../CX3RDKOV5640.c ****                     //UVCHandleCameraTerminalRqts ();
1468:../CX3RDKOV5640.c ****                     //break;
1469:../CX3RDKOV5640.c ****                 case CY_FX_UVC_INTERFACE_CTRL:
1470:../CX3RDKOV5640.c ****                     //UVCHandleInterfaceCtrlRqts ();
1471:../CX3RDKOV5640.c ****                     //break;
1472:../CX3RDKOV5640.c **** 
1473:../CX3RDKOV5640.c ****                 default:
1474:../CX3RDKOV5640.c ****                     /* Unsupported request. Fail by stalling the control endpoint. */
1475:../CX3RDKOV5640.c ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
 2206              		.loc 1 1475 0
 2207 07e8 0000A0E3 		mov	r0, #0
 2208 07ec 0110A0E3 		mov	r1, #1
 2209 07f0 0020A0E3 		mov	r2, #0
 2210 07f4 FEFFFFEB 		bl	CyU3PUsbStall
1476:../CX3RDKOV5640.c ****                     break;
 2211              		.loc 1 1476 0
 2212 07f8 0000A0E1 		mov	r0, r0	@ nop
 2213              	.L129:
1477:../CX3RDKOV5640.c ****             }
1478:../CX3RDKOV5640.c ****         	CyU3PDebugPrint (4, "\n\rUSBStpCB:control interface wIndex = 0x%x wValue = 0x%x bRequest =
 2214              		.loc 1 1478 0
 2215 07fc BE225BE1 		ldrh	r2, [fp, #-46]
 2216 0800 BC325BE1 		ldrh	r3, [fp, #-44]
 2217 0804 2A105BE5 		ldrb	r1, [fp, #-42]	@ zero_extendqisi2
 2218 0808 00108DE5 		str	r1, [sp]
 2219 080c 0400A0E3 		mov	r0, #4
 2220 0810 84109FE5 		ldr	r1, .L132+116
 2221 0814 FEFFFFEB 		bl	CyU3PDebugPrint
 2222              	.L88:
1479:../CX3RDKOV5640.c ****         	/* the end of the controls handler */
1480:../CX3RDKOV5640.c **** #endif
1481:../CX3RDKOV5640.c ****         }
1482:../CX3RDKOV5640.c ****     }
1483:../CX3RDKOV5640.c ****     return isHandled;
 2223              		.loc 1 1483 0
 2224 0818 20301BE5 		ldr	r3, [fp, #-32]
 2225              	.L130:
1484:../CX3RDKOV5640.c **** }
 2226              		.loc 1 1484 0
 2227 081c 0300A0E1 		mov	r0, r3
 2228 0820 18D04BE2 		sub	sp, fp, #24
 2229              		@ sp needed
 2230 0824 F089BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, fp, pc}
 2231              	.L133:
 2232              		.align	2
 2233              	.L132:
 2234 0828 64010000 		.word	.LC10
 2235 082c 00000000 		.word	glIsApplnActive
 2236 0830 00000000 		.word	glIsStreamingStarted
 2237 0834 00000000 		.word	glPreviewStarted
 2238 0838 00000000 		.word	glIsClearFeature
 2239 083c 00000000 		.word	glcommitcount
 2240 0840 00000000 		.word	glIsConfigured
 2241 0844 00000000 		.word	glCurrentFrameIndex
 2242 0848 00000000 		.word	glProbeCtrl
 2243 084c 00000000 		.word	gl5MpProbeCtrl
 2244 0850 00000000 		.word	gl720pProbeCtrl
 2245 0854 00000000 		.word	glVga60ProbeCtrl
 2246 0858 00000000 		.word	gl1080pProbeCtrl
 2247 085c 00000000 		.word	glVga30ProbeCtrl
 2248 0860 B4010000 		.word	.LC11
 2249 0864 D0010000 		.word	.LC12
 2250 0868 00000000 		.word	glStillProbeCtrl
 2251 086c 00000000 		.word	glCommitCtrl
 2252 0870 FC010000 		.word	.LC13
 2253 0874 28020000 		.word	.LC14
 2254 0878 00000000 		.word	glcheckframe
 2255 087c 00000000 		.word	glFrameIndexToSet
 2256 0880 00000000 		.word	glStillCommitCtrl
 2257 0884 4C020000 		.word	.LC15
 2258 0888 70020000 		.word	.LC16
 2259 088c 00000000 		.word	glCurrentStillFrameIndex
 2260 0890 00000000 		.word	glStillTriggerCtrl
 2261 0894 00000000 		.word	glStillSkip
 2262 0898 00000000 		.word	glStillCaptureStart
 2263 089c 98020000 		.word	.LC17
 2264              		.cfi_endproc
 2265              	.LFE10:
 2267              		.section	.rodata
 2268 02e1 000000   		.align	2
 2269              	.LC18:
 2270 02e4 0A0D4170 		.ascii	"\012\015AppInit:I2CInit Err = 0x%x.\000"
 2270      70496E69 
 2270      743A4932 
 2270      43496E69 
 2270      74204572 
 2271 0302 0000     		.align	2
 2272              	.LC19:
 2273 0304 0A0D4170 		.ascii	"\012\015AppInit:GPIOInit Err = 0x%x\000"
 2273      70496E69 
 2273      743A4750 
 2273      494F496E 
 2273      69742045 
 2274 0322 0000     		.align	2
 2275              	.LC20:
 2276 0324 0A0D4170 		.ascii	"\012\015AppInit:PIBInit Err = 0x%x\000"
 2276      70496E69 
 2276      743A5049 
 2276      42496E69 
 2276      74204572 
 2277 0341 000000   		.align	2
 2278              	.LC21:
 2279 0344 0A0D4170 		.ascii	"\012\015AppInit:UsbStart Err = 0x%x\000"
 2279      70496E69 
 2279      743A5573 
 2279      62537461 
 2279      72742045 
 2280 0362 0000     		.align	2
 2281              	.LC22:
 2282 0364 0A0D4170 		.ascii	"\012\015AppInit:Set_SS_Device_Dscr Err = 0x%x\000"
 2282      70496E69 
 2282      743A5365 
 2282      745F5353 
 2282      5F446576 
 2283              		.align	2
 2284              	.LC23:
 2285 038c 0A0D4170 		.ascii	"\012\015AppInit:Set_HS_Device_Dscr Err = 0x%x\000"
 2285      70496E69 
 2285      743A5365 
 2285      745F4853 
 2285      5F446576 
 2286              		.align	2
 2287              	.LC24:
 2288 03b4 0A0D4170 		.ascii	"\012\015AppInit:Set_BOS_Dscr Err = 0x%x\000"
 2288      70496E69 
 2288      743A5365 
 2288      745F424F 
 2288      535F4473 
 2289 03d6 0000     		.align	2
 2290              	.LC25:
 2291 03d8 0A0D4170 		.ascii	"\012\015AppInit:Set_DEVQUAL_Dscr Err = 0x%x\000"
 2291      70496E69 
 2291      743A5365 
 2291      745F4445 
 2291      56515541 
 2292 03fe 0000     		.align	2
 2293              	.LC26:
 2294 0400 0A0D4170 		.ascii	"\012\015AppInit:Set_SS_CFG_Dscr Err = 0x%x\000"
 2294      70496E69 
 2294      743A5365 
 2294      745F5353 
 2294      5F434647 
 2295 0425 000000   		.align	2
 2296              	.LC27:
 2297 0428 0A0D4170 		.ascii	"\012\015AppInit:Set_HS_CFG_Dscr Err = 0x%x\000"
 2297      70496E69 
 2297      743A5365 
 2297      745F4853 
 2297      5F434647 
 2298 044d 000000   		.align	2
 2299              	.LC28:
 2300 0450 0A0D4170 		.ascii	"\012\015AppInit:Set_FS_CFG_Dscr Err = 0x%x\000"
 2300      70496E69 
 2300      743A5365 
 2300      745F4653 
 2300      5F434647 
 2301 0475 000000   		.align	2
 2302              	.LC29:
 2303 0478 0A0D4170 		.ascii	"\012\015AppInit:Set_STRNG_Dscr0 Err = 0x%x\000"
 2303      70496E69 
 2303      743A5365 
 2303      745F5354 
 2303      524E475F 
 2304 049d 000000   		.align	2
 2305              	.LC30:
 2306 04a0 0A0D4170 		.ascii	"\012\015AppInit:Set_STRNG_Dscr1 Err = 0x%x\000"
 2306      70496E69 
 2306      743A5365 
 2306      745F5354 
 2306      524E475F 
 2307 04c5 000000   		.align	2
 2308              	.LC31:
 2309 04c8 0A0D4170 		.ascii	"\012\015AppInit:Set_STRNG_Dscr2 Err = 0x%x\000"
 2309      70496E69 
 2309      743A5365 
 2309      745F5354 
 2309      524E475F 
 2310 04ed 000000   		.align	2
 2311              	.LC32:
 2312 04f0 0A0D4170 		.ascii	"\012\015AppInit:Set_STRNG_Dscr3 Err = 0x%x\000"
 2312      70496E69 
 2312      743A5365 
 2312      745F5354 
 2312      524E475F 
 2313 0515 000000   		.align	2
 2314              	.LC33:
 2315 0518 0A0D4170 		.ascii	"\012\015AppInit:Set_STRNG_Dscr4 Err = 0x%x\000"
 2315      70496E69 
 2315      743A5365 
 2315      745F5354 
 2315      524E475F 
 2316 053d 000000   		.align	2
 2317              	.LC34:
 2318 0540 0A0D4170 		.ascii	"\012\015AppInit:Set_STRNG_Dscr5 Err = 0x%x\000"
 2318      70496E69 
 2318      743A5365 
 2318      745F5354 
 2318      524E475F 
 2319 0565 000000   		.align	2
 2320              	.LC35:
 2321 0568 0A0D4170 		.ascii	"\012\015AppInit:ConnectState Err = 0x%x\000"
 2321      70496E69 
 2321      743A436F 
 2321      6E6E6563 
 2321      74537461 
 2322 058a 0000     		.align	2
 2323              	.LC36:
 2324 058c 0A0D4170 		.ascii	"\012\015AppInit:CyU3PSetEpConfig CtrlEp Err = 0x%x\000"
 2324      70496E69 
 2324      743A4379 
 2324      55335053 
 2324      65744570 
 2325 05b9 000000   		.align	2
 2326              	.LC37:
 2327 05bc 0A0D4170 		.ascii	"\012\015AppInit:CyU3PSetEpConfig BulkEp Err = 0x%x\000"
 2327      70496E69 
 2327      743A4379 
 2327      55335053 
 2327      65744570 
 2328 05e9 000000   		.align	2
 2329              	.LC38:
 2330 05ec 0A0D4170 		.ascii	"\012\015AppInit:DmaMultiChannelCreate Err = 0x%x\000"
 2330      70496E69 
 2330      743A446D 
 2330      614D756C 
 2330      74694368 
 2331 0617 00       		.align	2
 2332              	.LC39:
 2333 0618 0A0D4170 		.ascii	"\012\015AppInit:MultiChannelReset Err = 0x%x\000"
 2333      70496E69 
 2333      743A4D75 
 2333      6C746943 
 2333      68616E6E 
 2334 063f 00       		.align	2
 2335              	.LC40:
 2336 0640 0A0D4170 		.ascii	"\012\015AppInit:MipicsiGpifLoad Err = 0x%x\000"
 2336      70496E69 
 2336      743A4D69 
 2336      70696373 
 2336      69477069 
 2337 0665 000000   		.align	2
 2338              	.LC41:
 2339 0668 0A0D4170 		.ascii	"\012\015AppInit:GpifSMStart Err = 0x%x\000"
 2339      70496E69 
 2339      743A4770 
 2339      6966534D 
 2339      53746172 
 2340 0689 000000   		.align	2
 2341              	.LC42:
 2342 068c 0A0D4170 		.ascii	"\012\015AppInit:MipicsiInit Err = 0x%x\000"
 2342      70496E69 
 2342      743A4D69 
 2342      70696373 
 2342      69496E69 
 2343 06ad 000000   		.align	2
 2344              	.LC43:
 2345 06b0 0A0D4170 		.ascii	"\012\015AppInit:MipicsiSetIntfParams Err = 0x%x\000"
 2345      70496E69 
 2345      743A4D69 
 2345      70696373 
 2345      69536574 
 2346 06da 0000     		.align	2
 2347              	.LC44:
 2348 06dc 0A0D4669 		.ascii	"\012\015Firmware Version: %d.%d.%d.%d\000"
 2348      726D7761 
 2348      72652056 
 2348      65727369 
 2348      6F6E3A20 
 2349              		.section	.text.esUVCUvcApplnInit,"ax",%progbits
 2350              		.align	2
 2351              		.global	esUVCUvcApplnInit
 2353              	esUVCUvcApplnInit:
 2354              	.LFB11:
1485:../CX3RDKOV5640.c **** 
1486:../CX3RDKOV5640.c **** 
1487:../CX3RDKOV5640.c **** /* This function initializes the USB Module, creates event group,
1488:../CX3RDKOV5640.c ****    sets the enumeration descriptors, configures the Endpoints and
1489:../CX3RDKOV5640.c ****    configures the DMA module for the UVC Application */
1490:../CX3RDKOV5640.c ****     void
1491:../CX3RDKOV5640.c **** esUVCUvcApplnInit (void)
1492:../CX3RDKOV5640.c **** {
 2355              		.loc 1 1492 0
 2356              		.cfi_startproc
 2357              		@ args = 0, pretend = 0, frame = 56
 2358              		@ frame_needed = 1, uses_anonymous_args = 0
 2359 0000 00482DE9 		stmfd	sp!, {fp, lr}
 2360              	.LCFI22:
 2361              		.cfi_def_cfa_offset 8
 2362              		.cfi_offset 11, -8
 2363              		.cfi_offset 14, -4
 2364 0004 04B08DE2 		add	fp, sp, #4
 2365              	.LCFI23:
 2366              		.cfi_def_cfa 11, 4
 2367 0008 48D04DE2 		sub	sp, sp, #72
1493:../CX3RDKOV5640.c ****     CyU3PEpConfig_t endPointConfig;
1494:../CX3RDKOV5640.c ****     CyU3PDmaMultiChannelConfig_t dmaCfg;
1495:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 2368              		.loc 1 1495 0
 2369 000c 0030A0E3 		mov	r3, #0
 2370 0010 08300BE5 		str	r3, [fp, #-8]
1496:../CX3RDKOV5640.c **** 
1497:../CX3RDKOV5640.c ****     /* Initialize the I2C interface for Mipi Block Usage and Camera. */
1498:../CX3RDKOV5640.c ****     status = CyU3PMipicsiInitializeI2c (CY_U3P_MIPICSI_I2C_400KHZ);
 2371              		.loc 1 1498 0
 2372 0014 0100A0E3 		mov	r0, #1
 2373 0018 FEFFFFEB 		bl	CyU3PMipicsiInitializeI2c
 2374 001c 08000BE5 		str	r0, [fp, #-8]
1499:../CX3RDKOV5640.c ****     if( status != CY_U3P_SUCCESS)
 2375              		.loc 1 1499 0
 2376 0020 08301BE5 		ldr	r3, [fp, #-8]
 2377 0024 000053E3 		cmp	r3, #0
 2378 0028 0500000A 		beq	.L135
1500:../CX3RDKOV5640.c ****     {
1501:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:I2CInit Err = 0x%x.",status);
 2379              		.loc 1 1501 0
 2380 002c 0400A0E3 		mov	r0, #4
 2381 0030 70179FE5 		ldr	r1, .L166
 2382 0034 08201BE5 		ldr	r2, [fp, #-8]
 2383 0038 FEFFFFEB 		bl	CyU3PDebugPrint
1502:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2384              		.loc 1 1502 0
 2385 003c 08001BE5 		ldr	r0, [fp, #-8]
 2386 0040 FEFFFFEB 		bl	esUVCAppErrorHandler
 2387              	.L135:
1503:../CX3RDKOV5640.c ****     }
1504:../CX3RDKOV5640.c **** #ifdef VISDebug
1505:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:I2CInit");
1506:../CX3RDKOV5640.c **** #endif
1507:../CX3RDKOV5640.c ****     /* Initialize GPIO module. */
1508:../CX3RDKOV5640.c ****     status = CyU3PMipicsiInitializeGPIO ();
 2388              		.loc 1 1508 0
 2389 0044 FEFFFFEB 		bl	CyU3PMipicsiInitializeGPIO
 2390 0048 08000BE5 		str	r0, [fp, #-8]
1509:../CX3RDKOV5640.c ****     if( status != CY_U3P_SUCCESS)
 2391              		.loc 1 1509 0
 2392 004c 08301BE5 		ldr	r3, [fp, #-8]
 2393 0050 000053E3 		cmp	r3, #0
 2394 0054 0500000A 		beq	.L136
1510:../CX3RDKOV5640.c ****     {
1511:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:GPIOInit Err = 0x%x",status);
 2395              		.loc 1 1511 0
 2396 0058 0400A0E3 		mov	r0, #4
 2397 005c 48179FE5 		ldr	r1, .L166+4
 2398 0060 08201BE5 		ldr	r2, [fp, #-8]
 2399 0064 FEFFFFEB 		bl	CyU3PDebugPrint
1512:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2400              		.loc 1 1512 0
 2401 0068 08001BE5 		ldr	r0, [fp, #-8]
 2402 006c FEFFFFEB 		bl	esUVCAppErrorHandler
 2403              	.L136:
1513:../CX3RDKOV5640.c ****     }
1514:../CX3RDKOV5640.c **** #ifdef VISDebug
1515:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:GPIOInit");
1516:../CX3RDKOV5640.c **** #endif
1517:../CX3RDKOV5640.c ****     /* Initialize the PIB block */
1518:../CX3RDKOV5640.c ****     status = CyU3PMipicsiInitializePIB ();
 2404              		.loc 1 1518 0
 2405 0070 FEFFFFEB 		bl	CyU3PMipicsiInitializePIB
 2406 0074 08000BE5 		str	r0, [fp, #-8]
1519:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2407              		.loc 1 1519 0
 2408 0078 08301BE5 		ldr	r3, [fp, #-8]
 2409 007c 000053E3 		cmp	r3, #0
 2410 0080 0500000A 		beq	.L137
1520:../CX3RDKOV5640.c ****     {
1521:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:PIBInit Err = 0x%x",status);
 2411              		.loc 1 1521 0
 2412 0084 0400A0E3 		mov	r0, #4
 2413 0088 20179FE5 		ldr	r1, .L166+8
 2414 008c 08201BE5 		ldr	r2, [fp, #-8]
 2415 0090 FEFFFFEB 		bl	CyU3PDebugPrint
1522:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2416              		.loc 1 1522 0
 2417 0094 08001BE5 		ldr	r0, [fp, #-8]
 2418 0098 FEFFFFEB 		bl	esUVCAppErrorHandler
 2419              	.L137:
1523:../CX3RDKOV5640.c ****     }
1524:../CX3RDKOV5640.c **** #ifdef VISDebug
1525:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:PIBInit");
1526:../CX3RDKOV5640.c **** #endif
1527:../CX3RDKOV5640.c ****     /* Start the USB functionality */
1528:../CX3RDKOV5640.c ****     status = CyU3PUsbStart();
 2420              		.loc 1 1528 0
 2421 009c FEFFFFEB 		bl	CyU3PUsbStart
 2422 00a0 08000BE5 		str	r0, [fp, #-8]
1529:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2423              		.loc 1 1529 0
 2424 00a4 08301BE5 		ldr	r3, [fp, #-8]
 2425 00a8 000053E3 		cmp	r3, #0
 2426 00ac 0500000A 		beq	.L138
1530:../CX3RDKOV5640.c ****     {
1531:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:UsbStart Err = 0x%x",status);
 2427              		.loc 1 1531 0
 2428 00b0 0400A0E3 		mov	r0, #4
 2429 00b4 F8169FE5 		ldr	r1, .L166+12
 2430 00b8 08201BE5 		ldr	r2, [fp, #-8]
 2431 00bc FEFFFFEB 		bl	CyU3PDebugPrint
1532:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2432              		.loc 1 1532 0
 2433 00c0 08001BE5 		ldr	r0, [fp, #-8]
 2434 00c4 FEFFFFEB 		bl	esUVCAppErrorHandler
 2435              	.L138:
1533:../CX3RDKOV5640.c ****     }
1534:../CX3RDKOV5640.c **** #ifdef VISDebug
1535:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:UsbStart");
1536:../CX3RDKOV5640.c **** #endif
1537:../CX3RDKOV5640.c ****     /* The fast enumeration is the easiest way to setup a USB connection,
1538:../CX3RDKOV5640.c ****      * where all enumeration phase is handled by the library. Only the
1539:../CX3RDKOV5640.c ****      * class / vendor requests need to be handled by the application. */
1540:../CX3RDKOV5640.c ****     CyU3PUsbRegisterSetupCallback(esUVCUvcApplnUSBSetupCB, CyTrue);
 2436              		.loc 1 1540 0
 2437 00c8 E8069FE5 		ldr	r0, .L166+16
 2438 00cc 0110A0E3 		mov	r1, #1
 2439 00d0 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
1541:../CX3RDKOV5640.c **** 
1542:../CX3RDKOV5640.c ****     /* Setup the callback to handle the USB events */
1543:../CX3RDKOV5640.c ****     CyU3PUsbRegisterEventCallback(esUVCUvcApplnUSBEventCB);
 2440              		.loc 1 1543 0
 2441 00d4 E0069FE5 		ldr	r0, .L166+20
 2442 00d8 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
1544:../CX3RDKOV5640.c **** 
1545:../CX3RDKOV5640.c ****     /* Register a callback to handle LPM requests from the USB 3.0 host. */
1546:../CX3RDKOV5640.c ****     CyU3PUsbRegisterLPMRequestCallback (esUVCApplnLPMRqtCB);
 2443              		.loc 1 1546 0
 2444 00dc DC069FE5 		ldr	r0, .L166+24
 2445 00e0 FEFFFFEB 		bl	CyU3PUsbRegisterLPMRequestCallback
1547:../CX3RDKOV5640.c **** 
1548:../CX3RDKOV5640.c ****     /* Set the USB Enumeration descriptors */
1549:../CX3RDKOV5640.c **** 
1550:../CX3RDKOV5640.c ****     /* Super speed device descriptor. */
1551:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_DEVICE_DESCR, 0, (uint8_t *)esUVCUSB30DeviceDscr);
 2446              		.loc 1 1551 0
 2447 00e4 0000A0E3 		mov	r0, #0
 2448 00e8 0010A0E3 		mov	r1, #0
 2449 00ec D0269FE5 		ldr	r2, .L166+28
 2450 00f0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2451 00f4 08000BE5 		str	r0, [fp, #-8]
1552:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2452              		.loc 1 1552 0
 2453 00f8 08301BE5 		ldr	r3, [fp, #-8]
 2454 00fc 000053E3 		cmp	r3, #0
 2455 0100 0500000A 		beq	.L139
1553:../CX3RDKOV5640.c ****     {
1554:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_SS_Device_Dscr Err = 0x%x", status);
 2456              		.loc 1 1554 0
 2457 0104 0400A0E3 		mov	r0, #4
 2458 0108 B8169FE5 		ldr	r1, .L166+32
 2459 010c 08201BE5 		ldr	r2, [fp, #-8]
 2460 0110 FEFFFFEB 		bl	CyU3PDebugPrint
1555:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2461              		.loc 1 1555 0
 2462 0114 08001BE5 		ldr	r0, [fp, #-8]
 2463 0118 FEFFFFEB 		bl	esUVCAppErrorHandler
 2464              	.L139:
1556:../CX3RDKOV5640.c ****     }
1557:../CX3RDKOV5640.c **** #ifdef VISDebug
1558:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_SS_Device_Dscr");
1559:../CX3RDKOV5640.c **** #endif
1560:../CX3RDKOV5640.c ****     /* High speed device descriptor. */
1561:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_HS_DEVICE_DESCR, 0, (uint8_t *)esUVCUSB20DeviceDscr);
 2465              		.loc 1 1561 0
 2466 011c 0100A0E3 		mov	r0, #1
 2467 0120 0010A0E3 		mov	r1, #0
 2468 0124 A0269FE5 		ldr	r2, .L166+36
 2469 0128 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2470 012c 08000BE5 		str	r0, [fp, #-8]
1562:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2471              		.loc 1 1562 0
 2472 0130 08301BE5 		ldr	r3, [fp, #-8]
 2473 0134 000053E3 		cmp	r3, #0
 2474 0138 0500000A 		beq	.L140
1563:../CX3RDKOV5640.c ****     {
1564:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_HS_Device_Dscr Err = 0x%x", status);
 2475              		.loc 1 1564 0
 2476 013c 0400A0E3 		mov	r0, #4
 2477 0140 88169FE5 		ldr	r1, .L166+40
 2478 0144 08201BE5 		ldr	r2, [fp, #-8]
 2479 0148 FEFFFFEB 		bl	CyU3PDebugPrint
1565:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2480              		.loc 1 1565 0
 2481 014c 08001BE5 		ldr	r0, [fp, #-8]
 2482 0150 FEFFFFEB 		bl	esUVCAppErrorHandler
 2483              	.L140:
1566:../CX3RDKOV5640.c ****     }
1567:../CX3RDKOV5640.c **** #ifdef VISDebug
1568:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_HS_Device_Dscr");
1569:../CX3RDKOV5640.c **** #endif
1570:../CX3RDKOV5640.c ****     /* BOS descriptor */
1571:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_BOS_DESCR, 0, (uint8_t *)esUVCUSBBOSDscr);
 2484              		.loc 1 1571 0
 2485 0154 0700A0E3 		mov	r0, #7
 2486 0158 0010A0E3 		mov	r1, #0
 2487 015c 70269FE5 		ldr	r2, .L166+44
 2488 0160 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2489 0164 08000BE5 		str	r0, [fp, #-8]
1572:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2490              		.loc 1 1572 0
 2491 0168 08301BE5 		ldr	r3, [fp, #-8]
 2492 016c 000053E3 		cmp	r3, #0
 2493 0170 0500000A 		beq	.L141
1573:../CX3RDKOV5640.c ****     {
1574:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_BOS_Dscr Err = 0x%x", status);
 2494              		.loc 1 1574 0
 2495 0174 0400A0E3 		mov	r0, #4
 2496 0178 58169FE5 		ldr	r1, .L166+48
 2497 017c 08201BE5 		ldr	r2, [fp, #-8]
 2498 0180 FEFFFFEB 		bl	CyU3PDebugPrint
1575:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2499              		.loc 1 1575 0
 2500 0184 08001BE5 		ldr	r0, [fp, #-8]
 2501 0188 FEFFFFEB 		bl	esUVCAppErrorHandler
 2502              	.L141:
1576:../CX3RDKOV5640.c ****     }
1577:../CX3RDKOV5640.c **** #ifdef VISDebug
1578:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_BOS_Dscr");
1579:../CX3RDKOV5640.c **** #endif
1580:../CX3RDKOV5640.c ****     /* Device qualifier descriptor */
1581:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_DEVQUAL_DESCR, 0, (uint8_t *)esUVCUSBDeviceQualDscr);
 2503              		.loc 1 1581 0
 2504 018c 0200A0E3 		mov	r0, #2
 2505 0190 0010A0E3 		mov	r1, #0
 2506 0194 40269FE5 		ldr	r2, .L166+52
 2507 0198 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2508 019c 08000BE5 		str	r0, [fp, #-8]
1582:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2509              		.loc 1 1582 0
 2510 01a0 08301BE5 		ldr	r3, [fp, #-8]
 2511 01a4 000053E3 		cmp	r3, #0
 2512 01a8 0500000A 		beq	.L142
1583:../CX3RDKOV5640.c ****     {
1584:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_DEVQUAL_Dscr Err = 0x%x", status);
 2513              		.loc 1 1584 0
 2514 01ac 0400A0E3 		mov	r0, #4
 2515 01b0 28169FE5 		ldr	r1, .L166+56
 2516 01b4 08201BE5 		ldr	r2, [fp, #-8]
 2517 01b8 FEFFFFEB 		bl	CyU3PDebugPrint
1585:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2518              		.loc 1 1585 0
 2519 01bc 08001BE5 		ldr	r0, [fp, #-8]
 2520 01c0 FEFFFFEB 		bl	esUVCAppErrorHandler
 2521              	.L142:
1586:../CX3RDKOV5640.c ****     }
1587:../CX3RDKOV5640.c **** #ifdef VISDebug
1588:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_DEVQUAL_Dscr");
1589:../CX3RDKOV5640.c **** #endif
1590:../CX3RDKOV5640.c ****     /* Super speed configuration descriptor */
1591:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_CONFIG_DESCR, 0, (uint8_t *)esUVCUSBSSConfigDscr);
 2522              		.loc 1 1591 0
 2523 01c4 0600A0E3 		mov	r0, #6
 2524 01c8 0010A0E3 		mov	r1, #0
 2525 01cc 10269FE5 		ldr	r2, .L166+60
 2526 01d0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2527 01d4 08000BE5 		str	r0, [fp, #-8]
1592:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2528              		.loc 1 1592 0
 2529 01d8 08301BE5 		ldr	r3, [fp, #-8]
 2530 01dc 000053E3 		cmp	r3, #0
 2531 01e0 0500000A 		beq	.L143
1593:../CX3RDKOV5640.c ****     {
1594:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_SS_CFG_Dscr Err = 0x%x", status);
 2532              		.loc 1 1594 0
 2533 01e4 0400A0E3 		mov	r0, #4
 2534 01e8 F8159FE5 		ldr	r1, .L166+64
 2535 01ec 08201BE5 		ldr	r2, [fp, #-8]
 2536 01f0 FEFFFFEB 		bl	CyU3PDebugPrint
1595:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2537              		.loc 1 1595 0
 2538 01f4 08001BE5 		ldr	r0, [fp, #-8]
 2539 01f8 FEFFFFEB 		bl	esUVCAppErrorHandler
 2540              	.L143:
1596:../CX3RDKOV5640.c ****     }
1597:../CX3RDKOV5640.c **** #ifdef VISDebug
1598:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_SS_CFG_Dscr");
1599:../CX3RDKOV5640.c **** #endif
1600:../CX3RDKOV5640.c ****     /* High speed configuration descriptor */
1601:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_HS_CONFIG_DESCR, 0, (uint8_t *)esUVCUSBHSConfigDscr);
 2541              		.loc 1 1601 0
 2542 01fc 0400A0E3 		mov	r0, #4
 2543 0200 0010A0E3 		mov	r1, #0
 2544 0204 E0259FE5 		ldr	r2, .L166+68
 2545 0208 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2546 020c 08000BE5 		str	r0, [fp, #-8]
1602:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2547              		.loc 1 1602 0
 2548 0210 08301BE5 		ldr	r3, [fp, #-8]
 2549 0214 000053E3 		cmp	r3, #0
 2550 0218 0500000A 		beq	.L144
1603:../CX3RDKOV5640.c ****     {
1604:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_HS_CFG_Dscr Err = 0x%x", status);
 2551              		.loc 1 1604 0
 2552 021c 0400A0E3 		mov	r0, #4
 2553 0220 C8159FE5 		ldr	r1, .L166+72
 2554 0224 08201BE5 		ldr	r2, [fp, #-8]
 2555 0228 FEFFFFEB 		bl	CyU3PDebugPrint
1605:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2556              		.loc 1 1605 0
 2557 022c 08001BE5 		ldr	r0, [fp, #-8]
 2558 0230 FEFFFFEB 		bl	esUVCAppErrorHandler
 2559              	.L144:
1606:../CX3RDKOV5640.c ****     }
1607:../CX3RDKOV5640.c **** #ifdef VISDebug
1608:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_HS_CFG_Dscr");
1609:../CX3RDKOV5640.c **** #endif
1610:../CX3RDKOV5640.c ****     /* Full speed configuration descriptor */
1611:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_FS_CONFIG_DESCR, 0, (uint8_t *)esUVCUSBFSConfigDscr);
 2560              		.loc 1 1611 0
 2561 0234 0300A0E3 		mov	r0, #3
 2562 0238 0010A0E3 		mov	r1, #0
 2563 023c B0259FE5 		ldr	r2, .L166+76
 2564 0240 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2565 0244 08000BE5 		str	r0, [fp, #-8]
1612:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2566              		.loc 1 1612 0
 2567 0248 08301BE5 		ldr	r3, [fp, #-8]
 2568 024c 000053E3 		cmp	r3, #0
 2569 0250 0500000A 		beq	.L145
1613:../CX3RDKOV5640.c ****     {
1614:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_FS_CFG_Dscr Err = 0x%x", status);
 2570              		.loc 1 1614 0
 2571 0254 0400A0E3 		mov	r0, #4
 2572 0258 98159FE5 		ldr	r1, .L166+80
 2573 025c 08201BE5 		ldr	r2, [fp, #-8]
 2574 0260 FEFFFFEB 		bl	CyU3PDebugPrint
1615:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2575              		.loc 1 1615 0
 2576 0264 08001BE5 		ldr	r0, [fp, #-8]
 2577 0268 FEFFFFEB 		bl	esUVCAppErrorHandler
 2578              	.L145:
1616:../CX3RDKOV5640.c ****     }
1617:../CX3RDKOV5640.c **** #ifdef VISDebug
1618:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:Set_FS_CFG_Dscr");
1619:../CX3RDKOV5640.c **** #endif
1620:../CX3RDKOV5640.c ****     /* String descriptor 0 */
1621:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)esUVCUSBStringLangIDDscr);
 2579              		.loc 1 1621 0
 2580 026c 0500A0E3 		mov	r0, #5
 2581 0270 0010A0E3 		mov	r1, #0
 2582 0274 80259FE5 		ldr	r2, .L166+84
 2583 0278 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2584 027c 08000BE5 		str	r0, [fp, #-8]
1622:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2585              		.loc 1 1622 0
 2586 0280 08301BE5 		ldr	r3, [fp, #-8]
 2587 0284 000053E3 		cmp	r3, #0
 2588 0288 0500000A 		beq	.L146
1623:../CX3RDKOV5640.c ****     {
1624:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_STRNG_Dscr0 Err = 0x%x", status);
 2589              		.loc 1 1624 0
 2590 028c 0400A0E3 		mov	r0, #4
 2591 0290 68159FE5 		ldr	r1, .L166+88
 2592 0294 08201BE5 		ldr	r2, [fp, #-8]
 2593 0298 FEFFFFEB 		bl	CyU3PDebugPrint
1625:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2594              		.loc 1 1625 0
 2595 029c 08001BE5 		ldr	r0, [fp, #-8]
 2596 02a0 FEFFFFEB 		bl	esUVCAppErrorHandler
 2597              	.L146:
1626:../CX3RDKOV5640.c ****     }
1627:../CX3RDKOV5640.c **** 
1628:../CX3RDKOV5640.c ****     /* String descriptor 1 */
1629:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)esUVCUSBManufactureDscr);
 2598              		.loc 1 1629 0
 2599 02a4 0500A0E3 		mov	r0, #5
 2600 02a8 0110A0E3 		mov	r1, #1
 2601 02ac 50259FE5 		ldr	r2, .L166+92
 2602 02b0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2603 02b4 08000BE5 		str	r0, [fp, #-8]
1630:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2604              		.loc 1 1630 0
 2605 02b8 08301BE5 		ldr	r3, [fp, #-8]
 2606 02bc 000053E3 		cmp	r3, #0
 2607 02c0 0500000A 		beq	.L147
1631:../CX3RDKOV5640.c ****     {
1632:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_STRNG_Dscr1 Err = 0x%x", status);
 2608              		.loc 1 1632 0
 2609 02c4 0400A0E3 		mov	r0, #4
 2610 02c8 38159FE5 		ldr	r1, .L166+96
 2611 02cc 08201BE5 		ldr	r2, [fp, #-8]
 2612 02d0 FEFFFFEB 		bl	CyU3PDebugPrint
1633:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2613              		.loc 1 1633 0
 2614 02d4 08001BE5 		ldr	r0, [fp, #-8]
 2615 02d8 FEFFFFEB 		bl	esUVCAppErrorHandler
 2616              	.L147:
1634:../CX3RDKOV5640.c ****     }
1635:../CX3RDKOV5640.c **** 
1636:../CX3RDKOV5640.c ****     /* String descriptor 2 */
1637:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)esUVCUSBProductDscr);
 2617              		.loc 1 1637 0
 2618 02dc 0500A0E3 		mov	r0, #5
 2619 02e0 0210A0E3 		mov	r1, #2
 2620 02e4 20259FE5 		ldr	r2, .L166+100
 2621 02e8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2622 02ec 08000BE5 		str	r0, [fp, #-8]
1638:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2623              		.loc 1 1638 0
 2624 02f0 08301BE5 		ldr	r3, [fp, #-8]
 2625 02f4 000053E3 		cmp	r3, #0
 2626 02f8 0500000A 		beq	.L148
1639:../CX3RDKOV5640.c ****     {
1640:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_STRNG_Dscr2 Err = 0x%x", status);
 2627              		.loc 1 1640 0
 2628 02fc 0400A0E3 		mov	r0, #4
 2629 0300 08159FE5 		ldr	r1, .L166+104
 2630 0304 08201BE5 		ldr	r2, [fp, #-8]
 2631 0308 FEFFFFEB 		bl	CyU3PDebugPrint
1641:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2632              		.loc 1 1641 0
 2633 030c 08001BE5 		ldr	r0, [fp, #-8]
 2634 0310 FEFFFFEB 		bl	esUVCAppErrorHandler
 2635              	.L148:
1642:../CX3RDKOV5640.c ****     }
1643:../CX3RDKOV5640.c ****     /* String descriptor 3 */
1644:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 3, (uint8_t *)esUVCUSBConfigSSDscr);
 2636              		.loc 1 1644 0
 2637 0314 0500A0E3 		mov	r0, #5
 2638 0318 0310A0E3 		mov	r1, #3
 2639 031c F0249FE5 		ldr	r2, .L166+108
 2640 0320 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2641 0324 08000BE5 		str	r0, [fp, #-8]
1645:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2642              		.loc 1 1645 0
 2643 0328 08301BE5 		ldr	r3, [fp, #-8]
 2644 032c 000053E3 		cmp	r3, #0
 2645 0330 0500000A 		beq	.L149
1646:../CX3RDKOV5640.c ****     {
1647:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_STRNG_Dscr3 Err = 0x%x", status);
 2646              		.loc 1 1647 0
 2647 0334 0400A0E3 		mov	r0, #4
 2648 0338 D8149FE5 		ldr	r1, .L166+112
 2649 033c 08201BE5 		ldr	r2, [fp, #-8]
 2650 0340 FEFFFFEB 		bl	CyU3PDebugPrint
1648:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2651              		.loc 1 1648 0
 2652 0344 08001BE5 		ldr	r0, [fp, #-8]
 2653 0348 FEFFFFEB 		bl	esUVCAppErrorHandler
 2654              	.L149:
1649:../CX3RDKOV5640.c ****     }
1650:../CX3RDKOV5640.c **** 
1651:../CX3RDKOV5640.c ****     /* String descriptor 4 */
1652:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 4, (uint8_t *)esUVCUSBConfigHSDscr);
 2655              		.loc 1 1652 0
 2656 034c 0500A0E3 		mov	r0, #5
 2657 0350 0410A0E3 		mov	r1, #4
 2658 0354 C0249FE5 		ldr	r2, .L166+116
 2659 0358 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2660 035c 08000BE5 		str	r0, [fp, #-8]
1653:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2661              		.loc 1 1653 0
 2662 0360 08301BE5 		ldr	r3, [fp, #-8]
 2663 0364 000053E3 		cmp	r3, #0
 2664 0368 0500000A 		beq	.L150
1654:../CX3RDKOV5640.c ****     {
1655:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_STRNG_Dscr4 Err = 0x%x", status);
 2665              		.loc 1 1655 0
 2666 036c 0400A0E3 		mov	r0, #4
 2667 0370 A8149FE5 		ldr	r1, .L166+120
 2668 0374 08201BE5 		ldr	r2, [fp, #-8]
 2669 0378 FEFFFFEB 		bl	CyU3PDebugPrint
1656:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2670              		.loc 1 1656 0
 2671 037c 08001BE5 		ldr	r0, [fp, #-8]
 2672 0380 FEFFFFEB 		bl	esUVCAppErrorHandler
 2673              	.L150:
1657:../CX3RDKOV5640.c ****     }
1658:../CX3RDKOV5640.c ****     /* String descriptor 2 */
1659:../CX3RDKOV5640.c ****     status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 5, (uint8_t *)esUVCUSBConfigFSDscr);
 2674              		.loc 1 1659 0
 2675 0384 0500A0E3 		mov	r0, #5
 2676 0388 0510A0E3 		mov	r1, #5
 2677 038c 90249FE5 		ldr	r2, .L166+124
 2678 0390 FEFFFFEB 		bl	CyU3PUsbSetDesc
 2679 0394 08000BE5 		str	r0, [fp, #-8]
1660:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2680              		.loc 1 1660 0
 2681 0398 08301BE5 		ldr	r3, [fp, #-8]
 2682 039c 000053E3 		cmp	r3, #0
 2683 03a0 0500000A 		beq	.L151
1661:../CX3RDKOV5640.c ****     {
1662:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:Set_STRNG_Dscr5 Err = 0x%x", status);
 2684              		.loc 1 1662 0
 2685 03a4 0400A0E3 		mov	r0, #4
 2686 03a8 78149FE5 		ldr	r1, .L166+128
 2687 03ac 08201BE5 		ldr	r2, [fp, #-8]
 2688 03b0 FEFFFFEB 		bl	CyU3PDebugPrint
1663:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2689              		.loc 1 1663 0
 2690 03b4 08001BE5 		ldr	r0, [fp, #-8]
 2691 03b8 FEFFFFEB 		bl	esUVCAppErrorHandler
 2692              	.L151:
1664:../CX3RDKOV5640.c ****     }
1665:../CX3RDKOV5640.c **** 
1666:../CX3RDKOV5640.c ****     CyU3PUsbVBattEnable (CyTrue);
 2693              		.loc 1 1666 0
 2694 03bc 0100A0E3 		mov	r0, #1
 2695 03c0 FEFFFFEB 		bl	CyU3PUsbVBattEnable
1667:../CX3RDKOV5640.c ****     CyU3PUsbControlVBusDetect (CyFalse, CyTrue);
 2696              		.loc 1 1667 0
 2697 03c4 0000A0E3 		mov	r0, #0
 2698 03c8 0110A0E3 		mov	r1, #1
 2699 03cc FEFFFFEB 		bl	CyU3PUsbControlVBusDetect
1668:../CX3RDKOV5640.c **** 
1669:../CX3RDKOV5640.c ****     //TODO Change this function with the "Sensor specific" function to Write the Base I2C settings 
1670:../CX3RDKOV5640.c ****     /* Setup Image Sensor */
1671:../CX3RDKOV5640.c **** 	//esOV5640_Base_Config();
1672:../CX3RDKOV5640.c **** 	 //TODO Change this function with the "Sensor specific" function to Write the Base I2C settings fo
1673:../CX3RDKOV5640.c **** 	//esOV5640_Auto_Focus_Config();
1674:../CX3RDKOV5640.c **** 	//TODO Change this function with "Sensor Specific" PowerDown function to PowerDown the sensor
1675:../CX3RDKOV5640.c **** 	//esCamera_Power_Down();
1676:../CX3RDKOV5640.c **** 
1677:../CX3RDKOV5640.c ****     /* Connect the USB pins and enable super speed operation */
1678:../CX3RDKOV5640.c ****     status = CyU3PConnectState(CyTrue, CyTrue);
 2700              		.loc 1 1678 0
 2701 03d0 0100A0E3 		mov	r0, #1
 2702 03d4 0110A0E3 		mov	r1, #1
 2703 03d8 FEFFFFEB 		bl	CyU3PConnectState
 2704 03dc 08000BE5 		str	r0, [fp, #-8]
1679:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2705              		.loc 1 1679 0
 2706 03e0 08301BE5 		ldr	r3, [fp, #-8]
 2707 03e4 000053E3 		cmp	r3, #0
 2708 03e8 0500000A 		beq	.L152
1680:../CX3RDKOV5640.c ****     {
1681:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:ConnectState Err = 0x%x", status);
 2709              		.loc 1 1681 0
 2710 03ec 0400A0E3 		mov	r0, #4
 2711 03f0 34149FE5 		ldr	r1, .L166+132
 2712 03f4 08201BE5 		ldr	r2, [fp, #-8]
 2713 03f8 FEFFFFEB 		bl	CyU3PDebugPrint
1682:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2714              		.loc 1 1682 0
 2715 03fc 08001BE5 		ldr	r0, [fp, #-8]
 2716 0400 FEFFFFEB 		bl	esUVCAppErrorHandler
 2717              	.L152:
1683:../CX3RDKOV5640.c ****     }
1684:../CX3RDKOV5640.c **** #ifdef VISDebug
1685:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "n\rAppInit:ConnectState");
1686:../CX3RDKOV5640.c **** #endif
1687:../CX3RDKOV5640.c ****     /* Since the status interrupt endpoint is not used in this application,
1688:../CX3RDKOV5640.c ****      * just enable the EP in the beginning. */
1689:../CX3RDKOV5640.c ****     /* Control status interrupt endpoint configuration */
1690:../CX3RDKOV5640.c ****     endPointConfig.enable = 1;
 2718              		.loc 1 1690 0
 2719 0404 0130A0E3 		mov	r3, #1
 2720 0408 14300BE5 		str	r3, [fp, #-20]
1691:../CX3RDKOV5640.c ****     endPointConfig.epType = CY_U3P_USB_EP_INTR;
 2721              		.loc 1 1691 0
 2722 040c 0330A0E3 		mov	r3, #3
 2723 0410 10304BE5 		strb	r3, [fp, #-16]
1692:../CX3RDKOV5640.c ****     endPointConfig.pcktSize = 64;
 2724              		.loc 1 1692 0
 2725 0414 4030A0E3 		mov	r3, #64
 2726 0418 BC304BE1 		strh	r3, [fp, #-12]	@ movhi
1693:../CX3RDKOV5640.c ****     endPointConfig.isoPkts  = 1;
 2727              		.loc 1 1693 0
 2728 041c 0130A0E3 		mov	r3, #1
 2729 0420 09304BE5 		strb	r3, [fp, #-9]
1694:../CX3RDKOV5640.c ****     endPointConfig.burstLen = 1;
 2730              		.loc 1 1694 0
 2731 0424 0130A0E3 		mov	r3, #1
 2732 0428 0A304BE5 		strb	r3, [fp, #-10]
1695:../CX3RDKOV5640.c **** 
1696:../CX3RDKOV5640.c ****     status = CyU3PSetEpConfig(ES_UVC_EP_CONTROL_STATUS, &endPointConfig);
 2733              		.loc 1 1696 0
 2734 042c 14304BE2 		sub	r3, fp, #20
 2735 0430 8200A0E3 		mov	r0, #130
 2736 0434 0310A0E1 		mov	r1, r3
 2737 0438 FEFFFFEB 		bl	CyU3PSetEpConfig
 2738 043c 08000BE5 		str	r0, [fp, #-8]
1697:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2739              		.loc 1 1697 0
 2740 0440 08301BE5 		ldr	r3, [fp, #-8]
 2741 0444 000053E3 		cmp	r3, #0
 2742 0448 0500000A 		beq	.L153
1698:../CX3RDKOV5640.c ****     {
1699:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:CyU3PSetEpConfig CtrlEp Err = 0x%x", status);
 2743              		.loc 1 1699 0
 2744 044c 0400A0E3 		mov	r0, #4
 2745 0450 D8139FE5 		ldr	r1, .L166+136
 2746 0454 08201BE5 		ldr	r2, [fp, #-8]
 2747 0458 FEFFFFEB 		bl	CyU3PDebugPrint
1700:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2748              		.loc 1 1700 0
 2749 045c 08001BE5 		ldr	r0, [fp, #-8]
 2750 0460 FEFFFFEB 		bl	esUVCAppErrorHandler
 2751              	.L153:
1701:../CX3RDKOV5640.c ****     }
1702:../CX3RDKOV5640.c **** 
1703:../CX3RDKOV5640.c ****     CyU3PUsbFlushEp(ES_UVC_EP_CONTROL_STATUS);
 2752              		.loc 1 1703 0
 2753 0464 8200A0E3 		mov	r0, #130
 2754 0468 FEFFFFEB 		bl	CyU3PUsbFlushEp
1704:../CX3RDKOV5640.c **** 
1705:../CX3RDKOV5640.c ****     /* Setup the Bulk endpoint used for Video Streaming */
1706:../CX3RDKOV5640.c ****     endPointConfig.enable = CyTrue;
 2755              		.loc 1 1706 0
 2756 046c 0130A0E3 		mov	r3, #1
 2757 0470 14300BE5 		str	r3, [fp, #-20]
1707:../CX3RDKOV5640.c ****     endPointConfig.epType = CY_U3P_USB_EP_BULK;
 2758              		.loc 1 1707 0
 2759 0474 0230A0E3 		mov	r3, #2
 2760 0478 10304BE5 		strb	r3, [fp, #-16]
1708:../CX3RDKOV5640.c **** 
1709:../CX3RDKOV5640.c ****     endPointConfig.isoPkts  = 0;
 2761              		.loc 1 1709 0
 2762 047c 0030A0E3 		mov	r3, #0
 2763 0480 09304BE5 		strb	r3, [fp, #-9]
1710:../CX3RDKOV5640.c ****     endPointConfig.streams = 0;
 2764              		.loc 1 1710 0
 2765 0484 0030A0E3 		mov	r3, #0
 2766 0488 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
1711:../CX3RDKOV5640.c **** 
1712:../CX3RDKOV5640.c ****     CyU3PThreadSleep(1000);
 2767              		.loc 1 1712 0
 2768 048c FA0FA0E3 		mov	r0, #1000
 2769 0490 FEFFFFEB 		bl	_tx_thread_sleep
1713:../CX3RDKOV5640.c **** 
1714:../CX3RDKOV5640.c ****     switch(CyU3PUsbGetSpeed())
 2770              		.loc 1 1714 0
 2771 0494 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 2772 0498 0030A0E1 		mov	r3, r0
 2773 049c 010053E3 		cmp	r3, #1
 2774 04a0 0F00000A 		beq	.L155
 2775 04a4 020053E3 		cmp	r3, #2
 2776 04a8 1200001A 		bne	.L165
1715:../CX3RDKOV5640.c ****     {
1716:../CX3RDKOV5640.c ****         case CY_U3P_HIGH_SPEED:
1717:../CX3RDKOV5640.c ****             endPointConfig.pcktSize = 0x200;
 2777              		.loc 1 1717 0
 2778 04ac 023CA0E3 		mov	r3, #512
 2779 04b0 BC304BE1 		strh	r3, [fp, #-12]	@ movhi
1718:../CX3RDKOV5640.c ****             endPointConfig.burstLen = 1;
 2780              		.loc 1 1718 0
 2781 04b4 0130A0E3 		mov	r3, #1
 2782 04b8 0A304BE5 		strb	r3, [fp, #-10]
1719:../CX3RDKOV5640.c ****             ES_UVC_STREAM_BUF_SIZE 	= ES_UVC_HS_STREAM_BUF_SIZE;
 2783              		.loc 1 1719 0
 2784 04bc 70339FE5 		ldr	r3, .L166+140
 2785 04c0 032BA0E3 		mov	r2, #3072
 2786 04c4 B020C3E1 		strh	r2, [r3]	@ movhi
1720:../CX3RDKOV5640.c ****             ES_UVC_DATA_BUF_SIZE 	= ES_UVC_HS_DATA_BUF_SIZE;
 2787              		.loc 1 1720 0
 2788 04c8 68339FE5 		ldr	r3, .L166+144
 2789 04cc BF2EA0E3 		mov	r2, #3056
 2790 04d0 B020C3E1 		strh	r2, [r3]	@ movhi
1721:../CX3RDKOV5640.c ****             ES_UVC_STREAM_BUF_COUNT	= ES_UVC_HS_STREAM_BUF_COUNT;
 2791              		.loc 1 1721 0
 2792 04d4 60339FE5 		ldr	r3, .L166+148
 2793 04d8 0820A0E3 		mov	r2, #8
 2794 04dc 0020C3E5 		strb	r2, [r3]
1722:../CX3RDKOV5640.c ****             break;
 2795              		.loc 1 1722 0
 2796 04e0 120000EA 		b	.L157
 2797              	.L155:
1723:../CX3RDKOV5640.c **** 
1724:../CX3RDKOV5640.c ****         case CY_U3P_FULL_SPEED:
1725:../CX3RDKOV5640.c ****             endPointConfig.pcktSize = 0x40;
 2798              		.loc 1 1725 0
 2799 04e4 4030A0E3 		mov	r3, #64
 2800 04e8 BC304BE1 		strh	r3, [fp, #-12]	@ movhi
1726:../CX3RDKOV5640.c ****             endPointConfig.burstLen = 1;
 2801              		.loc 1 1726 0
 2802 04ec 0130A0E3 		mov	r3, #1
 2803 04f0 0A304BE5 		strb	r3, [fp, #-10]
1727:../CX3RDKOV5640.c ****             break;
 2804              		.loc 1 1727 0
 2805 04f4 0D0000EA 		b	.L157
 2806              	.L165:
1728:../CX3RDKOV5640.c **** 
1729:../CX3RDKOV5640.c ****         case CY_U3P_SUPER_SPEED:
1730:../CX3RDKOV5640.c ****         default:
1731:../CX3RDKOV5640.c ****             endPointConfig.pcktSize = ES_UVC_EP_BULK_VIDEO_PKT_SIZE;
 2807              		.loc 1 1731 0
 2808 04f8 013BA0E3 		mov	r3, #1024
 2809 04fc BC304BE1 		strh	r3, [fp, #-12]	@ movhi
1732:../CX3RDKOV5640.c ****             endPointConfig.burstLen = 16;
 2810              		.loc 1 1732 0
 2811 0500 1030A0E3 		mov	r3, #16
 2812 0504 0A304BE5 		strb	r3, [fp, #-10]
1733:../CX3RDKOV5640.c ****             ES_UVC_STREAM_BUF_SIZE 	= ES_UVC_SS_STREAM_BUF_SIZE;
 2813              		.loc 1 1733 0
 2814 0508 24339FE5 		ldr	r3, .L166+140
 2815 050c 062AA0E3 		mov	r2, #24576
 2816 0510 B020C3E1 		strh	r2, [r3]	@ movhi
1734:../CX3RDKOV5640.c ****             ES_UVC_DATA_BUF_SIZE 	= ES_UVC_SS_DATA_BUF_SIZE;
 2817              		.loc 1 1734 0
 2818 0514 1C339FE5 		ldr	r3, .L166+144
 2819 0518 20239FE5 		ldr	r2, .L166+152
 2820 051c B020C3E1 		strh	r2, [r3]	@ movhi
1735:../CX3RDKOV5640.c ****             ES_UVC_STREAM_BUF_COUNT	= ES_UVC_SS_STREAM_BUF_COUNT;
 2821              		.loc 1 1735 0
 2822 0520 14339FE5 		ldr	r3, .L166+148
 2823 0524 0420A0E3 		mov	r2, #4
 2824 0528 0020C3E5 		strb	r2, [r3]
1736:../CX3RDKOV5640.c ****             break;
 2825              		.loc 1 1736 0
 2826 052c 0000A0E1 		mov	r0, r0	@ nop
 2827              	.L157:
1737:../CX3RDKOV5640.c ****     }
1738:../CX3RDKOV5640.c **** 
1739:../CX3RDKOV5640.c ****     status = CyU3PSetEpConfig(ES_UVC_EP_BULK_VIDEO, &endPointConfig);
 2828              		.loc 1 1739 0
 2829 0530 14304BE2 		sub	r3, fp, #20
 2830 0534 8300A0E3 		mov	r0, #131
 2831 0538 0310A0E1 		mov	r1, r3
 2832 053c FEFFFFEB 		bl	CyU3PSetEpConfig
 2833 0540 08000BE5 		str	r0, [fp, #-8]
1740:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2834              		.loc 1 1740 0
 2835 0544 08301BE5 		ldr	r3, [fp, #-8]
 2836 0548 000053E3 		cmp	r3, #0
 2837 054c 0500000A 		beq	.L158
1741:../CX3RDKOV5640.c ****     {
1742:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:CyU3PSetEpConfig BulkEp Err = 0x%x", status);
 2838              		.loc 1 1742 0
 2839 0550 0400A0E3 		mov	r0, #4
 2840 0554 E8129FE5 		ldr	r1, .L166+156
 2841 0558 08201BE5 		ldr	r2, [fp, #-8]
 2842 055c FEFFFFEB 		bl	CyU3PDebugPrint
1743:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2843              		.loc 1 1743 0
 2844 0560 08001BE5 		ldr	r0, [fp, #-8]
 2845 0564 FEFFFFEB 		bl	esUVCAppErrorHandler
 2846              	.L158:
1744:../CX3RDKOV5640.c ****     }
1745:../CX3RDKOV5640.c **** #ifdef VISDebug
1746:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:CyU3PSetEpConfig BulkEp");
1747:../CX3RDKOV5640.c **** #endif
1748:../CX3RDKOV5640.c ****     CyU3PUsbEPSetBurstMode (ES_UVC_EP_BULK_VIDEO, CyTrue);
 2847              		.loc 1 1748 0
 2848 0568 8300A0E3 		mov	r0, #131
 2849 056c 0110A0E3 		mov	r1, #1
 2850 0570 FEFFFFEB 		bl	CyU3PUsbEPSetBurstMode
1749:../CX3RDKOV5640.c **** 
1750:../CX3RDKOV5640.c ****     /* Flush the endpoint memory */
1751:../CX3RDKOV5640.c ****     CyU3PUsbFlushEp(ES_UVC_EP_BULK_VIDEO);
 2851              		.loc 1 1751 0
 2852 0574 8300A0E3 		mov	r0, #131
 2853 0578 FEFFFFEB 		bl	CyU3PUsbFlushEp
1752:../CX3RDKOV5640.c **** 
1753:../CX3RDKOV5640.c ****     /* Create a DMA Manual OUT channel for streaming data */
1754:../CX3RDKOV5640.c ****     /* Video streaming Channel is not active till a stream request is received */
1755:../CX3RDKOV5640.c ****     dmaCfg.size                 = ES_UVC_STREAM_BUF_SIZE;
 2854              		.loc 1 1755 0
 2855 057c B0329FE5 		ldr	r3, .L166+140
 2856 0580 B030D3E1 		ldrh	r3, [r3]
 2857 0584 BC334BE1 		strh	r3, [fp, #-60]	@ movhi
1756:../CX3RDKOV5640.c ****     dmaCfg.count                = ES_UVC_STREAM_BUF_COUNT;
 2858              		.loc 1 1756 0
 2859 0588 AC329FE5 		ldr	r3, .L166+148
 2860 058c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2861 0590 BA334BE1 		strh	r3, [fp, #-58]	@ movhi
1757:../CX3RDKOV5640.c ****     dmaCfg.validSckCount        = 2;
 2862              		.loc 1 1757 0
 2863 0594 0230A0E3 		mov	r3, #2
 2864 0598 B8334BE1 		strh	r3, [fp, #-56]	@ movhi
1758:../CX3RDKOV5640.c **** 
1759:../CX3RDKOV5640.c ****     dmaCfg.prodSckId[0]         = ES_UVC_PRODUCER_PPORT_SOCKET_0;
 2865              		.loc 1 1759 0
 2866 059c 013CA0E3 		mov	r3, #256
 2867 05a0 B6334BE1 		strh	r3, [fp, #-54]	@ movhi
1760:../CX3RDKOV5640.c ****     dmaCfg.prodSckId[1]         = ES_UVC_PRODUCER_PPORT_SOCKET_1;
 2868              		.loc 1 1760 0
 2869 05a4 9C329FE5 		ldr	r3, .L166+160
 2870 05a8 B4334BE1 		strh	r3, [fp, #-52]	@ movhi
1761:../CX3RDKOV5640.c **** 
1762:../CX3RDKOV5640.c ****     dmaCfg.consSckId[0]         = ES_UVC_EP_VIDEO_CONS_SOCKET;
 2871              		.loc 1 1762 0
 2872 05ac 98329FE5 		ldr	r3, .L166+164
 2873 05b0 BE324BE1 		strh	r3, [fp, #-46]	@ movhi
1763:../CX3RDKOV5640.c ****     dmaCfg.dmaMode              = CY_U3P_DMA_MODE_BYTE;
 2874              		.loc 1 1763 0
 2875 05b4 0030A0E3 		mov	r3, #0
 2876 05b8 1E304BE5 		strb	r3, [fp, #-30]
1764:../CX3RDKOV5640.c ****     dmaCfg.notification         = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 2877              		.loc 1 1764 0
 2878 05bc 1830A0E3 		mov	r3, #24
 2879 05c0 1C300BE5 		str	r3, [fp, #-28]
1765:../CX3RDKOV5640.c ****     dmaCfg.cb                   = esUVCUvcAppDmaCallback;
 2880              		.loc 1 1765 0
 2881 05c4 84329FE5 		ldr	r3, .L166+168
 2882 05c8 18300BE5 		str	r3, [fp, #-24]
1766:../CX3RDKOV5640.c ****     dmaCfg.prodHeader           = ES_UVC_PROD_HEADER;
 2883              		.loc 1 1766 0
 2884 05cc 0C30A0E3 		mov	r3, #12
 2885 05d0 B4324BE1 		strh	r3, [fp, #-36]	@ movhi
1767:../CX3RDKOV5640.c ****     dmaCfg.prodFooter           = ES_UVC_PROD_FOOTER;
 2886              		.loc 1 1767 0
 2887 05d4 0430A0E3 		mov	r3, #4
 2888 05d8 B2324BE1 		strh	r3, [fp, #-34]	@ movhi
1768:../CX3RDKOV5640.c ****     dmaCfg.consHeader           = 0;
 2889              		.loc 1 1768 0
 2890 05dc 0030A0E3 		mov	r3, #0
 2891 05e0 B0324BE1 		strh	r3, [fp, #-32]	@ movhi
1769:../CX3RDKOV5640.c ****     dmaCfg.prodAvailCount       = 0;
 2892              		.loc 1 1769 0
 2893 05e4 0030A0E3 		mov	r3, #0
 2894 05e8 B6324BE1 		strh	r3, [fp, #-38]	@ movhi
1770:../CX3RDKOV5640.c **** 
1771:../CX3RDKOV5640.c ****     status = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO_ONE ,
 2895              		.loc 1 1771 0
 2896 05ec 3C304BE2 		sub	r3, fp, #60
 2897 05f0 5C029FE5 		ldr	r0, .L166+172
 2898 05f4 0710A0E3 		mov	r1, #7
 2899 05f8 0320A0E1 		mov	r2, r3
 2900 05fc FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 2901 0600 08000BE5 		str	r0, [fp, #-8]
1772:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2902              		.loc 1 1772 0
 2903 0604 08301BE5 		ldr	r3, [fp, #-8]
 2904 0608 000053E3 		cmp	r3, #0
 2905 060c 0300000A 		beq	.L159
1773:../CX3RDKOV5640.c ****     {
1774:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:DmaMultiChannelCreate Err = 0x%x", status);
 2906              		.loc 1 1774 0
 2907 0610 0400A0E3 		mov	r0, #4
 2908 0614 3C129FE5 		ldr	r1, .L166+176
 2909 0618 08201BE5 		ldr	r2, [fp, #-8]
 2910 061c FEFFFFEB 		bl	CyU3PDebugPrint
 2911              	.L159:
1775:../CX3RDKOV5640.c ****     }
1776:../CX3RDKOV5640.c ****     CyU3PThreadSleep(100);
 2912              		.loc 1 1776 0
 2913 0620 6400A0E3 		mov	r0, #100
 2914 0624 FEFFFFEB 		bl	_tx_thread_sleep
1777:../CX3RDKOV5640.c **** 
1778:../CX3RDKOV5640.c ****     /* Reset the channel: Set to DSCR chain starting point in PORD/CONS SCKT; set
1779:../CX3RDKOV5640.c ****        DSCR_SIZE field in DSCR memory */
1780:../CX3RDKOV5640.c ****     status = CyU3PDmaMultiChannelReset(&glChHandleUVCStream);  //-TODO the glChHandleUVCStream
 2915              		.loc 1 1780 0
 2916 0628 24029FE5 		ldr	r0, .L166+172
 2917 062c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 2918 0630 08000BE5 		str	r0, [fp, #-8]
1781:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2919              		.loc 1 1781 0
 2920 0634 08301BE5 		ldr	r3, [fp, #-8]
 2921 0638 000053E3 		cmp	r3, #0
 2922 063c 0300000A 		beq	.L160
1782:../CX3RDKOV5640.c ****     {
1783:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4,"\n\rAppInit:MultiChannelReset Err = 0x%x", status);
 2923              		.loc 1 1783 0
 2924 0640 0400A0E3 		mov	r0, #4
 2925 0644 10129FE5 		ldr	r1, .L166+180
 2926 0648 08201BE5 		ldr	r2, [fp, #-8]
 2927 064c FEFFFFEB 		bl	CyU3PDebugPrint
 2928              	.L160:
1784:../CX3RDKOV5640.c ****     }
1785:../CX3RDKOV5640.c **** #ifdef VISDebug
1786:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:MultiChannelReset");
1787:../CX3RDKOV5640.c **** #endif
1788:../CX3RDKOV5640.c ****     /* Configure the Fixed Function GPIF on the CX3 to use a 16 bit bus, and
1789:../CX3RDKOV5640.c ****      * a DMA Buffer of size CX3_UVC_DATA_BUF_SIZE
1790:../CX3RDKOV5640.c ****      */
1791:../CX3RDKOV5640.c ****     status = CyU3PMipicsiGpifLoad(CY_U3P_MIPICSI_BUS_16, ES_UVC_DATA_BUF_SIZE);
 2929              		.loc 1 1791 0
 2930 0650 E0319FE5 		ldr	r3, .L166+144
 2931 0654 B030D3E1 		ldrh	r3, [r3]
 2932 0658 0100A0E3 		mov	r0, #1
 2933 065c 0310A0E1 		mov	r1, r3
 2934 0660 FEFFFFEB 		bl	CyU3PMipicsiGpifLoad
 2935 0664 08000BE5 		str	r0, [fp, #-8]
1792:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2936              		.loc 1 1792 0
 2937 0668 08301BE5 		ldr	r3, [fp, #-8]
 2938 066c 000053E3 		cmp	r3, #0
 2939 0670 0500000A 		beq	.L161
1793:../CX3RDKOV5640.c ****     {
1794:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:MipicsiGpifLoad Err = 0x%x", status);
 2940              		.loc 1 1794 0
 2941 0674 0400A0E3 		mov	r0, #4
 2942 0678 E0119FE5 		ldr	r1, .L166+184
 2943 067c 08201BE5 		ldr	r2, [fp, #-8]
 2944 0680 FEFFFFEB 		bl	CyU3PDebugPrint
1795:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2945              		.loc 1 1795 0
 2946 0684 08001BE5 		ldr	r0, [fp, #-8]
 2947 0688 FEFFFFEB 		bl	esUVCAppErrorHandler
 2948              	.L161:
1796:../CX3RDKOV5640.c ****     }
1797:../CX3RDKOV5640.c ****     CyU3PThreadSleep(50);
 2949              		.loc 1 1797 0
 2950 068c 3200A0E3 		mov	r0, #50
 2951 0690 FEFFFFEB 		bl	_tx_thread_sleep
1798:../CX3RDKOV5640.c **** #ifdef VISDebug
1799:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:MipicsiGpifLoad");
1800:../CX3RDKOV5640.c **** #endif
1801:../CX3RDKOV5640.c ****     CyU3PGpifRegisterCallback(esUVCGpifCB);
 2952              		.loc 1 1801 0
 2953 0694 C8019FE5 		ldr	r0, .L166+188
 2954 0698 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
1802:../CX3RDKOV5640.c ****     CyU3PThreadSleep(50);
 2955              		.loc 1 1802 0
 2956 069c 3200A0E3 		mov	r0, #50
 2957 06a0 FEFFFFEB 		bl	_tx_thread_sleep
1803:../CX3RDKOV5640.c **** 
1804:../CX3RDKOV5640.c ****     /* Start the state machine. */
1805:../CX3RDKOV5640.c ****     status = CyU3PGpifSMStart (CX3_START_SCK0, ALPHA_CX3_START_SCK0);
 2958              		.loc 1 1805 0
 2959 06a4 0000A0E3 		mov	r0, #0
 2960 06a8 0010A0E3 		mov	r1, #0
 2961 06ac FEFFFFEB 		bl	CyU3PGpifSMStart
 2962 06b0 08000BE5 		str	r0, [fp, #-8]
1806:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2963              		.loc 1 1806 0
 2964 06b4 08301BE5 		ldr	r3, [fp, #-8]
 2965 06b8 000053E3 		cmp	r3, #0
 2966 06bc 0500000A 		beq	.L162
1807:../CX3RDKOV5640.c ****     {
1808:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:GpifSMStart Err = 0x%x", status);
 2967              		.loc 1 1808 0
 2968 06c0 0400A0E3 		mov	r0, #4
 2969 06c4 9C119FE5 		ldr	r1, .L166+192
 2970 06c8 08201BE5 		ldr	r2, [fp, #-8]
 2971 06cc FEFFFFEB 		bl	CyU3PDebugPrint
1809:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2972              		.loc 1 1809 0
 2973 06d0 08001BE5 		ldr	r0, [fp, #-8]
 2974 06d4 FEFFFFEB 		bl	esUVCAppErrorHandler
 2975              	.L162:
1810:../CX3RDKOV5640.c ****     }
1811:../CX3RDKOV5640.c ****     CyU3PThreadSleep(50);
 2976              		.loc 1 1811 0
 2977 06d8 3200A0E3 		mov	r0, #50
 2978 06dc FEFFFFEB 		bl	_tx_thread_sleep
1812:../CX3RDKOV5640.c **** #ifdef VISDebug
1813:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:GpifSMStart");
1814:../CX3RDKOV5640.c **** #endif
1815:../CX3RDKOV5640.c ****     /* Pause the GPIF*/
1816:../CX3RDKOV5640.c ****     CyU3PGpifSMControl(CyTrue);
 2979              		.loc 1 1816 0
 2980 06e0 0100A0E3 		mov	r0, #1
 2981 06e4 FEFFFFEB 		bl	CyU3PGpifSMControl
1817:../CX3RDKOV5640.c **** 
1818:../CX3RDKOV5640.c ****     /* Initialize the MIPI block */
1819:../CX3RDKOV5640.c ****     status =  CyU3PMipicsiInit();
 2982              		.loc 1 1819 0
 2983 06e8 FEFFFFEB 		bl	CyU3PMipicsiInit
 2984 06ec 08000BE5 		str	r0, [fp, #-8]
1820:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 2985              		.loc 1 1820 0
 2986 06f0 08301BE5 		ldr	r3, [fp, #-8]
 2987 06f4 000053E3 		cmp	r3, #0
 2988 06f8 0500000A 		beq	.L163
1821:../CX3RDKOV5640.c ****     {
1822:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:MipicsiInit Err = 0x%x", status);
 2989              		.loc 1 1822 0
 2990 06fc 0400A0E3 		mov	r0, #4
 2991 0700 64119FE5 		ldr	r1, .L166+196
 2992 0704 08201BE5 		ldr	r2, [fp, #-8]
 2993 0708 FEFFFFEB 		bl	CyU3PDebugPrint
1823:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 2994              		.loc 1 1823 0
 2995 070c 08001BE5 		ldr	r0, [fp, #-8]
 2996 0710 FEFFFFEB 		bl	esUVCAppErrorHandler
 2997              	.L163:
1824:../CX3RDKOV5640.c ****     }
1825:../CX3RDKOV5640.c **** #ifdef VISDebug
1826:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:MipicsiInit");
1827:../CX3RDKOV5640.c **** #endif
1828:../CX3RDKOV5640.c ****     status = CyU3PMipicsiSetIntfParams(&cfgUvcVgaNoMclk, CyTrue/*CyFalse*/);
 2998              		.loc 1 1828 0
 2999 0714 54019FE5 		ldr	r0, .L166+200
 3000 0718 0110A0E3 		mov	r1, #1
 3001 071c FEFFFFEB 		bl	CyU3PMipicsiSetIntfParams
 3002 0720 08000BE5 		str	r0, [fp, #-8]
1829:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3003              		.loc 1 1829 0
 3004 0724 08301BE5 		ldr	r3, [fp, #-8]
 3005 0728 000053E3 		cmp	r3, #0
 3006 072c 0500000A 		beq	.L164
1830:../CX3RDKOV5640.c ****     {
1831:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\rAppInit:MipicsiSetIntfParams Err = 0x%x",status);
 3007              		.loc 1 1831 0
 3008 0730 0400A0E3 		mov	r0, #4
 3009 0734 38119FE5 		ldr	r1, .L166+204
 3010 0738 08201BE5 		ldr	r2, [fp, #-8]
 3011 073c FEFFFFEB 		bl	CyU3PDebugPrint
1832:../CX3RDKOV5640.c ****         esUVCAppErrorHandler(status);
 3012              		.loc 1 1832 0
 3013 0740 08001BE5 		ldr	r0, [fp, #-8]
 3014 0744 FEFFFFEB 		bl	esUVCAppErrorHandler
 3015              	.L164:
1833:../CX3RDKOV5640.c ****     }
1834:../CX3RDKOV5640.c **** #ifdef VISDebug
1835:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rAppInit:MipicsiSetIntfParams");
1836:../CX3RDKOV5640.c **** #endif
1837:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
1838:../CX3RDKOV5640.c ****     CyU3PTimerCreate (&UvcTimer, UvcAppProgressTimer, 0x00, TIMER_PERIOD, 0, CYU3P_NO_ACTIVATE);
 3016              		.loc 1 1838 0
 3017 0748 7D3FA0E3 		mov	r3, #500
 3018 074c 00308DE5 		str	r3, [sp]
 3019 0750 0030A0E3 		mov	r3, #0
 3020 0754 04308DE5 		str	r3, [sp, #4]
 3021 0758 0030A0E3 		mov	r3, #0
 3022 075c 08308DE5 		str	r3, [sp, #8]
 3023 0760 2C30A0E3 		mov	r3, #44
 3024 0764 0C308DE5 		str	r3, [sp, #12]
 3025 0768 08019FE5 		ldr	r0, .L166+208
 3026 076c 0010A0E3 		mov	r1, #0
 3027 0770 04219FE5 		ldr	r2, .L166+212
 3028 0774 0030A0E3 		mov	r3, #0
 3029 0778 FEFFFFEB 		bl	_txe_timer_create
1839:../CX3RDKOV5640.c **** #endif
1840:../CX3RDKOV5640.c **** 
1841:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rFirmware Version: %d.%d.%d.%d",MajorVersion,MinorVersion,SubVersion,Su
 3030              		.loc 1 1841 0
 3031 077c 8530A0E3 		mov	r3, #133
 3032 0780 00308DE5 		str	r3, [sp]
 3033 0784 F4309FE5 		ldr	r3, .L166+216
 3034 0788 04308DE5 		str	r3, [sp, #4]
 3035 078c 0400A0E3 		mov	r0, #4
 3036 0790 EC109FE5 		ldr	r1, .L166+220
 3037 0794 0120A0E3 		mov	r2, #1
 3038 0798 0330A0E3 		mov	r3, #3
 3039 079c FEFFFFEB 		bl	CyU3PDebugPrint
1842:../CX3RDKOV5640.c **** }
 3040              		.loc 1 1842 0
 3041 07a0 04D04BE2 		sub	sp, fp, #4
 3042              		@ sp needed
 3043 07a4 0088BDE8 		ldmfd	sp!, {fp, pc}
 3044              	.L167:
 3045              		.align	2
 3046              	.L166:
 3047 07a8 E4020000 		.word	.LC18
 3048 07ac 04030000 		.word	.LC19
 3049 07b0 24030000 		.word	.LC20
 3050 07b4 44030000 		.word	.LC21
 3051 07b8 00000000 		.word	esUVCUvcApplnUSBSetupCB
 3052 07bc 00000000 		.word	esUVCUvcApplnUSBEventCB
 3053 07c0 00000000 		.word	esUVCApplnLPMRqtCB
 3054 07c4 00000000 		.word	esUVCUSB30DeviceDscr
 3055 07c8 64030000 		.word	.LC22
 3056 07cc 00000000 		.word	esUVCUSB20DeviceDscr
 3057 07d0 8C030000 		.word	.LC23
 3058 07d4 00000000 		.word	esUVCUSBBOSDscr
 3059 07d8 B4030000 		.word	.LC24
 3060 07dc 00000000 		.word	esUVCUSBDeviceQualDscr
 3061 07e0 D8030000 		.word	.LC25
 3062 07e4 00000000 		.word	esUVCUSBSSConfigDscr
 3063 07e8 00040000 		.word	.LC26
 3064 07ec 00000000 		.word	esUVCUSBHSConfigDscr
 3065 07f0 28040000 		.word	.LC27
 3066 07f4 00000000 		.word	esUVCUSBFSConfigDscr
 3067 07f8 50040000 		.word	.LC28
 3068 07fc 00000000 		.word	esUVCUSBStringLangIDDscr
 3069 0800 78040000 		.word	.LC29
 3070 0804 00000000 		.word	esUVCUSBManufactureDscr
 3071 0808 A0040000 		.word	.LC30
 3072 080c 00000000 		.word	esUVCUSBProductDscr
 3073 0810 C8040000 		.word	.LC31
 3074 0814 00000000 		.word	esUVCUSBConfigSSDscr
 3075 0818 F0040000 		.word	.LC32
 3076 081c 00000000 		.word	esUVCUSBConfigHSDscr
 3077 0820 18050000 		.word	.LC33
 3078 0824 00000000 		.word	esUVCUSBConfigFSDscr
 3079 0828 40050000 		.word	.LC34
 3080 082c 68050000 		.word	.LC35
 3081 0830 8C050000 		.word	.LC36
 3082 0834 00000000 		.word	ES_UVC_STREAM_BUF_SIZE
 3083 0838 00000000 		.word	ES_UVC_DATA_BUF_SIZE
 3084 083c 00000000 		.word	ES_UVC_STREAM_BUF_COUNT
 3085 0840 F05F0000 		.word	24560
 3086 0844 BC050000 		.word	.LC37
 3087 0848 01010000 		.word	257
 3088 084c 03030000 		.word	771
 3089 0850 00000000 		.word	esUVCUvcAppDmaCallback
 3090 0854 00000000 		.word	glChHandleUVCStream
 3091 0858 EC050000 		.word	.LC38
 3092 085c 18060000 		.word	.LC39
 3093 0860 40060000 		.word	.LC40
 3094 0864 00000000 		.word	esUVCGpifCB
 3095 0868 68060000 		.word	.LC41
 3096 086c 8C060000 		.word	.LC42
 3097 0870 00000000 		.word	cfgUvcVgaNoMclk
 3098 0874 B0060000 		.word	.LC43
 3099 0878 00000000 		.word	UvcTimer
 3100 087c 00000000 		.word	UvcAppProgressTimer
 3101 0880 35010000 		.word	309
 3102 0884 DC060000 		.word	.LC44
 3103              		.cfi_endproc
 3104              	.LFE11:
 3106              		.section	.rodata
 3107              		.align	2
 3108              	.LC45:
 3109 06fc 0A0D6573 		.ascii	"\012\015esUVCUvcApplnDebugInit:CyU3PUartInit failed"
 3109      55564355 
 3109      76634170 
 3109      706C6E44 
 3109      65627567 
 3110 0729 20457272 		.ascii	" Error = 0x%x\000"
 3110      6F72203D 
 3110      20307825 
 3110      7800
 3111 0737 00       		.align	2
 3112              	.LC46:
 3113 0738 0A0D6573 		.ascii	"\012\015esUVCUvcApplnDebugInit:CyU3PUartSetConfig f"
 3113      55564355 
 3113      76634170 
 3113      706C6E44 
 3113      65627567 
 3114 0765 61696C65 		.ascii	"ailed Error = 0x%x\000"
 3114      64204572 
 3114      726F7220 
 3114      3D203078 
 3114      257800
 3115              		.align	2
 3116              	.LC47:
 3117 0778 0A0D6573 		.ascii	"\012\015esUVCUvcApplnDebugInit:CyU3PUartTxSetBlockX"
 3117      55564355 
 3117      76634170 
 3117      706C6E44 
 3117      65627567 
 3118 07a5 66657220 		.ascii	"fer failed Error = 0x%x\000"
 3118      6661696C 
 3118      65642045 
 3118      72726F72 
 3118      203D2030 
 3119 07bd 000000   		.align	2
 3120              	.LC48:
 3121 07c0 0A0D6573 		.ascii	"\012\015esUVCUvcApplnDebugInit:CyU3PDebugInit faile"
 3121      55564355 
 3121      76634170 
 3121      706C6E44 
 3121      65627567 
 3122 07ed 64204572 		.ascii	"d Error = 0x%x\000"
 3122      726F7220 
 3122      3D203078 
 3122      257800
 3123              		.section	.text.esUVCUvcApplnDebugInit,"ax",%progbits
 3124              		.align	2
 3125              		.global	esUVCUvcApplnDebugInit
 3127              	esUVCUvcApplnDebugInit:
 3128              	.LFB12:
1843:../CX3RDKOV5640.c **** 
1844:../CX3RDKOV5640.c **** /* This function initializes the debug module for the UVC application */
1845:../CX3RDKOV5640.c ****     void
1846:../CX3RDKOV5640.c **** esUVCUvcApplnDebugInit (void)
1847:../CX3RDKOV5640.c **** {
 3129              		.loc 1 1847 0
 3130              		.cfi_startproc
 3131              		@ args = 0, pretend = 0, frame = 32
 3132              		@ frame_needed = 1, uses_anonymous_args = 0
 3133 0000 00482DE9 		stmfd	sp!, {fp, lr}
 3134              	.LCFI24:
 3135              		.cfi_def_cfa_offset 8
 3136              		.cfi_offset 11, -8
 3137              		.cfi_offset 14, -4
 3138 0004 04B08DE2 		add	fp, sp, #4
 3139              	.LCFI25:
 3140              		.cfi_def_cfa 11, 4
 3141 0008 20D04DE2 		sub	sp, sp, #32
1848:../CX3RDKOV5640.c ****     CyU3PUartConfig_t uartConfig;
1849:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 3142              		.loc 1 1849 0
 3143 000c 0030A0E3 		mov	r3, #0
 3144 0010 08300BE5 		str	r3, [fp, #-8]
1850:../CX3RDKOV5640.c **** 
1851:../CX3RDKOV5640.c ****     /* Initialize the UART for printing debug messages */
1852:../CX3RDKOV5640.c ****     status = CyU3PUartInit();
 3145              		.loc 1 1852 0
 3146 0014 FEFFFFEB 		bl	CyU3PUartInit
 3147 0018 08000BE5 		str	r0, [fp, #-8]
1853:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3148              		.loc 1 1853 0
 3149 001c 08301BE5 		ldr	r3, [fp, #-8]
 3150 0020 000053E3 		cmp	r3, #0
 3151 0024 0300000A 		beq	.L169
1854:../CX3RDKOV5640.c ****     {
1855:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\resUVCUvcApplnDebugInit:CyU3PUartInit failed Error = 0x%x",status);
 3152              		.loc 1 1855 0
 3153 0028 0400A0E3 		mov	r0, #4
 3154 002c D0109FE5 		ldr	r1, .L173
 3155 0030 08201BE5 		ldr	r2, [fp, #-8]
 3156 0034 FEFFFFEB 		bl	CyU3PDebugPrint
 3157              	.L169:
1856:../CX3RDKOV5640.c ****     }
1857:../CX3RDKOV5640.c **** 
1858:../CX3RDKOV5640.c ****     /* Set UART Configuration */
1859:../CX3RDKOV5640.c ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 3158              		.loc 1 1859 0
 3159 0038 C8309FE5 		ldr	r3, .L173+4
 3160 003c 10300BE5 		str	r3, [fp, #-16]
1860:../CX3RDKOV5640.c ****     uartConfig.stopBit = CY_U3P_UART_ONE_STOP_BIT;
 3161              		.loc 1 1860 0
 3162 0040 0130A0E3 		mov	r3, #1
 3163 0044 0C304BE5 		strb	r3, [fp, #-12]
1861:../CX3RDKOV5640.c ****     uartConfig.parity = CY_U3P_UART_NO_PARITY;
 3164              		.loc 1 1861 0
 3165 0048 0030A0E3 		mov	r3, #0
 3166 004c 0B304BE5 		strb	r3, [fp, #-11]
1862:../CX3RDKOV5640.c ****     uartConfig.txEnable = CyTrue;
 3167              		.loc 1 1862 0
 3168 0050 0130A0E3 		mov	r3, #1
 3169 0054 20300BE5 		str	r3, [fp, #-32]
1863:../CX3RDKOV5640.c ****     uartConfig.rxEnable = CyFalse;
 3170              		.loc 1 1863 0
 3171 0058 0030A0E3 		mov	r3, #0
 3172 005c 1C300BE5 		str	r3, [fp, #-28]
1864:../CX3RDKOV5640.c ****     uartConfig.flowCtrl = CyFalse;
 3173              		.loc 1 1864 0
 3174 0060 0030A0E3 		mov	r3, #0
 3175 0064 18300BE5 		str	r3, [fp, #-24]
1865:../CX3RDKOV5640.c ****     uartConfig.isDma = CyTrue;
 3176              		.loc 1 1865 0
 3177 0068 0130A0E3 		mov	r3, #1
 3178 006c 14300BE5 		str	r3, [fp, #-20]
1866:../CX3RDKOV5640.c **** 
1867:../CX3RDKOV5640.c ****     /* Set the UART configuration */
1868:../CX3RDKOV5640.c ****     status = CyU3PUartSetConfig (&uartConfig, NULL);
 3179              		.loc 1 1868 0
 3180 0070 20304BE2 		sub	r3, fp, #32
 3181 0074 0300A0E1 		mov	r0, r3
 3182 0078 0010A0E3 		mov	r1, #0
 3183 007c FEFFFFEB 		bl	CyU3PUartSetConfig
 3184 0080 08000BE5 		str	r0, [fp, #-8]
1869:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3185              		.loc 1 1869 0
 3186 0084 08301BE5 		ldr	r3, [fp, #-8]
 3187 0088 000053E3 		cmp	r3, #0
 3188 008c 0300000A 		beq	.L170
1870:../CX3RDKOV5640.c ****     {
1871:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\resUVCUvcApplnDebugInit:CyU3PUartSetConfig failed Error = 0x%x",sta
 3189              		.loc 1 1871 0
 3190 0090 0400A0E3 		mov	r0, #4
 3191 0094 70109FE5 		ldr	r1, .L173+8
 3192 0098 08201BE5 		ldr	r2, [fp, #-8]
 3193 009c FEFFFFEB 		bl	CyU3PDebugPrint
 3194              	.L170:
1872:../CX3RDKOV5640.c ****     }
1873:../CX3RDKOV5640.c **** 
1874:../CX3RDKOV5640.c ****     /* Set the UART transfer */
1875:../CX3RDKOV5640.c ****     status = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 3195              		.loc 1 1875 0
 3196 00a0 0000E0E3 		mvn	r0, #0
 3197 00a4 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 3198 00a8 08000BE5 		str	r0, [fp, #-8]
1876:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3199              		.loc 1 1876 0
 3200 00ac 08301BE5 		ldr	r3, [fp, #-8]
 3201 00b0 000053E3 		cmp	r3, #0
 3202 00b4 0300000A 		beq	.L171
1877:../CX3RDKOV5640.c ****     {
1878:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\resUVCUvcApplnDebugInit:CyU3PUartTxSetBlockXfer failed Error = 0x%x
 3203              		.loc 1 1878 0
 3204 00b8 0400A0E3 		mov	r0, #4
 3205 00bc 4C109FE5 		ldr	r1, .L173+12
 3206 00c0 08201BE5 		ldr	r2, [fp, #-8]
 3207 00c4 FEFFFFEB 		bl	CyU3PDebugPrint
 3208              	.L171:
1879:../CX3RDKOV5640.c ****     }
1880:../CX3RDKOV5640.c **** 
1881:../CX3RDKOV5640.c ****     /* Initialize the debug application */
1882:../CX3RDKOV5640.c ****     status = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 8);
 3209              		.loc 1 1882 0
 3210 00c8 0300A0E3 		mov	r0, #3
 3211 00cc 0810A0E3 		mov	r1, #8
 3212 00d0 FEFFFFEB 		bl	CyU3PDebugInit
 3213 00d4 08000BE5 		str	r0, [fp, #-8]
1883:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3214              		.loc 1 1883 0
 3215 00d8 08301BE5 		ldr	r3, [fp, #-8]
 3216 00dc 000053E3 		cmp	r3, #0
 3217 00e0 0300000A 		beq	.L172
1884:../CX3RDKOV5640.c ****     {
1885:../CX3RDKOV5640.c ****         CyU3PDebugPrint (4, "\n\resUVCUvcApplnDebugInit:CyU3PDebugInit failed Error = 0x%x",status)
 3218              		.loc 1 1885 0
 3219 00e4 0400A0E3 		mov	r0, #4
 3220 00e8 24109FE5 		ldr	r1, .L173+16
 3221 00ec 08201BE5 		ldr	r2, [fp, #-8]
 3222 00f0 FEFFFFEB 		bl	CyU3PDebugPrint
 3223              	.L172:
1886:../CX3RDKOV5640.c ****     }
1887:../CX3RDKOV5640.c ****     CyU3PDebugPreamble (CyFalse);
 3224              		.loc 1 1887 0
 3225 00f4 0000A0E3 		mov	r0, #0
 3226 00f8 FEFFFFEB 		bl	CyU3PDebugPreamble
1888:../CX3RDKOV5640.c **** 
1889:../CX3RDKOV5640.c **** }
 3227              		.loc 1 1889 0
 3228 00fc 04D04BE2 		sub	sp, fp, #4
 3229              		@ sp needed
 3230 0100 0088BDE8 		ldmfd	sp!, {fp, pc}
 3231              	.L174:
 3232              		.align	2
 3233              	.L173:
 3234 0104 FC060000 		.word	.LC45
 3235 0108 00C20100 		.word	115200
 3236 010c 38070000 		.word	.LC46
 3237 0110 78070000 		.word	.LC47
 3238 0114 C0070000 		.word	.LC48
 3239              		.cfi_endproc
 3240              	.LFE12:
 3242              		.section	.text.esUVCUvcAppThread_Entry,"ax",%progbits
 3243              		.align	2
 3244              		.global	esUVCUvcAppThread_Entry
 3246              	esUVCUvcAppThread_Entry:
 3247              	.LFB13:
1890:../CX3RDKOV5640.c **** 
1891:../CX3RDKOV5640.c **** /* Entry function for the UVC application thread. */
1892:../CX3RDKOV5640.c ****     void
1893:../CX3RDKOV5640.c **** esUVCUvcAppThread_Entry (
1894:../CX3RDKOV5640.c ****         uint32_t input)
1895:../CX3RDKOV5640.c **** {
 3248              		.loc 1 1895 0
 3249              		.cfi_startproc
 3250              		@ args = 0, pretend = 0, frame = 16
 3251              		@ frame_needed = 1, uses_anonymous_args = 0
 3252 0000 00482DE9 		stmfd	sp!, {fp, lr}
 3253              	.LCFI26:
 3254              		.cfi_def_cfa_offset 8
 3255              		.cfi_offset 11, -8
 3256              		.cfi_offset 14, -4
 3257 0004 04B08DE2 		add	fp, sp, #4
 3258              	.LCFI27:
 3259              		.cfi_def_cfa 11, 4
 3260 0008 18D04DE2 		sub	sp, sp, #24
 3261 000c 10000BE5 		str	r0, [fp, #-16]
1896:../CX3RDKOV5640.c ****     uint16_t wakeReason;
1897:../CX3RDKOV5640.c ****     uint32_t eventFlag;
1898:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status;
1899:../CX3RDKOV5640.c **** 
1900:../CX3RDKOV5640.c ****     /* Initialize the Debug Module */
1901:../CX3RDKOV5640.c ****     esUVCUvcApplnDebugInit();
 3262              		.loc 1 1901 0
 3263 0010 FEFFFFEB 		bl	esUVCUvcApplnDebugInit
1902:../CX3RDKOV5640.c **** 
1903:../CX3RDKOV5640.c ****     /* Initialize the UVC Application */
1904:../CX3RDKOV5640.c ****     esUVCUvcApplnInit();
 3264              		.loc 1 1904 0
 3265 0014 FEFFFFEB 		bl	esUVCUvcApplnInit
 3266              	.L181:
1905:../CX3RDKOV5640.c **** 
1906:../CX3RDKOV5640.c ****     for (;;)
1907:../CX3RDKOV5640.c ****     {
1908:../CX3RDKOV5640.c ****         CyU3PEventGet (&glTimerEvent,ES_USB_SUSP_EVENT_FLAG|ES_TIMER_RESET_EVENT, CYU3P_EVENT_OR_CL
 3267              		.loc 1 1908 0
 3268 0018 08304BE2 		sub	r3, fp, #8
 3269 001c 0020E0E3 		mvn	r2, #0
 3270 0020 00208DE5 		str	r2, [sp]
 3271 0024 A8009FE5 		ldr	r0, .L183
 3272 0028 3010A0E3 		mov	r1, #48
 3273 002c 0120A0E3 		mov	r2, #1
 3274 0030 FEFFFFEB 		bl	_txe_event_flags_get
1909:../CX3RDKOV5640.c **** 
1910:../CX3RDKOV5640.c ****         /* Handle TimerReset Event*/
1911:../CX3RDKOV5640.c ****         if( eventFlag & ES_TIMER_RESET_EVENT)
 3275              		.loc 1 1911 0
 3276 0034 08301BE5 		ldr	r3, [fp, #-8]
 3277 0038 103003E2 		and	r3, r3, #16
 3278 003c 000053E3 		cmp	r3, #0
 3279 0040 1700000A 		beq	.L176
1912:../CX3RDKOV5640.c ****         {
1913:../CX3RDKOV5640.c ****             if (glIsApplnActive)
 3280              		.loc 1 1913 0
 3281 0044 8C309FE5 		ldr	r3, .L183+4
 3282 0048 003093E5 		ldr	r3, [r3]
 3283 004c 000053E3 		cmp	r3, #0
 3284 0050 0300000A 		beq	.L177
1914:../CX3RDKOV5640.c ****             {
1915:../CX3RDKOV5640.c ****             	glIsClearFeature = CyFalse;
 3285              		.loc 1 1915 0
 3286 0054 80309FE5 		ldr	r3, .L183+8
 3287 0058 0020A0E3 		mov	r2, #0
 3288 005c 002083E5 		str	r2, [r3]
1916:../CX3RDKOV5640.c ****                 esUVCUvcApplnStop();
 3289              		.loc 1 1916 0
 3290 0060 FEFFFFEB 		bl	esUVCUvcApplnStop
 3291              	.L177:
1917:../CX3RDKOV5640.c **** #ifdef VISDebug
1918:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rES_TIMER_RESET_EVENT: esUVCUvcApplnStop");
1919:../CX3RDKOV5640.c **** #endif
1920:../CX3RDKOV5640.c ****             }
1921:../CX3RDKOV5640.c ****             if(glPreviewStarted == CyTrue)
 3292              		.loc 1 1921 0
 3293 0064 74309FE5 		ldr	r3, .L183+12
 3294 0068 003093E5 		ldr	r3, [r3]
 3295 006c 010053E3 		cmp	r3, #1
 3296 0070 0700001A 		bne	.L178
1922:../CX3RDKOV5640.c ****             {
1923:../CX3RDKOV5640.c ****             	//TODO Change this function with "Sensor Specific" function to write the sensor settin
1924:../CX3RDKOV5640.c ****             	esSetCameraResolution(glFrameIndexToSet);
 3297              		.loc 1 1924 0
 3298 0074 68309FE5 		ldr	r3, .L183+16
 3299 0078 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 3300 007c 0300A0E1 		mov	r0, r3
 3301 0080 FEFFFFEB 		bl	esSetCameraResolution
1925:../CX3RDKOV5640.c ****             	esUVCUvcApplnStart();
 3302              		.loc 1 1925 0
 3303 0084 FEFFFFEB 		bl	esUVCUvcApplnStart
1926:../CX3RDKOV5640.c ****             	SensorGetControl(0x02, 0x30); //using this statement to start the video by microcode.
 3304              		.loc 1 1926 0
 3305 0088 0200A0E3 		mov	r0, #2
 3306 008c 3010A0E3 		mov	r1, #48
 3307 0090 FEFFFFEB 		bl	SensorGetControl
 3308              	.L178:
1927:../CX3RDKOV5640.c **** #ifdef VISDebug
1928:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rES_TIMER_RESET_EVENT: esUVCUvcApplnStart");
1929:../CX3RDKOV5640.c **** #endif
1930:../CX3RDKOV5640.c ****             }
1931:../CX3RDKOV5640.c **** #ifdef RESET_TIMER_ENABLE
1932:../CX3RDKOV5640.c ****             CyU3PTimerModify (&UvcTimer, TIMER_PERIOD, 0);
 3309              		.loc 1 1932 0
 3310 0094 4C009FE5 		ldr	r0, .L183+20
 3311 0098 7D1FA0E3 		mov	r1, #500
 3312 009c 0020A0E3 		mov	r2, #0
 3313 00a0 FEFFFFEB 		bl	_txe_timer_change
 3314              	.L176:
1933:../CX3RDKOV5640.c **** #endif
1934:../CX3RDKOV5640.c ****         }
1935:../CX3RDKOV5640.c ****         /* Handle Suspend Event*/
1936:../CX3RDKOV5640.c ****         if(eventFlag & ES_USB_SUSP_EVENT_FLAG)
 3315              		.loc 1 1936 0
 3316 00a4 08301BE5 		ldr	r3, [fp, #-8]
 3317 00a8 203003E2 		and	r3, r3, #32
 3318 00ac 000053E3 		cmp	r3, #0
 3319 00b0 0600000A 		beq	.L179
1937:../CX3RDKOV5640.c ****         {
1938:../CX3RDKOV5640.c ****             /* Place CX3 in Low Power Suspend mode, with USB bus activity as the wakeup source. */
1939:../CX3RDKOV5640.c ****             //CyU3PMipicsiSleep();
1940:../CX3RDKOV5640.c ****             //TODO Change this function with "Sensor Specific" PowerDown function to PowerDown the 
1941:../CX3RDKOV5640.c ****             //esCamera_Power_Down();
1942:../CX3RDKOV5640.c **** 
1943:../CX3RDKOV5640.c ****             //status = CyU3PSysEnterSuspendMode (CY_U3P_SYS_USB_BUS_ACTVTY_WAKEUP_SRC, 0, &wakeReas
1944:../CX3RDKOV5640.c **** #ifdef VISDebug
1945:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rES_USB_SUSP_EVENT_FLAG %x", status);
1946:../CX3RDKOV5640.c **** #endif
1947:../CX3RDKOV5640.c ****     		if(glMipiActive)
 3320              		.loc 1 1947 0
 3321 00b4 30309FE5 		ldr	r3, .L183+24
 3322 00b8 003093E5 		ldr	r3, [r3]
 3323 00bc 000053E3 		cmp	r3, #0
 3324 00c0 0100000A 		beq	.L180
1948:../CX3RDKOV5640.c ****             {
1949:../CX3RDKOV5640.c ****                 CyU3PMipicsiWakeup();
 3325              		.loc 1 1949 0
 3326 00c4 FEFFFFEB 		bl	CyU3PMipicsiWakeup
1950:../CX3RDKOV5640.c ****                 //TODO Change this function with "Sensor Specific" PowerUp function to PowerUp the 
1951:../CX3RDKOV5640.c ****                 //esCamera_Power_Up();  // remove the camera operations function for VIS mipi camer
1952:../CX3RDKOV5640.c **** #ifdef VISDebug
1953:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rES_USB_SUSP_EVENT_FLAG: esCamera_Power_Up");
1954:../CX3RDKOV5640.c **** #endif
1955:../CX3RDKOV5640.c ****             }
1956:../CX3RDKOV5640.c ****             continue;
 3327              		.loc 1 1956 0
 3328 00c8 FFFFFFEA 		b	.L182
 3329              	.L180:
 3330              	.L182:
 3331 00cc 0000A0E1 		mov	r0, r0	@ nop
 3332              	.L179:
1957:../CX3RDKOV5640.c ****         }
1958:../CX3RDKOV5640.c **** #ifdef VISDebug
1959:../CX3RDKOV5640.c ****     CyU3PDebugPrint (4, "\n\rApp Thread Loop");
1960:../CX3RDKOV5640.c **** #endif
1961:../CX3RDKOV5640.c ****     } /* End of for(;;) */
 3333              		.loc 1 1961 0
 3334 00d0 D0FFFFEA 		b	.L181
 3335              	.L184:
 3336              		.align	2
 3337              	.L183:
 3338 00d4 00000000 		.word	glTimerEvent
 3339 00d8 00000000 		.word	glIsApplnActive
 3340 00dc 00000000 		.word	glIsClearFeature
 3341 00e0 00000000 		.word	glPreviewStarted
 3342 00e4 00000000 		.word	glFrameIndexToSet
 3343 00e8 00000000 		.word	UvcTimer
 3344 00ec 00000000 		.word	glMipiActive
 3345              		.cfi_endproc
 3346              	.LFE13:
 3348              		.section	.rodata
 3349              		.align	2
 3350              	.LC49:
 3351 07fc 53656E43 		.ascii	"SenCmdQue\000"
 3351      6D645175 
 3351      6500
 3352 0806 0000     		.align	2
 3353              	.LC50:
 3354 0808 53656E53 		.ascii	"SenStatQue\000"
 3354      74617451 
 3354      756500
 3355 0813 00       		.align	2
 3356              	.LC51:
 3357 0814 33303A55 		.ascii	"30:UVC_app_thread\000"
 3357      56435F61 
 3357      70705F74 
 3357      68726561 
 3357      6400
 3358 0826 0000     		.align	2
 3359              	.LC52:
 3360 0828 33313A53 		.ascii	"31:Sen_ctrl_thread\000"
 3360      656E5F63 
 3360      74726C5F 
 3360      74687265 
 3360      616400
 3361 083b 00       		.section	.text.CyFxApplicationDefine,"ax",%progbits
 3362              		.align	2
 3363              		.global	CyFxApplicationDefine
 3365              	CyFxApplicationDefine:
 3366              	.LFB14:
1962:../CX3RDKOV5640.c **** }
1963:../CX3RDKOV5640.c **** 
1964:../CX3RDKOV5640.c **** 
1965:../CX3RDKOV5640.c **** /* Application define function which creates the threads. */
1966:../CX3RDKOV5640.c ****     void
1967:../CX3RDKOV5640.c **** CyFxApplicationDefine (
1968:../CX3RDKOV5640.c ****         void)
1969:../CX3RDKOV5640.c **** {
 3367              		.loc 1 1969 0
 3368              		.cfi_startproc
 3369              		@ args = 0, pretend = 0, frame = 64
 3370              		@ frame_needed = 1, uses_anonymous_args = 0
 3371 0000 10482DE9 		stmfd	sp!, {r4, fp, lr}
 3372              	.LCFI28:
 3373              		.cfi_def_cfa_offset 12
 3374              		.cfi_offset 4, -12
 3375              		.cfi_offset 11, -8
 3376              		.cfi_offset 14, -4
 3377 0004 08B08DE2 		add	fp, sp, #8
 3378              	.LCFI29:
 3379              		.cfi_def_cfa 11, 4
 3380 0008 64D04DE2 		sub	sp, sp, #100
1970:../CX3RDKOV5640.c ****     void *ptrUvc = NULL, *ptrSen = NULL;
 3381              		.loc 1 1970 0
 3382 000c 0030A0E3 		mov	r3, #0
 3383 0010 10300BE5 		str	r3, [fp, #-16]
 3384 0014 0030A0E3 		mov	r3, #0
 3385 0018 14300BE5 		str	r3, [fp, #-20]
1971:../CX3RDKOV5640.c ****     uint32_t retThrdCreate = CY_U3P_SUCCESS;
 3386              		.loc 1 1971 0
 3387 001c 0030A0E3 		mov	r3, #0
 3388 0020 18300BE5 		str	r3, [fp, #-24]
1972:../CX3RDKOV5640.c ****     VdRingBuf *cmdQuptr = &cmdQu, *statQuptr = &statQu;
 3389              		.loc 1 1972 0
 3390 0024 60319FE5 		ldr	r3, .L192
 3391 0028 1C300BE5 		str	r3, [fp, #-28]
 3392 002c 5C319FE5 		ldr	r3, .L192+4
 3393 0030 20300BE5 		str	r3, [fp, #-32]
1973:../CX3RDKOV5640.c ****     /* Create/initialize Ring buffers for Sensor control */
1974:../CX3RDKOV5640.c ****     char *cmdName = "SenCmdQue", *StatName = "SenStatQue";
 3394              		.loc 1 1974 0
 3395 0034 58319FE5 		ldr	r3, .L192+8
 3396 0038 24300BE5 		str	r3, [fp, #-36]
 3397 003c 54319FE5 		ldr	r3, .L192+12
 3398 0040 28300BE5 		str	r3, [fp, #-40]
1975:../CX3RDKOV5640.c ****     cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 3399              		.loc 1 1975 0
 3400 0044 40419FE5 		ldr	r4, .L192
 3401 0048 4C304BE2 		sub	r3, fp, #76
 3402 004c 48219FE5 		ldr	r2, .L192+16
 3403 0050 00208DE5 		str	r2, [sp]
 3404 0054 0300A0E1 		mov	r0, r3
 3405 0058 4010A0E3 		mov	r1, #64
 3406 005c 24201BE5 		ldr	r2, [fp, #-36]
 3407 0060 0030A0E3 		mov	r3, #0
 3408 0064 FEFFFFEB 		bl	cmdbufCreate
 3409 0068 04C0A0E1 		mov	ip, r4
 3410 006c 4CE04BE2 		sub	lr, fp, #76
 3411 0070 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 3412 0074 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 3413 0078 0F009EE8 		ldmia	lr, {r0, r1, r2, r3}
 3414 007c 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
1976:../CX3RDKOV5640.c **** 	cmdquInit(cmdQuptr);
 3415              		.loc 1 1976 0
 3416 0080 1C001BE5 		ldr	r0, [fp, #-28]
 3417 0084 FEFFFFEB 		bl	cmdquInit
1977:../CX3RDKOV5640.c **** 
1978:../CX3RDKOV5640.c ****     /* Allocate the memory for the thread and create the thread */
1979:../CX3RDKOV5640.c ****     ptrUvc = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 3418              		.loc 1 1979 0
 3419 0088 010AA0E3 		mov	r0, #4096
 3420 008c FEFFFFEB 		bl	CyU3PMemAlloc
 3421 0090 10000BE5 		str	r0, [fp, #-16]
1980:../CX3RDKOV5640.c ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 3422              		.loc 1 1980 0
 3423 0094 10301BE5 		ldr	r3, [fp, #-16]
 3424 0098 00308DE5 		str	r3, [sp]
 3425 009c 013AA0E3 		mov	r3, #4096
 3426 00a0 04308DE5 		str	r3, [sp, #4]
 3427 00a4 0830A0E3 		mov	r3, #8
 3428 00a8 08308DE5 		str	r3, [sp, #8]
 3429 00ac 0830A0E3 		mov	r3, #8
 3430 00b0 0C308DE5 		str	r3, [sp, #12]
 3431 00b4 0030A0E3 		mov	r3, #0
 3432 00b8 10308DE5 		str	r3, [sp, #16]
 3433 00bc 0130A0E3 		mov	r3, #1
 3434 00c0 14308DE5 		str	r3, [sp, #20]
 3435 00c4 A830A0E3 		mov	r3, #168
 3436 00c8 18308DE5 		str	r3, [sp, #24]
 3437 00cc CC009FE5 		ldr	r0, .L192+20
 3438 00d0 CC109FE5 		ldr	r1, .L192+24
 3439 00d4 CC209FE5 		ldr	r2, .L192+28
 3440 00d8 0030A0E3 		mov	r3, #0
 3441 00dc FEFFFFEB 		bl	_txe_thread_create
 3442 00e0 18000BE5 		str	r0, [fp, #-24]
1981:../CX3RDKOV5640.c ****             "30:UVC_app_thread",         /* Thread Id and name */
1982:../CX3RDKOV5640.c ****             esUVCUvcAppThread_Entry,          /* UVC Application Thread Entry function */
1983:../CX3RDKOV5640.c ****             0,                           /* No input parameter to thread */
1984:../CX3RDKOV5640.c ****             ptrUvc,                         /* Pointer to the allocated thread stack */
1985:../CX3RDKOV5640.c ****             UVC_APP_THREAD_STACK,        /* UVC Application Thread stack size */
1986:../CX3RDKOV5640.c ****             UVC_APP_THREAD_PRIORITY,     /* UVC Application Thread priority */
1987:../CX3RDKOV5640.c ****             UVC_APP_THREAD_PRIORITY,     /* Pre-emption threshold */
1988:../CX3RDKOV5640.c ****             CYU3P_NO_TIME_SLICE,         /* No time slice for the application thread */
1989:../CX3RDKOV5640.c ****             CYU3P_AUTO_START             /* Start the Thread immediately */
1990:../CX3RDKOV5640.c ****             );
1991:../CX3RDKOV5640.c **** 
1992:../CX3RDKOV5640.c ****     /* Check the return code */
1993:../CX3RDKOV5640.c ****     if (retThrdCreate != 0)
 3443              		.loc 1 1993 0
 3444 00e4 18301BE5 		ldr	r3, [fp, #-24]
 3445 00e8 000053E3 		cmp	r3, #0
 3446 00ec 0000000A 		beq	.L186
 3447              	.L187:
1994:../CX3RDKOV5640.c ****     {
1995:../CX3RDKOV5640.c ****         /* Thread Creation failed with the error code retThrdCreate */
1996:../CX3RDKOV5640.c **** 
1997:../CX3RDKOV5640.c ****         /* Add custom recovery or debug actions here */
1998:../CX3RDKOV5640.c **** 
1999:../CX3RDKOV5640.c ****         /* Application cannot continue */
2000:../CX3RDKOV5640.c ****         /* Loop indefinitely */
2001:../CX3RDKOV5640.c ****         while(1);
 3448              		.loc 1 2001 0 discriminator 1
 3449 00f0 FEFFFFEA 		b	.L187
 3450              	.L186:
2002:../CX3RDKOV5640.c ****     }
2003:../CX3RDKOV5640.c **** 
2004:../CX3RDKOV5640.c ****     ptrSen = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 3451              		.loc 1 2004 0
 3452 00f4 010AA0E3 		mov	r0, #4096
 3453 00f8 FEFFFFEB 		bl	CyU3PMemAlloc
 3454 00fc 14000BE5 		str	r0, [fp, #-20]
2005:../CX3RDKOV5640.c ****     retThrdCreate = CyU3PThreadCreate (&SenAppThread,   /* UVC Thread structure */
 3455              		.loc 1 2005 0
 3456 0100 14301BE5 		ldr	r3, [fp, #-20]
 3457 0104 00308DE5 		str	r3, [sp]
 3458 0108 013AA0E3 		mov	r3, #4096
 3459 010c 04308DE5 		str	r3, [sp, #4]
 3460 0110 0830A0E3 		mov	r3, #8
 3461 0114 08308DE5 		str	r3, [sp, #8]
 3462 0118 0830A0E3 		mov	r3, #8
 3463 011c 0C308DE5 		str	r3, [sp, #12]
 3464 0120 0030A0E3 		mov	r3, #0
 3465 0124 10308DE5 		str	r3, [sp, #16]
 3466 0128 0130A0E3 		mov	r3, #1
 3467 012c 14308DE5 		str	r3, [sp, #20]
 3468 0130 A830A0E3 		mov	r3, #168
 3469 0134 18308DE5 		str	r3, [sp, #24]
 3470 0138 6C009FE5 		ldr	r0, .L192+32
 3471 013c 6C109FE5 		ldr	r1, .L192+36
 3472 0140 6C209FE5 		ldr	r2, .L192+40
 3473 0144 0030A0E3 		mov	r3, #0
 3474 0148 FEFFFFEB 		bl	_txe_thread_create
 3475 014c 18000BE5 		str	r0, [fp, #-24]
2006:../CX3RDKOV5640.c ****             "31:Sen_ctrl_thread",         /* Thread Id and name */
2007:../CX3RDKOV5640.c ****             SenAppThread_Entry,          /* UVC Application Thread Entry function */
2008:../CX3RDKOV5640.c ****             0,                           /* No input parameter to thread */
2009:../CX3RDKOV5640.c ****             ptrSen,                         /* Pointer to the allocated thread stack */
2010:../CX3RDKOV5640.c ****             UVC_APP_THREAD_STACK,        /* UVC Application Thread stack size */
2011:../CX3RDKOV5640.c ****             UVC_APP_THREAD_PRIORITY,     /* UVC Application Thread priority */
2012:../CX3RDKOV5640.c ****             UVC_APP_THREAD_PRIORITY,     /* Pre-emption threshold */
2013:../CX3RDKOV5640.c ****             CYU3P_NO_TIME_SLICE,         /* No time slice for the application thread */
2014:../CX3RDKOV5640.c ****             CYU3P_AUTO_START             /* Start the Thread immediately */
2015:../CX3RDKOV5640.c ****             );
2016:../CX3RDKOV5640.c **** 
2017:../CX3RDKOV5640.c ****     /* Check the return code */
2018:../CX3RDKOV5640.c ****     if (retThrdCreate != 0)
 3476              		.loc 1 2018 0
 3477 0150 18301BE5 		ldr	r3, [fp, #-24]
 3478 0154 000053E3 		cmp	r3, #0
 3479 0158 0000000A 		beq	.L188
 3480              	.L189:
2019:../CX3RDKOV5640.c ****     {
2020:../CX3RDKOV5640.c ****         /* Thread Creation failed with the error code retThrdCreate */
2021:../CX3RDKOV5640.c **** 
2022:../CX3RDKOV5640.c ****         /* Add custom recovery or debug actions here */
2023:../CX3RDKOV5640.c **** 
2024:../CX3RDKOV5640.c ****         /* Application cannot continue */
2025:../CX3RDKOV5640.c ****         /* Loop indefinitely */
2026:../CX3RDKOV5640.c ****         while(1);
 3481              		.loc 1 2026 0 discriminator 1
 3482 015c FEFFFFEA 		b	.L189
 3483              	.L188:
2027:../CX3RDKOV5640.c ****     }
2028:../CX3RDKOV5640.c ****     /* Create GPIO application event group */
2029:../CX3RDKOV5640.c ****     retThrdCreate = CyU3PEventCreate(&glTimerEvent);
 3484              		.loc 1 2029 0
 3485 0160 50009FE5 		ldr	r0, .L192+44
 3486 0164 0010A0E3 		mov	r1, #0
 3487 0168 2820A0E3 		mov	r2, #40
 3488 016c FEFFFFEB 		bl	_txe_event_flags_create
 3489 0170 18000BE5 		str	r0, [fp, #-24]
2030:../CX3RDKOV5640.c ****     if (retThrdCreate != 0)
 3490              		.loc 1 2030 0
 3491 0174 18301BE5 		ldr	r3, [fp, #-24]
 3492 0178 000053E3 		cmp	r3, #0
 3493 017c 0000000A 		beq	.L185
 3494              	.L191:
2031:../CX3RDKOV5640.c ****     {
2032:../CX3RDKOV5640.c ****         /* Event group creation failed with the error code retThrdCreate */
2033:../CX3RDKOV5640.c **** 
2034:../CX3RDKOV5640.c ****         /* Add custom recovery or debug actions here */
2035:../CX3RDKOV5640.c **** 
2036:../CX3RDKOV5640.c ****         /* Application cannot continue */
2037:../CX3RDKOV5640.c ****         /* Loop indefinitely */
2038:../CX3RDKOV5640.c ****         while(1);
 3495              		.loc 1 2038 0 discriminator 1
 3496 0180 FEFFFFEA 		b	.L191
 3497              	.L185:
2039:../CX3RDKOV5640.c ****     }
2040:../CX3RDKOV5640.c **** }
 3498              		.loc 1 2040 0
 3499 0184 08D04BE2 		sub	sp, fp, #8
 3500              		@ sp needed
 3501 0188 1088BDE8 		ldmfd	sp!, {r4, fp, pc}
 3502              	.L193:
 3503              		.align	2
 3504              	.L192:
 3505 018c 00000000 		.word	cmdQu
 3506 0190 00000000 		.word	statQu
 3507 0194 FC070000 		.word	.LC49
 3508 0198 08080000 		.word	.LC50
 3509 019c 00000000 		.word	cmdQuMux
 3510 01a0 00000000 		.word	uvcAppThread
 3511 01a4 14080000 		.word	.LC51
 3512 01a8 00000000 		.word	esUVCUvcAppThread_Entry
 3513 01ac 00000000 		.word	SenAppThread
 3514 01b0 28080000 		.word	.LC52
 3515 01b4 00000000 		.word	SenAppThread_Entry
 3516 01b8 00000000 		.word	glTimerEvent
 3517              		.cfi_endproc
 3518              	.LFE14:
 3520              		.section	.text.main,"ax",%progbits
 3521              		.align	2
 3522              		.global	main
 3524              	main:
 3525              	.LFB15:
2041:../CX3RDKOV5640.c **** 
2042:../CX3RDKOV5640.c **** /*
2043:../CX3RDKOV5640.c ****  * Main function
2044:../CX3RDKOV5640.c ****  */
2045:../CX3RDKOV5640.c **** 
2046:../CX3RDKOV5640.c ****     int
2047:../CX3RDKOV5640.c **** main (void)
2048:../CX3RDKOV5640.c **** {
 3526              		.loc 1 2048 0
 3527              		.cfi_startproc
 3528              		@ args = 0, pretend = 0, frame = 48
 3529              		@ frame_needed = 1, uses_anonymous_args = 0
 3530 0000 00482DE9 		stmfd	sp!, {fp, lr}
 3531              	.LCFI30:
 3532              		.cfi_def_cfa_offset 8
 3533              		.cfi_offset 11, -8
 3534              		.cfi_offset 14, -4
 3535 0004 04B08DE2 		add	fp, sp, #4
 3536              	.LCFI31:
 3537              		.cfi_def_cfa 11, 4
 3538 0008 30D04DE2 		sub	sp, sp, #48
2049:../CX3RDKOV5640.c ****     CyU3PIoMatrixConfig_t io_cfg;
2050:../CX3RDKOV5640.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 3539              		.loc 1 2050 0
 3540 000c 0030A0E3 		mov	r3, #0
 3541 0010 08300BE5 		str	r3, [fp, #-8]
2051:../CX3RDKOV5640.c **** 
2052:../CX3RDKOV5640.c ****     /* Initialize the device */
2053:../CX3RDKOV5640.c ****     status = CyU3PDeviceInit (NULL);
 3542              		.loc 1 2053 0
 3543 0014 0000A0E3 		mov	r0, #0
 3544 0018 FEFFFFEB 		bl	CyU3PDeviceInit
 3545 001c 08000BE5 		str	r0, [fp, #-8]
2054:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3546              		.loc 1 2054 0
 3547 0020 08301BE5 		ldr	r3, [fp, #-8]
 3548 0024 000053E3 		cmp	r3, #0
 3549 0028 0000000A 		beq	.L195
2055:../CX3RDKOV5640.c ****     {
2056:../CX3RDKOV5640.c ****         goto handle_fatal_error;
 3550              		.loc 1 2056 0
 3551 002c 270000EA 		b	.L196
 3552              	.L195:
2057:../CX3RDKOV5640.c ****     }
2058:../CX3RDKOV5640.c **** 
2059:../CX3RDKOV5640.c ****     /* Initialize the caches. Enable instruction cache and keep data cache disabled.
2060:../CX3RDKOV5640.c ****      * The data cache is useful only when there is a large amount of CPU based memory
2061:../CX3RDKOV5640.c ****      * accesses. When used in simple cases, it can decrease performance due to large
2062:../CX3RDKOV5640.c ****      * number of cache flushes and cleans and also it adds to the complexity of the
2063:../CX3RDKOV5640.c ****      * code. */
2064:../CX3RDKOV5640.c ****     status = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 3553              		.loc 1 2064 0
 3554 0030 0100A0E3 		mov	r0, #1
 3555 0034 0010A0E3 		mov	r1, #0
 3556 0038 0020A0E3 		mov	r2, #0
 3557 003c FEFFFFEB 		bl	CyU3PDeviceCacheControl
 3558 0040 08000BE5 		str	r0, [fp, #-8]
2065:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3559              		.loc 1 2065 0
 3560 0044 08301BE5 		ldr	r3, [fp, #-8]
 3561 0048 000053E3 		cmp	r3, #0
 3562 004c 0000000A 		beq	.L197
2066:../CX3RDKOV5640.c ****     {
2067:../CX3RDKOV5640.c ****         goto handle_fatal_error;
 3563              		.loc 1 2067 0
 3564 0050 1E0000EA 		b	.L196
 3565              	.L197:
2068:../CX3RDKOV5640.c ****     }
2069:../CX3RDKOV5640.c **** 
2070:../CX3RDKOV5640.c ****     /* Configure the IO matrix for the device.*/
2071:../CX3RDKOV5640.c ****     io_cfg.isDQ32Bit = CyFalse;
 3566              		.loc 1 2071 0
 3567 0054 0030A0E3 		mov	r3, #0
 3568 0058 30300BE5 		str	r3, [fp, #-48]
2072:../CX3RDKOV5640.c **** 
2073:../CX3RDKOV5640.c ****     io_cfg.useUart   = CyTrue;
 3569              		.loc 1 2073 0
 3570 005c 0130A0E3 		mov	r3, #1
 3571 0060 2C300BE5 		str	r3, [fp, #-44]
2074:../CX3RDKOV5640.c ****     io_cfg.useI2C    = CyTrue;
 3572              		.loc 1 2074 0
 3573 0064 0130A0E3 		mov	r3, #1
 3574 0068 28300BE5 		str	r3, [fp, #-40]
2075:../CX3RDKOV5640.c ****     io_cfg.useI2S    = CyFalse;
 3575              		.loc 1 2075 0
 3576 006c 0030A0E3 		mov	r3, #0
 3577 0070 24300BE5 		str	r3, [fp, #-36]
2076:../CX3RDKOV5640.c ****     io_cfg.useSpi    = CyFalse;
 3578              		.loc 1 2076 0
 3579 0074 0030A0E3 		mov	r3, #0
 3580 0078 20300BE5 		str	r3, [fp, #-32]
2077:../CX3RDKOV5640.c ****     io_cfg.lppMode   = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 3581              		.loc 1 2077 0
 3582 007c 0030A0E3 		mov	r3, #0
 3583 0080 1A304BE5 		strb	r3, [fp, #-26]
2078:../CX3RDKOV5640.c ****     /* No GPIOs are enabled. */
2079:../CX3RDKOV5640.c ****     io_cfg.gpioSimpleEn[0]  = 0;
 3584              		.loc 1 2079 0
 3585 0084 0030A0E3 		mov	r3, #0
 3586 0088 18300BE5 		str	r3, [fp, #-24]
2080:../CX3RDKOV5640.c ****     io_cfg.gpioSimpleEn[1]  = 0;
 3587              		.loc 1 2080 0
 3588 008c 0030A0E3 		mov	r3, #0
 3589 0090 14300BE5 		str	r3, [fp, #-20]
2081:../CX3RDKOV5640.c ****     io_cfg.gpioComplexEn[0] = 0;
 3590              		.loc 1 2081 0
 3591 0094 0030A0E3 		mov	r3, #0
 3592 0098 10300BE5 		str	r3, [fp, #-16]
2082:../CX3RDKOV5640.c ****     io_cfg.gpioComplexEn[1] = 0;
 3593              		.loc 1 2082 0
 3594 009c 0030A0E3 		mov	r3, #0
 3595 00a0 0C300BE5 		str	r3, [fp, #-12]
2083:../CX3RDKOV5640.c ****     status = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 3596              		.loc 1 2083 0
 3597 00a4 30304BE2 		sub	r3, fp, #48
 3598 00a8 0300A0E1 		mov	r0, r3
 3599 00ac FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 3600 00b0 08000BE5 		str	r0, [fp, #-8]
2084:../CX3RDKOV5640.c ****     if (status != CY_U3P_SUCCESS)
 3601              		.loc 1 2084 0
 3602 00b4 08301BE5 		ldr	r3, [fp, #-8]
 3603 00b8 000053E3 		cmp	r3, #0
 3604 00bc 0000000A 		beq	.L198
2085:../CX3RDKOV5640.c ****     {
2086:../CX3RDKOV5640.c ****         goto handle_fatal_error;
 3605              		.loc 1 2086 0
 3606 00c0 020000EA 		b	.L196
 3607              	.L198:
2087:../CX3RDKOV5640.c ****     }
2088:../CX3RDKOV5640.c **** 
2089:../CX3RDKOV5640.c ****     /* This is a non returnable call for initializing the RTOS kernel */
2090:../CX3RDKOV5640.c ****     CyU3PKernelEntry ();
 3608              		.loc 1 2090 0
 3609 00c4 FEFFFFEB 		bl	_tx_initialize_kernel_enter
2091:../CX3RDKOV5640.c **** 
2092:../CX3RDKOV5640.c ****     /* Dummy return to make the compiler happy */
2093:../CX3RDKOV5640.c ****     return 0;
 3610              		.loc 1 2093 0
 3611 00c8 0030A0E3 		mov	r3, #0
 3612 00cc 000000EA 		b	.L200
 3613              	.L196:
2094:../CX3RDKOV5640.c **** 
2095:../CX3RDKOV5640.c **** handle_fatal_error:
2096:../CX3RDKOV5640.c ****     /* Cannot recover from this error. */
2097:../CX3RDKOV5640.c ****     while (1);
 3614              		.loc 1 2097 0 discriminator 1
 3615 00d0 FEFFFFEA 		b	.L196
 3616              	.L200:
2098:../CX3RDKOV5640.c **** }
 3617              		.loc 1 2098 0
 3618 00d4 0300A0E1 		mov	r0, r3
 3619 00d8 04D04BE2 		sub	sp, fp, #4
 3620              		@ sp needed
 3621 00dc 0088BDE8 		ldmfd	sp!, {fp, pc}
 3622              		.cfi_endproc
 3623              	.LFE15:
 3625              		.text
 3626              	.Letext0:
 3627              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 3628              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/cyu3ty
 3629              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/cyfx3_
 3630              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/tx_por
 3631              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/tx_api
 3632              		.file 7 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/cyu3dm
 3633              		.file 8 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/cyu3er
 3634              		.file 9 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/cyu3us
 3635              		.file 10 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/cyu3u
 3636              		.file 11 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/cyu3u
 3637              		.file 12 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/cyu3g
 3638              		.file 13 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\firmware\\u3p_firmware\\inc/cyu3m
 3639              		.file 14 "../cmdqu.h"
 3640              		.file 15 "../CX3RDKOV5640.h"
DEFINED SYMBOLS
                            *ABS*:00000000 CX3RDKOV5640.c
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:17     .bss.glEp0Buffer:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:20     .bss.glEp0Buffer:00000000 glEp0Buffer
                            *COM*:000000a8 uvcAppThread
                            *COM*:000000a8 SenAppThread
                            *COM*:00000028 glTimerEvent
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 statQuMux
                            *COM*:00000038 timMux
                            *COM*:00000038 imgHdMux
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:32     .bss.UvcTimer:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:35     .bss.UvcTimer:00000000 UvcTimer
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:38     .text.UvcAppProgressTimer:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:40     .text.UvcAppProgressTimer:00000000 UvcAppProgressTimer
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:69     .text.UvcAppProgressTimer:00000028 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:78     .bss.glDMATxCount:00000000 glDMATxCount
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:75     .bss.glDMATxCount:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:85     .bss.glDmaDone:00000000 glDmaDone
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:82     .bss.glDmaDone:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:91     .bss.glActiveSocket:00000000 glActiveSocket
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:92     .bss.glActiveSocket:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:98     .data.doLpmDisable:00000000 doLpmDisable
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:95     .data.doLpmDisable:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:105    .bss.glHitFV:00000000 glHitFV
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:102    .bss.glHitFV:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:112    .bss.glMipiActive:00000000 glMipiActive
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:109    .bss.glMipiActive:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:119    .bss.glIsClearFeature:00000000 glIsClearFeature
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:116    .bss.glIsClearFeature:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:126    .bss.glPreviewStarted:00000000 glPreviewStarted
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:123    .bss.glPreviewStarted:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:133    .data.glUVCHeader:00000000 glUVCHeader
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:130    .data.glUVCHeader:00000000 $d
                            *COM*:00000020 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:151    .data.glCurrentFrameIndex:00000000 glCurrentFrameIndex
                            *COM*:00000020 glStillCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:158    .data.glCurrentStillFrameIndex:00000000 glCurrentStillFrameIndex
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:164    .bss.glStillTriggerCtrl:00000000 glStillTriggerCtrl
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:165    .bss.glStillTriggerCtrl:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:170    .bss.glFrameIndexToSet:00000000 glFrameIndexToSet
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:171    .bss.glFrameIndexToSet:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:177    .bss.glStillCaptureStart:00000000 glStillCaptureStart
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:174    .bss.glStillCaptureStart:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:184    .bss.glStillCaptured:00000000 glStillCaptured
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:181    .bss.glStillCaptured:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:190    .bss.glStillSkip:00000000 glStillSkip
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:191    .bss.glStillSkip:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:197    .bss.glIsApplnActive:00000000 glIsApplnActive
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:194    .bss.glIsApplnActive:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:204    .bss.glIsConfigured:00000000 glIsConfigured
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:201    .bss.glIsConfigured:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:211    .bss.glIsStreamingStarted:00000000 glIsStreamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:208    .bss.glIsStreamingStarted:00000000 $d
                            *COM*:000000e8 glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:219    .bss.ES_UVC_STREAM_BUF_SIZE:00000000 ES_UVC_STREAM_BUF_SIZE
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:216    .bss.ES_UVC_STREAM_BUF_SIZE:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:226    .bss.ES_UVC_DATA_BUF_SIZE:00000000 ES_UVC_DATA_BUF_SIZE
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:223    .bss.ES_UVC_DATA_BUF_SIZE:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:232    .bss.ES_UVC_STREAM_BUF_COUNT:00000000 ES_UVC_STREAM_BUF_COUNT
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:233    .bss.ES_UVC_STREAM_BUF_COUNT:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:238    .data.g_IsAutoFocus:00000000 g_IsAutoFocus
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:244    .bss.glGet_Info:00000000 glGet_Info
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:245    .bss.glGet_Info:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:251    .bss.gl8GetControl:00000000 gl8GetControl
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:248    .bss.gl8GetControl:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:258    .bss.gl8SetControl:00000000 gl8SetControl
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:255    .bss.gl8SetControl:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:265    .bss.gl16GetControl:00000000 gl16GetControl
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:262    .bss.gl16GetControl:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:272    .bss.gl32GetControl:00000000 gl32GetControl
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:269    .bss.gl32GetControl:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:278    .bss.glcommitcount:00000000 glcommitcount
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:279    .bss.glcommitcount:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:284    .data.glcheckframe:00000000 glcheckframe
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:287    .text.esUVCAppErrorHandler:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:290    .text.esUVCAppErrorHandler:00000000 esUVCAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:316    .text.esUVCUvcAddHeader:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:318    .text.esUVCUvcAddHeader:00000000 esUVCUvcAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:369    .text.esUVCUvcAddHeader:00000074 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:374    .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:381    .text.esUVCUvcApplnStart:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:384    .text.esUVCUvcApplnStart:00000000 esUVCUvcApplnStart
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:513    .text.esUVCUvcApplnStart:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:533    .text.esUVCUvcApplnStop:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:536    .text.esUVCUvcApplnStop:00000000 esUVCUvcApplnStop
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:637    .text.esUVCUvcApplnStop:000000f4 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:656    .text.esUVCGpifCB:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:659    .text.esUVCGpifCB:00000000 esUVCGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:731    .text.esUVCGpifCB:000000ac $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:738    .text.esUVCUvcAppDmaCallback:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:741    .text.esUVCUvcAppDmaCallback:00000000 esUVCUvcAppDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:1038   .text.esUVCUvcAppDmaCallback:00000360 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:1058   .text.esUVCUvcApplnUSBEventCB:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:1060   .text.esUVCUvcApplnUSBEventCB:00000000 esUVCUvcApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:1090   .text.esUVCUvcApplnUSBEventCB:0000003c $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:1100   .text.esUVCUvcApplnUSBEventCB:0000005c $a
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:1222   .text.esUVCUvcApplnUSBEventCB:00000198 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:1233   .text.esUVCApplnLPMRqtCB:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:1235   .text.esUVCApplnLPMRqtCB:00000000 esUVCApplnLPMRqtCB
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:1280   .text.esSetCameraResolution:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:1283   .text.esSetCameraResolution:00000000 esSetCameraResolution
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:1440   .text.esSetCameraResolution:000001ac $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:1480   .text.esUVCUvcApplnUSBSetupCB:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:1482   .text.esUVCUvcApplnUSBSetupCB:00000000 esUVCUvcApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:2234   .text.esUVCUvcApplnUSBSetupCB:00000828 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:2350   .text.esUVCUvcApplnInit:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:2353   .text.esUVCUvcApplnInit:00000000 esUVCUvcApplnInit
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:3047   .text.esUVCUvcApplnInit:000007a8 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:3124   .text.esUVCUvcApplnDebugInit:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:3127   .text.esUVCUvcApplnDebugInit:00000000 esUVCUvcApplnDebugInit
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:3234   .text.esUVCUvcApplnDebugInit:00000104 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:3243   .text.esUVCUvcAppThread_Entry:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:3246   .text.esUVCUvcAppThread_Entry:00000000 esUVCUvcAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:3338   .text.esUVCUvcAppThread_Entry:000000d4 $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:3362   .text.CyFxApplicationDefine:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:3365   .text.CyFxApplicationDefine:00000000 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:3505   .text.CyFxApplicationDefine:0000018c $d
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:3521   .text.main:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccA2gnBS.s:3524   .text.main:00000000 main
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.29463082a45126943f020ea30bda05c8
                           .group:00000000 wm4.newlib.h.8.384a112feabb3bef7b573ae48cde2e3b
                           .group:00000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:00000000 wm4.config.h.219.8eb38badc3f446ace4f0fbbdc7b4e018
                           .group:00000000 wm4._ansi.h.23.5644b60c990a4800b02a6e654e88f93a
                           .group:00000000 wm4.stdint.h.20.54ad762faa59e3c05491630641c8d8bf
                           .group:00000000 wm4.cyu3types.h.80.f5310e165127de2daf78c334a454267e
                           .group:00000000 wm4.stdlib.h.18.8bab2fb43ac4e90235390733c30a4530
                           .group:00000000 wm4.stddef.h.184.aa65fb7281d578229bbad41b91862635
                           .group:00000000 wm4._default_types.h.6.5e12cd604db8ce00b62bb2f02708eaf3
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.59.db8450f33c1f6150c0372fa1091a887a
                           .group:00000000 wm4.stddef.h.348.9a99de77b6ba3b4278b57e9cc6d6e349
                           .group:00000000 wm4.reent.h.16.ec713094ff7b80200da61a1b94cca956
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.55.7091a050e07f1c4abd225630fe3d62f1
                           .group:00000000 wm4.stddef.h.39.d0197034aa5fd947cae140b9289e6734
                           .group:00000000 wm4.cdefs.h.56.efab90f4d89fbc41d6b3a5c5fb0d3d0f
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.string.h.126.6ff3aa59129e7f66b2c273baf353e066
                           .group:00000000 wm4.tx_port.h.95.54ef54ef950923016df123872c81f77f
                           .group:00000000 wm4.tx_api.h.90.d18ffa804751aa80b6d59c3d596c2234
                           .group:00000000 wm4.cyu3tx.h.61.421a5eac9b37f3e2677fcfe17ba1c9c3
                           .group:00000000 wm4.cyu3dma.h.569.521da17a880bb7dc9c063e240d18d9bc
                           .group:00000000 wm4.cyu3system.h.43.0fbd82548e591beefe95401c72410881
                           .group:00000000 wm4.cyu3usbconst.h.37.502980e110c2142a7316d50a53794397
                           .group:00000000 wm4.cyu3usb.h.302.ade7bb9b5b6e92c233eea1baf2851afa
                           .group:00000000 wm4.cyu3lpp.h.138.66435309bc2407b6684483dfed574450
                           .group:00000000 wm4.assert.h.11.060c3dc511517628fd4f958fa9448dce
                           .group:00000000 wm4.cyu3utils.h.45.ea1b88089ccad3d50489f6f768ad8e9f
                           .group:00000000 wm4.cyu3pib.h.192.a1483c513c81c352d6719814a4b66283
                           .group:00000000 wm4.cyu3descriptor.h.104.486178ff96f7d84792762d8905519d09
                           .group:00000000 wm4.cyu3socket.h.153.0d077cd39632ba9c913ec648cfa0f9e9
                           .group:00000000 wm4.sock_regs.h.24.15d70ab2b2a99b01b4189217fc091bd3
                           .group:00000000 wm4.cyu3sib.h.59.b1cff9a75023363cc612aef2b2314b23
                           .group:00000000 wm4.cyu3gpif.h.52.b01ef1bece12652336136a0aaabab45b
                           .group:00000000 wm4.cyu3mipicsi.h.46.b99df5b141b2543db3c56d6e408e0c5e
                           .group:00000000 wm4.cmdqu.h.19.d1373502bd3a7a56ccbd1736008f9f37
                           .group:00000000 wm4.CX3RDKOV5640.h.35.f7fe529c288b3942b3918d28808c5cde
                           .group:00000000 wm4.sensor.h.26.d38741ffaf0557280b1e48334d87d815
                           .group:00000000 wm4.uvc.h.35.a04ef8733ce74876578c7ba6b3d79b48

UNDEFINED SYMBOLS
_txe_event_flags_set
_tx_thread_sleep
CyU3PMemCopy
_txe_timer_deactivate
CyU3PUsbSetEpNak
CyFx3BusyWait
CyU3PUsbFlushEp
CyU3PDmaMultiChannelReset
CyU3PDebugPrint
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMControl
CyU3PGpifSMSwitch
CyU3PMipicsiWakeup
CyU3PMipicsiSleep
CyU3PUsbStall
CyU3PUsbLPMEnable
CyU3PDmaMultiChannelSetWrapUp
CyU3PUsbGetSpeed
CyU3PUsbLPMDisable
CyU3PUsbSetLinkPowerState
_txe_timer_activate
CyU3PDmaMultiChannelGetBuffer
CyU3PDmaMultiChannelCommitBuffer
_txe_timer_change
CyU3PMipicsiSetIntfParams
cfgUvc1080p30NoMclk
cfgUvcVga30NoMclk
cfgUvc720p60NoMclk
cfgUvc5Mp15NoMclk
CyU3PUsbAckSetup
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
SensorGetControl
UVCHandleProcessingUnitRqts
UVCHandleExtensionUnitRqts
glProbeCtrl
gl5MpProbeCtrl
gl720pProbeCtrl
glVga60ProbeCtrl
gl1080pProbeCtrl
glVga30ProbeCtrl
glStillProbeCtrl
CyU3PMipicsiInitializeI2c
CyU3PMipicsiInitializeGPIO
CyU3PMipicsiInitializePIB
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbRegisterLPMRequestCallback
CyU3PUsbSetDesc
CyU3PUsbVBattEnable
CyU3PUsbControlVBusDetect
CyU3PConnectState
CyU3PSetEpConfig
CyU3PUsbEPSetBurstMode
CyU3PDmaMultiChannelCreate
CyU3PMipicsiGpifLoad
CyU3PGpifRegisterCallback
CyU3PGpifSMStart
CyU3PMipicsiInit
_txe_timer_create
esUVCUSB30DeviceDscr
esUVCUSB20DeviceDscr
esUVCUSBBOSDscr
esUVCUSBDeviceQualDscr
esUVCUSBSSConfigDscr
esUVCUSBHSConfigDscr
esUVCUSBFSConfigDscr
esUVCUSBStringLangIDDscr
esUVCUSBManufactureDscr
esUVCUSBProductDscr
esUVCUSBConfigSSDscr
esUVCUSBConfigHSDscr
esUVCUSBConfigFSDscr
cfgUvcVgaNoMclk
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
_txe_event_flags_get
cmdbufCreate
cmdquInit
CyU3PMemAlloc
_txe_thread_create
_txe_event_flags_create
SenAppThread_Entry
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
